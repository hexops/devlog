<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>2024s on Hexops' devlog</title><link>https://devlog.hexops.com/2024/</link><description>Recent content in 2024s on Hexops' devlog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 09 Feb 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://devlog.hexops.com/2024/feed.xml" rel="self" type="application/rss+xml"/><item><title>Building the DirectX shader compiler better than Microsoft?</title><link>https://devlog.hexops.com/2024/building-the-directx-shader-compiler-better-than-microsoft/</link><pubDate>Fri, 09 Feb 2024 00:00:00 +0000</pubDate><guid>https://devlog.hexops.com/2024/building-the-directx-shader-compiler-better-than-microsoft/</guid><description>&lt;p>This is a &lt;del>story&lt;/del> nightmare about the messy state of Microsoft&amp;rsquo;s DirectX shader compiler, and trying to wrangle it into a nicer experience for game developers. In some respects, we now build the DXC compiler better than how Microsoft does.&lt;/p>
&lt;h2 id="setting-the-stage">Setting the stage&lt;/h2>
&lt;p>For &lt;a href="https://machengine.org">Mach engine&lt;/a> we&amp;rsquo;ve been building an &lt;a href="../mach-v0.3-released/#sysgpu">experimental graphics API called sysgpu&lt;/a> using Zig, aiming to be a &lt;em>successor&lt;/em> and &lt;em>descendant&lt;/em> of WebGPU for native graphics. It will support Metal, Vulkan, Direct3D, and OpenGL backends. As part of this, we need to compile shader programs into something that Direct3D 12 can consume. But what does it consume?&lt;/p>
&lt;h2 id="a-brief-history-lesson">A brief history lesson&lt;/h2>
&lt;p>The DirectX graphics API uses HLSL as its shading language of choice. In the past, with Direct3D 11 and earlier, this compiler was called &amp;lsquo;FXC&amp;rsquo; (the &amp;lsquo;effects compiler&amp;rsquo;)&lt;/p>
&lt;h3 id="fxc-is-deprecated-dxc-enters-the-scene-with-direct3d-12">FXC is deprecated, DXC enters the scene with Direct3D 12&lt;/h3>
&lt;p>Unfortunately, FXC as a compiler is rather notoriously slow among game developers, with suboptimal code generation - meaning shaders often both compile and execute fairly suboptimally.&lt;/p>
&lt;p>With the release of Direct3D 12 and Shader Model 6.0 (SM6), Microsoft officially deprecated the FXC compiler distributed as part of the Windows OS in favor of a new compiler called &amp;lsquo;DXC&amp;rsquo; (&amp;lsquo;directx compiler&amp;rsquo;), which exists as a public Microsoft-official fork of LLVM/Clang v3.7 &lt;a href="https://github.com/microsoft/DirectXShaderCompiler">Microsoft/DirectXShaderCompiler&lt;/a> and prebuilt binaries you can download.&lt;/p>
&lt;p>In this Microsoft fork of LLVM, changes are meticulously annotated via &lt;code>// HLSL Change Start&lt;/code> and &lt;code>// HLSL Change End&lt;/code> comments making it clear who owns what code:&lt;/p>
&lt;p>&lt;a class="imglink" href="https://devlog.hexops.com/img/2024/hlsl-change-start">&lt;img src="https://devlog.hexops.com/img/2024/hlsl-change-start.png">&lt;/a>&lt;/p>
&lt;h3 id="what-a-directx-driver-eats-for-breakfast-dxbc-or-dxil">What a DirectX driver eats for breakfast: DXBC or DXIL&lt;/h3>
&lt;p>Although HLSL is the language of choice for Direct3D programming, at the end of the day GPUs under the hood all have different compute architectures and requirements: the compiled binary form of a shader program that an Intel GPU needs is going to be different from what an NVIDIA GPU needs, same goes for AMD.&lt;/p>
&lt;p>Microsoft&amp;rsquo;s role is to provide the nice game developer frontend APIs (like Direct3D, and the HLSL shanding language), while working with independent hardware vendors (IHV&amp;rsquo;s) like Intel/AMD/NVIDIA who write the drivers - bridging those nice frontend APIs to whatever is hopefully closest to hardware manufacturer&amp;rsquo;s instruction set architecture (ISA) under the hood. You can think of it like web browsers making sure JavaScript can run on both a Windows PC and a macOS Apple Silicon device, though graphics developers would spit at the suggested comparison.&lt;/p>
&lt;p>DirectX versions 9-11 had driver manufacturers consuming what is called DXBC (DirectX Byte Code) - game developers would produce DXBC either using a CLI tool to compile their HLSL programs like &lt;code>fxc.exe&lt;/code>, or at runtime using the &lt;code>d3dcompiler&lt;/code> APIs, and then the driver&amp;rsquo;s job was to take that decently-optimized shader bytecode and turn it into the actual binary that the GPU would run. This bytecode was an undocumented, proprietary format really only shared between Microsoft and GPU driver manufacturers - excluding a few odd-ball Linux developers who cared to reverse engineer it for Proton.&lt;/p>
&lt;p>With the advent of DirectX 12 and Shader Model 6.0, Microsoft aspirationally had intended to create their own standard IR called DXIR, but in 2021 they &lt;a href="https://github.com/microsoft/DirectXShaderCompiler/commit/61c6573842be58a14e1dfc6b1b3def03d39d9988">removed all language suggesting they might do this&lt;/a>. The intent &lt;em>was&lt;/em> for DXIR to be the &amp;lsquo;high level&amp;rsquo;, &amp;lsquo;unoptimized&amp;rsquo; IR form which compilers (think: Rust) could target, and then the DXC compiler could lower DXIR into the optimized DXIL bytecode form, a new &amp;lsquo;low level&amp;rsquo; post-optimization IR format, before handing it off to graphics drivers to muck with as they please before it gets translated to run on the actual hardware.&lt;/p>
&lt;p>Asked about DXIR documentation, a &lt;a href="https://github.com/microsoft/DirectXShaderCompiler/issues/2389#issuecomment-517076643">Microsoft employee&lt;/a> had noted this in 2019:&lt;/p>
&lt;blockquote>
&lt;p>Unfortunately, documentation on the lowering process [from DXIR to DXIL] is mostly non-existent. [&amp;hellip;]&lt;/p>
&lt;p>Oh, and DXIR isn&amp;rsquo;t anything official, but just the first LLVM IR after CodeGen.&lt;/p>
&lt;/blockquote>
&lt;p>As you&amp;rsquo;ll soon see, this theme of &amp;lsquo;there are no docs, just whatever our compiler actually does&amp;rsquo; will become a common pattern.&lt;/p>
&lt;h3 id="dxil">DXIL&lt;/h3>
&lt;p>DXIL (pronunciation?) is the official format that DirectX 12 driver manufacturers consume &lt;em>today&lt;/em>.&lt;/p>
&lt;p>A game developer produces DXIL bytecode using the DXC compiler, which is a fork of LLVM/clang heavily modified to support HLSL compilation, and the DirectX APIs hand that DXIL over to the graphics driver which then converts the IR into their own intermediate languages, performing any secret sauce optimization passes on it, and ultimately boiling down to the actual machine code that will run on the GPU hardware.&lt;/p>
&lt;p>Much like the old bytecode format DXBC which DXIL replaced, it is &lt;em>also&lt;/em> an undocumented bytecode format, specifically it is LLVM&amp;rsquo;s version 3.7 post-codegen post-optimization-passes bitecode format. It is undocumented not because nobody wants to document it, but rather because the documentation is literally &amp;lsquo;whatever the Microsoft fork of LLVM v3.7 with all the HLSL changes we made, after CodeGen and optimization passes have occurred, actually emits as LLVM bitcode - plus a small custom container/wrapper file format on top.&amp;rsquo;&lt;/p>
&lt;h3 id="correcting-the-microsoft-fork-of-llvm">Correcting the Microsoft fork of LLVM&lt;/h3>
&lt;p>Microsoft themselves are well aware that a bunch of independent driver manufacturers relying on and expecting to consume a hyper-specific undocumented LLVM bitcode format specifically produced by their fork is, well, less than ideal - and also aware that their fork of LLVM is not super fun to maintain, either. Quoting &lt;a href="https://github.com/microsoft/DirectXShaderCompiler/issues/5773#issuecomment-1735794551">another Microsoft employee&lt;/a> (Sep 2023) who was asked about the potential of adding DirectX 9/10/11 support to the new/better DXC compiler, they stated:&lt;/p>
&lt;blockquote>
&lt;p>DXC&amp;rsquo;s fork of LLVM removed and/or damaged much of the code generation layer and infrastructure [of LLVM]. Given that, supporting DXBC generation in DXC would be a massive task to fix and restore broken LLVM functionality. Due to the large scale of this issue and resource constraints on our team we&amp;rsquo;re not going to address this issue in [the new] DXC [compiler] ever.&lt;/p>
&lt;p>We may support DXBC generation in Clang in the future (we mentioned that in the original proposal to LLVM). That work is unlikely to begin for a few years as our focus will be on supporting DXIL and SPIR-V generation first.&lt;/p>
&lt;/blockquote>
&lt;p>As noted above, in March of 2022, Microsoft had proposed and begun work on &lt;a href="https://discourse.llvm.org/t/rfc-adding-hlsl-and-directx-support-to-clang-llvm/60783">upstreaming HLSL compilation support directly into LLVM/clang proper&lt;/a> - work that is still ongoing today - and involved &lt;em>adding back&lt;/em> legacy LLVM v3.7 bitcode writing support to modern LLVM/clang versions:&lt;/p>
&lt;blockquote>
&lt;p>By isolating as much of the DXIL-specific code as possible into a target we hope to minimize the cost on the community to maintain our legacy bitcode writing support.&lt;/p>
&lt;/blockquote>
&lt;p>i.e. the plan to get away fromn their fork is to upstream HLSL and DXIL support to LLVM/clang proper.&lt;/p>
&lt;h2 id="the-challenge-for-gamedevs-webgpu-etc">The challenge for gamedevs, WebGPU, etc.&lt;/h2>
&lt;p>Graphics abstraction layers which aim to provide a unified interface to modern graphics APIs like Metal, Direct3D 12, and Vulkan.. ultimately need to provide a unified shading language as well. If you look today, you&amp;rsquo;ll find most WebGPU implementations which do this have had a goal of &amp;lsquo;in the future we might be able to emit DXIL directly..&amp;rsquo; but in practice, none actually do.&lt;/p>
&lt;p>Instead, basically every WebGPU implementation today behaves as follows:&lt;/p>
&lt;ul>
&lt;li>The WGSL textual language first gets translated to HLSL at runtime&lt;/li>
&lt;li>HLSL is compiled into DXBC or DXIL using an HLSL compiler&lt;/li>
&lt;li>The optimized DXBC/DXIL is handed to the graphics driver, which then gets converted to the various vendor-specific ILs before finally becoming machine code that runs on the GPU.&lt;/li>
&lt;/ul>
&lt;h3 id="a-quick-detour-spir-v">A quick detour: SPIR-V&lt;/h3>
&lt;p>Vulkan/SPIR-V does much the same as the above, in fact most drivers cannot assume SPIR-V is optimized at all - though some do, and this varies by mobile/desktop GPUs - and have more work to perform to get SPIR-V turned into a &lt;em>driver-compiled&lt;/em> native binary.&lt;/p>
&lt;p>Valve has &lt;a href="https://github.com/ValveSoftware/Fossilize">Fossilize&lt;/a> and maintains caches of each specific (GPU, driver version, etc.) pairing along with the &lt;em>actual&lt;/em> driver-compiled binary for a SPIR-V blob, to enable downloading &amp;lsquo;pre-cached shaders&amp;rsquo; from Valve servers ahead of playing games for this reason: so that you don&amp;rsquo;t spend all day waiting for your computer to go brrr compiling and optimizing SPIR-V shaders into actual native code your GPU understands.&lt;/p>
&lt;p>In other words, DXIL is always post-optimization-passes LLVM &lt;em>bitcode&lt;/em>, while SPIR-V can or cannot be an an optimized form, and GPU manufacturers write their drivers based on what SPIR-V looks like in the wild - which may or may not be a pre-optimized form. SPIR-V is closer to hardware than a textual shading language, but still very far from native machine code a GPU understands.&lt;/p>
&lt;p>Only Apple&amp;rsquo;s Metal graphics API supports compiling directly to the actual target hardware&amp;rsquo;s native binary format (thanks to that iron fist they hold over their hardware, I guess.)&lt;/p>
&lt;h2 id="to-use-dxcompilerdll-or-not">To use dxcompiler.dll or not?&lt;/h2>
&lt;p>Since WGSL-&amp;gt;HLSL-&amp;gt;DXIL is happening at runtime, WebGPU runtimes are faced with a challenge: do we use the new DXC HLSL compiler, or the old, officially deprecated FXC compiler which has worse performance and codegen quality? On the surface, this hardly sounds like a difficult choice!&lt;/p>
&lt;p>However, despite this, many indie devs and game engines choose to use FXC by default. &lt;a href="https://docs.rs/bevy/latest/i686-pc-windows-msvc/bevy/render/settings/enum.Dx12Compiler.html">Bevy game engine&amp;rsquo;s documentation&lt;/a> puts it really well:&lt;/p>
&lt;blockquote>
&lt;p>The Fxc compiler (default) is old, slow and unmaintained. However, it doesnâ€™t require any additional .dlls to be shipped with the application.&lt;/p>
&lt;p>The Dxc compiler is new, fast and maintained. However, it requires both &lt;code>dxcompiler.dll&lt;/code> and &lt;code>dxil.dll&lt;/code> to be shipped with the application. These files can be downloaded from &lt;a href="https://github.com/microsoft/DirectXShaderCompiler/releases">https://github.com/microsoft/DirectXShaderCompiler/releases&lt;/a>.&lt;/p>
&lt;/blockquote>
&lt;p>As a result, much software defaults to the old, slow and unmaintained compiler. And it&amp;rsquo;s not just Bevy: &lt;code>wgpu&lt;/code> Rust users, Dawn WebGPU users, etc. are all faced with this same question. It&amp;rsquo;s likely one of the reasons WebGPU does not support Shader Model 6.0+ functionality today - using the DXC compiler is not so pleasant: it is after all a large, clunky Microsoft fork of a C++ codebase from nearly a decade ago!&lt;/p>
&lt;h2 id="well-why-not-just-statically-link-against-it">Well, why not just statically link against it?&lt;/h2>
&lt;p>You can&amp;rsquo;t.&lt;/p>
&lt;p>Firstly, there is the issue that &lt;a href="https://github.com/microsoft/DirectXShaderCompiler/issues/4766">Microsoft&amp;rsquo;s fork of LLVM doesn&amp;rsquo;t support statically linking&lt;/a>. On the surface, this appears just to be due to some cmake files assuming &lt;code>SHARED&lt;/code> instead of &lt;code>STATIC&lt;/code> when creating libraries, but if you dig into it - as I did - you&amp;rsquo;ll soon find it is &lt;em>much&lt;/em> more involved than that.&lt;/p>
&lt;p>Switching &lt;code>SHARED&lt;/code> to &lt;code>STATIC&lt;/code> everywhere in CMake files will appear to get you a build with ~15 different static libraries to link against (not pleasant compared to just one.) You might think using cmake &lt;code>OBJECT&lt;/code> libraries could solve this, but with this you will quickly encounter an issue where although the cmake files are structured logically as dependants, they actually have implicit dependencies on eachother due to the HLSL changes Microsoft made. I am 80% sure you would need to rewrite every cmake file in the repository to support OBJECT libraries. I can say this, because I tried!&lt;/p>
&lt;p>You might be thinking, linking against ~15 static libraries isn&amp;rsquo;t SO bad as long as the final executable is static, right?&lt;/p>
&lt;p>Not so fast - many parts of DXC&amp;rsquo;s COM interface implementation is also explicitly designed to load itself as a DLL, i.e. to load &lt;code>dxcompiler.dll&lt;/code> and &lt;code>dxil.dll&lt;/code> as dynamic libraries and self-invoke methods.&lt;/p>
&lt;p>OK, we just need to patch the implementation to not call &lt;code>LoadLibraryW&lt;/code> then, basically, right?&lt;/p>
&lt;h2 id="introducing-dxildll---the-proprietary-code-signing-blob-for-directx-shaders">Introducing dxil.dll - the proprietary code signing blob for DirectX shaders&lt;/h2>
&lt;p>If you&amp;rsquo;ve ever built DirectXShaderCompiler from source, you might notice something: dxil.dll doesn&amp;rsquo;t get built. Why? It&amp;rsquo;s distributed in every release on GitHub, both for Windows (x86/arm) and Linux (x86 only).&lt;/p>
&lt;p>Strange, I thought the compiler was supposed to be open source? Well, it wouldn&amp;rsquo;t be the first time&lt;a href="https://github.com/microsoft/win32metadata/issues/766#issuecomment-1150271300">[0]&lt;/a>&lt;a href="https://github.com/microsoft/Azure-Kinect-Sensor-SDK/issues/1521">[1]&lt;/a> I&amp;rsquo;ve encountered a Microsoft &amp;lsquo;open source&amp;rsquo; repository that actually completely depends on some proprietary platform-specific code blobs behind the scenes.&lt;/p>
&lt;p>Incidentally, I stumbled across the &lt;a href="https://microsoft.github.io/DirectX-Specs/d3d/ShaderCache.html">D3D12 Shader Cache API specification&lt;/a> which mentions the existence of this proprietary code signing blob as a &amp;lsquo;good reason for invoking the shader compiler at runtime&amp;rsquo;:&lt;/p>
&lt;blockquote>
&lt;p>D3D12 will only accept signed shaders. That means that if any patching or runtime optimizations are performed, such as constant folding, the shader must be re-validated and re-signed, which is non-trivial.&lt;/p>
&lt;/blockquote>
&lt;p>And in the recent &lt;a href="https://github.com/microsoft/DirectXShaderCompiler/releases/tag/v1.8.2306-preview">&amp;lsquo;preview release&amp;rsquo; for Shader Model 6.8 functionality&lt;/a>, Microsoft notes how they appear to leverage this DLL to restrict new experimental shader functionality:&lt;/p>
&lt;blockquote>
&lt;p>The DXIL signing library (dxil.dll/libdxil.so) is not provided with this preview release. DXIL generated with this compiler targeting Shader Model 6.8 is not final, cannot be validated, and is not supported for distribution or execution on machines not running in developer mode.&lt;/p>
&lt;/blockquote>
&lt;p>In other words: if you do not have dxil.dll, then your shaders will not be signed/validated. If your shaders are not signed/validated, then they cannot run on a Windows machine unless it is running in Developer Mode.&lt;/p>
&lt;h2 id="platform-support-challenges">Platform support challenges&lt;/h2>
&lt;p>For a second, I&amp;rsquo;d like to go back to something I wrote at the start of this article:&lt;/p>
&lt;blockquote>
&lt;p>For &lt;a href="https://machengine.org">Mach engine&lt;/a> [&amp;hellip;] we need to compile shader programs into something that Direct3D 12 can consume.&lt;/p>
&lt;/blockquote>
&lt;p>I&amp;rsquo;d like for us to be able to perform offline shader compilation, and skip out on distributing the heavy DXC dependency, when desired.&lt;/p>
&lt;p>But Microsoft only distributes a copy of dxil.dll for Windows (x86/arm) and Linux (x86). There&amp;rsquo;s no Linux aarch64 binary. There&amp;rsquo;s no macOS binary. In other words, you can&amp;rsquo;t produce builds of your cross-platform game for Windows using offline shader compilation on a mac, or in your Arm Linux CI pipeline. You need a Windows or x86_64 Linux machine to run the proprietary blob.&lt;/p>
&lt;h2 id="recap">Recap&lt;/h2>
&lt;p>To recap:&lt;/p>
&lt;ul>
&lt;li>We cannot build DXC as a static library, because the decades-old Microsoft fork of LLVM v3.7 has a very messy build-system.&lt;/li>
&lt;li>Even if we could, we cannot build DXC as a static library &lt;strong>because of the proprietary code-signing blob&lt;/strong>.&lt;/li>
&lt;li>We cannot compile DirectX HLSL shaders offline on a Mac, or build our cross-platform game in an arm Linux CI pipeline, because Microsoft doesn&amp;rsquo;t distribute copies of &lt;strong>the proprietary code signing blob&lt;/strong> for those platforms.&lt;/li>
&lt;/ul>
&lt;h2 id="going-deeper">Going deeper&lt;/h2>
&lt;h3 id="un-the-build-system">Un#$@&amp;amp;%*! the build system&lt;/h3>
&lt;p>The first problem I wanted to address was how to actually build this codebase into a single static library.&lt;/p>
&lt;p>After several days of attempting to fix the implicit dependencies that changing the cmake virtual libraries from &lt;code>DYNAMIC&lt;/code> -&amp;gt; &lt;code>OBJECT&lt;/code> surfaces, I gave up. Originally, my intent was to use their existing cmake build system (so as to not diverge from their codebase too much) and just swap the compiler with &lt;code>zig cc&lt;/code> as the build toolchain for cross-compilation.&lt;/p>
&lt;p>After it slowly and painfully became apparent that direction was not going to be &lt;em>any&lt;/em> better than maintaining the entire buildsystem myself, I decided to just bite the bullet and rewrite the entire CMake build system they had, some ~10.5k lines of code, using &lt;code>build.zig&lt;/code> instead. To make things simpler, I chose to build only the two parts we (and others) really care about as consumers of the code: the &lt;code>dxcompiler.dll&lt;/code> library, and &lt;code>dxc.exe&lt;/code> binary for offline compilation / testing. (we&amp;rsquo;ll deal with &lt;code>dxil.dll&lt;/code> later.)&lt;/p>
&lt;p>This resulted in somewhere around &lt;a href="https://github.com/hexops/mach-dxcompiler/blob/bd0cfbe4230133d8d3b50eedf1a0d0c4a00f47d7/build.zig#L1-L956">~1k lines of build.zig logic&lt;/a>, and in practice it&amp;rsquo;s less than that because much of it is just related to running &lt;code>git clone&lt;/code> on the source repository, having the ability for Zig package consumers to use a prebuilt binary instead of building the large C++ library from source, and header/source generation (though we&amp;rsquo;re still not done with that, thanks to llvm-tablegen)&lt;/p>
&lt;h3 id="un-the-dynamic-library-dependency">Un#$@&amp;amp;%*! the dynamic library dependency&lt;/h3>
&lt;p>As mentioned earlier, DXC is written with the expectation that &lt;code>dxcompiler.dll&lt;/code> and &lt;code>dxil.dll&lt;/code> exist. Reading the code, it almost appears as if the COM API implementation invokes the DLL, which then invokes itself dynamically depending on which is available.&lt;/p>
&lt;p>Taking some advice from Microsoft, I got my hands dirty, &lt;em>forked their codebase&lt;/em> and got to work on the actual C++ code. I began annotating my changes with cute &lt;code>// Mach change start&lt;/code> and &lt;code>// Mach change end&lt;/code> comments, to know who owns what code. All of this existing as a choice that I hope will come back to haunt my dreams in the future as much as Microsoft&amp;rsquo;s own choice to underemploy the HLSL team and fork LLVM 3.7 originally.&lt;/p>
&lt;p>I was off to the races: &lt;a href="https://github.com/hexops/DirectXShaderCompiler/blob/4190bb0c90d374c6b4d0b0f2c7b45b604eda24b6/tools/clang/tools/dxcompiler/DXCompiler.cpp#L88">simulating dllmain&lt;/a> entrypoints, &lt;a href="https://github.com/hexops/DirectXShaderCompiler/blob/4190bb0c90d374c6b4d0b0f2c7b45b604eda24b6/tools/clang/tools/dxclib/dxc.cpp#L1258">disabling&lt;/a> the ability to print the compiler version info derived from the dlls, and &lt;a href="https://github.com/hexops/DirectXShaderCompiler/blob/4190bb0c90d374c6b4d0b0f2c7b45b604eda24b6/include/dxc/Support/dxcapi.use.h#L17">emulating dynamic library function pointer loads&lt;/a>.&lt;/p>
&lt;h3 id="un-the-proprietary-code-signing">Un#$@&amp;amp;%*! the proprietary code signing&lt;/h3>
&lt;p>All that was left was that pesky &lt;code>dxil.dll&lt;/code> - what sort of magic might Microsoft be employing in that library to &amp;ldquo;sign shaders&amp;rdquo;? How can they prevent unsigned shaders from running on Windows machines that aren&amp;rsquo;t in developer mode? How are they able to distribute that binary on Linux, too?&lt;/p>
&lt;p>I won&amp;rsquo;t comment on any of those questions, but will say that &lt;a href="https://github.com/hexops/DirectXShaderCompiler/blob/4190bb0c90d374c6b4d0b0f2c7b45b604eda24b6/tools/clang/tools/dxcompiler/MachSiegbertVogtDXCSA.cpp#L178">you&amp;rsquo;ll find dxil.dll is NOT a dependency of mach-dxcompiler in any form&lt;/a>. You can compile an HLSL shader on a macOS machine using mach-dxcompiler, without the proprietary &lt;code>dxil.dll&lt;/code> blob - and end up with a DXIL bytecode file that is byte-for-byte equal to one which runs it on a standard Windows box. Enjoy!&lt;/p>
&lt;h2 id="results">Results&lt;/h2>
&lt;p>We now have prebuilt, static binaries of the &lt;code>dxcompiler&lt;/code> library, as well as the &lt;code>dxc&lt;/code> CLI &lt;a href="https://github.com/hexops/mach-dxcompiler/releases/tag/2024.02.10%2B2c3635c.1">here&lt;/a>, with zero dependency on the proprietary &lt;code>dxil.dll&lt;/code>. At the time of writing, we have binaries building in our CI pipeline for:&lt;/p>
&lt;ul>
&lt;li>macOS (the first ever in history), both Apple Silicon (aarch64) and Intel (x86_64).&lt;/li>
&lt;li>Linux, including musl and glibc, as well as aarch64 (first ever in history) and x86_64.&lt;/li>
&lt;li>Windows, x86_64 and aarch64, including for MinGW/GNU ABI (first ever in history?)&lt;/li>
&lt;/ul>
&lt;p>Additionally included is a &lt;a href="https://github.com/hexops/mach-dxcompiler/blob/main/src/mach_dxc.h">small C API&lt;/a> the library now exposes, as an alternative to the COM API traditionally required.&lt;/p>
&lt;p>Zig game developers will find the repository also includes a Zig API, see &lt;a href="https://github.com/hexops/mach-dxcompiler/blob/main/src/main.zig">&lt;code>src/main.zig&lt;/code>&lt;/a> tests for usage. By default prebuilt binaries are downloaded/used.&lt;/p>
&lt;p>You can &lt;a href="https://github.com/hexops/mach-dxcompiler">build from source yourself&lt;/a> for any OS/arch with only &lt;code>zig&lt;/code> and &lt;code>git&lt;/code>, just make sure you have &lt;a href="https://machengine.org/about/zig-version/">the right Zig version&lt;/a>:&lt;/p>
&lt;pre>&lt;code>git clone https://github.com/hexops/mach-dxcompiler
cd mach-dxcompiler/
zig build -Dfrom_source -Dtarget=aarch64-macos
zig build -Dfrom_source -Dtarget=x86_64-windows-gnu
zig build -Dfrom_source -Dtarget=x86_64-linux-gnu
&lt;/code>&lt;/pre>&lt;h2 id="caveats">Caveats&lt;/h2>
&lt;p>It&amp;rsquo;s not all roses - there are some drawbacks:&lt;/p>
&lt;ul>
&lt;li>Windows MSVC ABI binaries are currently not building due to a small bug in the C bindings - will fix it quickly if important for you, otherwise at our own pace.&lt;/li>
&lt;li>Linux musl binaries are untested, they build fine and I&amp;rsquo;d be curious to know if they run fine!&lt;/li>
&lt;li>With Mach engine, we plan to use Zig itself as our shading language, not HLSL, so I do not build SPIRV-output support, sorry! I have no plans to add it.&lt;/li>
&lt;li>No plans to update this to support SM6.7 currently (released very recently), though perhaps in the future.&lt;/li>
&lt;li>LLVM&amp;rsquo;s cmake build system is not trivial, there are some aspects yet-to-be-translated. See &lt;code>generated-include/&lt;/code> for specifics which come from the cmake build system still.&lt;/li>
&lt;li>If you use this, you&amp;rsquo;ll be relying on myself to fix/address any issues. I am the only person working on this, and it exists solely to solve Mach&amp;rsquo;s own problems. If it works for you, great - but there may be a time we find a better path forward for us and it could get deprecated, so keep that in mind.&lt;/li>
&lt;/ul>
&lt;h2 id="on-a-personal-note">On a personal note&lt;/h2>
&lt;div style="display: flex;">
&lt;a href="https://github.com/slimsag">
&lt;img style="width: 420px" src="https://machengine.org/img/slimsag-profile.png">
&lt;/a>
&lt;div>
&lt;p>My name is Stephen, I work a normal tech job, and after signing off from work at the end of the day I go online to build &lt;a href="https://machengine.org/">Mach engine&lt;/a>. I've been dreaming of being able to build a game engine like this for a long time, and I'm finally doing it!&lt;/p>
&lt;p>FOSS &lt;a href="https://devlog.hexops.com/2021/increasing-my-contribution-to-zig-to-200-a-month#i-grew-up-playing-linux-games-like-mania-drive">is in my roots&lt;/a>, I believe we should own our tools, they should empower &lt;em>us&lt;/em>-not be part of &lt;a href="https://kristoff.it/blog/the-open-source-game/">the 'open source' game&lt;/a> which is all too prevelant today (even among 'open source' engines.) I &lt;em>need&lt;/em> Mach to genuinely be &lt;a href="https://softwareyoucan.love">software you can love&lt;/a>.&lt;/p>
&lt;p>My dream is one day to live a simple, modest, life earning a living building Mach for everyone and selling high-quality games. Please consider &lt;a href="https://github.com/sponsors/slimsag">sponsoring my work&lt;/a> if you believe in my vision. It means the world to me!&lt;/p>
&lt;/div>
&lt;/div>
&lt;h2 id="thanks-for-reading">Thanks for reading&lt;/h2>
&lt;div style="display: flex; flex-direction: row; align-items: center;">
&lt;img align="left" style="max-height: 12.5rem;" src="https://user-images.githubusercontent.com/3173176/187348488-0b52e87d-3a48-421c-9402-be78e32b5a20.png">&lt;/img>
&lt;ul>
&lt;li>Check out &lt;a href="https://machengine.org">machengine.org&lt;/a>&lt;/li>
&lt;li>Consider &lt;a href="https://github.com/sponsors/slimsag">sponsoring development&lt;/a> so we can do more of it!&lt;/li>
&lt;li>Join the &lt;a href="https://discord.gg/XNG3NZgCqp">Mach Discord server&lt;/a>&lt;/li>
&lt;/ul>
&lt;/div></description></item><item><title>Mach v0.3 released - Zig game engine &amp; graphics toolkit</title><link>https://devlog.hexops.com/2024/mach-v0.3-released/</link><pubDate>Fri, 02 Feb 2024 00:00:00 +0000</pubDate><guid>https://devlog.hexops.com/2024/mach-v0.3-released/</guid><description>&lt;p>Mach is a Zig game engine &amp;amp; graphics toolkit for building high-performance &amp;amp; modular games, visualizations, and desktop/mobile apps. &lt;a href="https://machengine.org/">Learn more&lt;/a>&lt;/p>
&lt;p>We are working towards Mach 1, and have just released v0.3 which includes &lt;a href="https://github.com/hexops/mach/milestone/5?closed=1">6 months of work&lt;/a> - here are the highlights!&lt;/p>
&lt;h2 id="coming-soon-intro-to-2d-gamedev-workshop">Coming soon: intro to 2D gamedev workshop&lt;/h2>
&lt;p>The first-ever &lt;strong>intro to 2D gamedev workshop using Mach&lt;/strong> will be hosted at the &lt;a href="https://sycl.it/">Software You Can Love&lt;/a> conference in Milan, Italy, May 14-17. The workshop will use Mach&amp;rsquo;s currently in-development higher level 2D graphics APIs.&lt;/p>
&lt;p>&lt;a class="imglink" href="https://sycl.it/">&lt;img src="https://devlog.hexops.com/img/2024/sycl-workshop.png">&lt;/a>&lt;/p>
&lt;p>If you&amp;rsquo;re interested in Zig or Mach, then &lt;a href="https://sycl.it/agenda/workshops/intro-to-2d-gamedev/">check out the SYCL conference&lt;/a>! It&amp;rsquo;s an amazing experience, a great opportunity to meet a ton of Zig community members, core team members, as well as enjoy some of the best food that Italy has to offer!&lt;/p>
&lt;h2 id="community-highlight-pixi-and-scoopems">Community highlight: Pixi and Scoop&amp;rsquo;ems&lt;/h2>
&lt;p>&lt;a href="https://github.com/foxnne">@foxxne&lt;/a> is an early adopter of &lt;a href="https://machengine.org/core/">Mach core&lt;/a>, largely pushing it to its limits. They make use of Mach&amp;rsquo;s new experimental sysgpu graphics API (which we intend to be a successor/descendant of WebGPU), as well as other libraries like flecs and dear-imgui. They&amp;rsquo;re developing &lt;a href="https://github.com/foxnne/pixi">Pixi&lt;/a> - a pixel art editor:&lt;/p>
&lt;p>&lt;a class="imglink" href="https://devlog.hexops.com/img/2024/pixi1.png">&lt;img src="https://devlog.hexops.com/img/2024/pixi1.png">&lt;/a>
&lt;a class="imglink" href="https://devlog.hexops.com/img/2024/pixi2.png">&lt;img src="https://devlog.hexops.com/img/2024/pixi2.png">&lt;/a>&lt;/p>
&lt;p>And have used it to make games like &lt;a href="https://github.com/foxnne/scoop-ems">Scoop&amp;rsquo;ems&lt;/a>:&lt;/p>
&lt;video loop controls height="4000px">
&lt;source src="https://media.machengine.org/showcase/scoopems.mp4" type="video/mp4">
&lt;/video>
&lt;p>&lt;a href="https://github.com/sponsors/foxnne">@foxxne&lt;/a> is making awesome tools and games in Zig, pushing things to their limits, I encourage watching &lt;a href="https://www.youtube.com/watch?v=7K9Vzcr7vJg">how humble Colton is when speaking about their work&lt;/a>. We are very excited to make Mach support foxxne&amp;rsquo;s projects better in the future, and enable others to build things like this too.&lt;/p>
&lt;p>Please consider &lt;a href="https://github.com/sponsors/foxnne">sponsoring their work on GitHub&lt;/a> - you could be their second-ever sponsor!&lt;/p>
&lt;h2 id="mach-core">Mach core&lt;/h2>
&lt;p>&lt;a href="https://machengine.org/core/">Mach core&lt;/a> aims to provide just a window, input, and truly cross-platform graphics API.&lt;/p>
&lt;p>We think of it as an alternative/competitor to the classic options of SDL+OpenGL, GLFW+Vulkan, etc. Today, it&amp;rsquo;s not quite there yet - it uses GLFW behind the scenes for desktop support, and WebGPU as its graphics API, but we&amp;rsquo;re actively working on making it a genuine competitor written in Zig.&lt;/p>
&lt;p>In this release, it saw general bug fixes - as well as some &lt;a href="https://github.com/hexops/libmach">libmach&lt;/a> development - which aims to provide a C API to both Mach core and engine APIs.&lt;/p>
&lt;h2 id="sysgpu">sysgpu&lt;/h2>
&lt;p>In Mach v0.2, we announced an experiment - that we were working on a WebGPU implementation written in Zig, as an alternative to using Dawn (Google Chrome&amp;rsquo;s WebGPU implementation.) In the past 6 months, this experiment saw an immense amount of development and exceeded our expectations!&lt;/p>
&lt;a class="imglink" href="https://machengine.org/pkg/mach-sysgpu">
&lt;picture>&lt;source media="(prefers-color-scheme: dark)" srcset="https://machengine.org/assets/mach/sysgpu-dark.svg">&lt;img alt="mach-sysgpu" src="https://machengine.org/assets/mach/sysgpu-light.svg" style="height:7rem;margin-top:1rem">&lt;/picture>
&lt;/a>
&lt;p>&lt;a href="https://machengine.org/pkg/mach-sysgpu/">sysgpu&lt;/a> today is a nearly fully-functional WebGPU native implementation (minus browser-level safety checks), thanks to &lt;a href="https://github.com/hexops/mach-sysgpu/graphs/contributors">two amazing contributors&lt;/a>. It has functional D3D12, Vulkan, Metal, and OpenGL backends. It has it&amp;rsquo;s own WGSL shader compiler, and nearly all mach-core examples are runnable using it. We&amp;rsquo;ve even seen real applications (the Pixi pixel editor from foxxne, for example) begin to adopt it.&lt;/p>
&lt;p>As we continued development of it over the past six months, we identified key design tradeoffs where we could differ from WebGPU&amp;rsquo;s API choices and gain a faster, more modern, featureful graphics API. As a result, we&amp;rsquo;ve come to view sysgpu as a leaner and meaner &lt;em>successor and descendant of&lt;/em> WebGPU for native graphics, rather than just another implementation of it. As a result, it builds on the back of WebGPU&amp;rsquo;s design choices, but ultimately has its own distinct API and will not be ABI-compatible.&lt;/p>
&lt;p>We have plans to alleviate some &lt;em>major&lt;/em> pain points of WebGPU, specifically around pipeline creation / descriptor boilerplate, supporting push constants when available via a better API design (not as an extension), a more integrated/seamless approach to binding resources to shaders with type-correctness, and more.&lt;/p>
&lt;p>We are also evaluating using Zig itself as the shading language, instead of WGSL, and are looking to enable fully offline shader compilation as an optional feature.&lt;/p>
&lt;p>sysgpu is still under heavy development, particularly all of the &amp;lsquo;successor/descendant&amp;rsquo; API design choices noted above have not been implemented yet. It is disabled in the v0.3 release by default, and after this release we plan to invest more aggressively in it - so expect more details and specifics to come soon.&lt;/p>
&lt;h2 id="sysaudio">sysaudio&lt;/h2>
&lt;p>As a bit of background, &lt;a href="https://machengine.org/pkg/mach-sysaudio/">mach-sysaudio&lt;/a> started out as Zig bindings to Andrew Kelley&amp;rsquo;s fantastic C library &lt;a href="https://github.com/andrewrk/libsoundio">libsoundio&lt;/a>, but ultimately it grew to stand on its own two feet - becoming a brand new library written in Zig from first-principles and the ground-up to achieve similar goals: providing just low-level audio input/output, nothing else. It saw a good deal of polish in this iteration:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/hexops/mach-sysaudio/pull/33">SIMD sample conversion support&lt;/a> - and sample conversion is now explicitly optional (so the default is to work with the driver&amp;rsquo;s active audio format.)&lt;/li>
&lt;li>Major API design improvements&lt;/li>
&lt;li>Fixed issues with microphone/input devices, specifically multi-channel devices on macOS with CoreAudio.&lt;/li>
&lt;li>Fixed &lt;a href="https://github.com/hexops/mach/issues?q=is%3Aissue+sysaudio+is%3Aclosed+milestone%3A%22Mach+0.3%22">various issues&lt;/a> with the WASAPI/Windows backend.&lt;/li>
&lt;/ul>
&lt;h3 id="audio-synthesizer-hack-project">Audio synthesizer hack-project&lt;/h3>
&lt;p>As a quick hack project over the holidays, I leveraged Mach&amp;rsquo;s audio libraries, reading midi input from a piano keyboard, synthesizing audio using Zig code / Mach, and playing it back through digital piano speakers. Here&amp;rsquo;s a few vertical videos of me being silly &amp;amp; having fun with it (skip to 2:24 to hear how I think a Ziguana might sound!):&lt;/p>
&lt;iframe width="720" height="480" src="https://www.youtube.com/embed/b8WDjaZC1C8?si=SgojGMwdD_lfncgn" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen>&lt;/iframe>
&lt;h2 id="nominated-zig-versions">Nominated Zig versions&lt;/h2>
&lt;p>Mach has always needed a sweet-spot between stable Zig and nightly Zig, a better balance of latest-and-greatest features and bug fixes, but less of a moving target than nightly Zig. To address this, we formalized how we &lt;a href="https://devlog.hexops.com/2024/announcing-nominated-zig/">nominate Zig versions&lt;/a> for use, enabling others to synchronize their Zig version with the one Mach supports more easily.&lt;/p>
&lt;h2 id="mach-engine-as-a-standard-library-of-modules">Mach engine as a standard library of modules&lt;/h2>
&lt;p>We began &lt;a href="https://machengine.org/engine/stdlib/">documenting&lt;/a> how we view Mach &lt;em>engine&lt;/em> as a standard library of modules for game development, and how we&amp;rsquo;ll enable you to use just the parts you wish. This is a small-but-important step in showcasing how the engine&amp;rsquo;s higher level APIs will be more modular than the monolithic big engines of today.&lt;/p>
&lt;h2 id="entity-component-system">Entity component system&lt;/h2>
&lt;p>The Mach entity component system provides a key role in Mach&amp;rsquo;s modularity, in this iteration it saw numerous polish / bug fix improvements - the ability to actually query entities, a more clear/concise API, etc. It is still under heavy development, however.&lt;/p>
&lt;h2 id="machmath">mach.math&lt;/h2>
&lt;p>&lt;a href="https://github.com/hexops/mach/tree/main/src/math">mach.math&lt;/a> was introduced to the Mach standard library: a custom math library tailored towards our graphics API conventions, matrix representations, coordinate systems, etc.&lt;/p>
&lt;p>Today it includes many of the basics: vectors, matrices, quaternions - though it is still missing some basic tablestakes. It also has ray-triangle intersection, and we intend to expand it to cover more general collision utilities later.&lt;/p>
&lt;p>A new set of &lt;a href="https://machengine.org/engine/math/">math docs&lt;/a> were added to the website with some cute diagrams/visualizations.&lt;/p>
&lt;h2 id="machgfxsprite">mach.gfx.Sprite&lt;/h2>
&lt;p>&lt;a href="https://github.com/hexops/mach/blob/main/src/gfx/Sprite.zig">mach.gfx.Sprite&lt;/a> was introduced, which is the start of a 2D sprite-rendering module. It is largely usable, though we anticipate its API to change a fair amount and are looking to add animated sprite support among other key features.&lt;/p>
&lt;p>It has been useful in letting us test basic rendering of hundreds of thousands of sprites, each as separate entities with their own transformation matrices calculated CPU-side, and get more of an end-to-end feel for how things are looking with our ECS:&lt;/p>
&lt;iframe width="720" height="480" src="https://www.youtube.com/embed/ciuSYf7dcuE?si=SgojGMwdD_lfncgn" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen>&lt;/iframe>
&lt;h2 id="machgfxtext">mach.gfx.Text&lt;/h2>
&lt;p>Development of a basic text rendering module is underway, but not ready for use yet.&lt;/p>
&lt;h2 id="status-of-simple-2d-game-support">Status of &amp;lsquo;simple 2D game&amp;rsquo; support&lt;/h2>
&lt;p>In short, we&amp;rsquo;re still working on it. More to come soon.&lt;/p>
&lt;h2 id="general-project-maintenance">General project maintenance&lt;/h2>
&lt;ul>
&lt;li>Two new examples &lt;a href="https://github.com/hexops/mach-core/tree/main/examples/rgb-quad">rgb-quad&lt;/a> and &lt;a href="https://github.com/hexops/mach-core/tree/main/examples/textured-quad">textured-quad&lt;/a> showing off super basic 2D rendering were added.&lt;/li>
&lt;li>Began to formulate our &lt;a href="https://github.com/hexops/mach/issues/989">hardware support plans&lt;/a>, such as when we will target certain SIMD instruction sets.&lt;/li>
&lt;li>All of our &lt;code>build.zig&lt;/code> scripts went through a great deal of changes and improvements, as Zig&amp;rsquo;s build system and package manager matured greatly.&lt;/li>
&lt;li>Various &lt;a href="https://github.com/hexops/mach/milestone/5?closed=1">other issues&lt;/a> were addressed.&lt;/li>
&lt;/ul>
&lt;h2 id="a-personal-note">A personal note&lt;/h2>
&lt;div style="display: flex;">
&lt;a href="https://github.com/slimsag">
&lt;img style="width: 420px" src="https://machengine.org/img/slimsag-profile.png">
&lt;/a>
&lt;div>
&lt;p>I work a normal tech job, and most days after I sign off from work I go online to build Mach, often like working two jobs. I've been doing this for a few years now, and dreaming of being able to build Mach for a decade before that.&lt;/p>
&lt;p>FOSS &lt;a href="https://devlog.hexops.com/2021/increasing-my-contribution-to-zig-to-200-a-month#i-grew-up-playing-linux-games-like-mania-drive">is in my roots&lt;/a> and I believe we should own our tools, they should empower &lt;em>us&lt;/em>-not be part of &lt;a href="https://kristoff.it/blog/the-open-source-game/">the 'open source' game&lt;/a> which is all too prevelant today (even among 'open source' engines.) Mach &lt;em>needs&lt;/em> to be for people like you and me-it needs to genuinely be &lt;a href="https://softwareyoucan.love">software you can love&lt;/a>.&lt;/p>
&lt;p>My dream is one day to live a simple, modest, future earning a living building Mach for you and creating high-quality games for everyone. Please consider &lt;a href="https://github.com/sponsors/slimsag">sponsoring my work&lt;/a> if you believe in this vision.&lt;/p>
&lt;/div>
&lt;/div>
&lt;h2 id="thanks">Thanks&lt;/h2>
&lt;p>Immense thank you to all those who helped make this release possible, to those who contribute regularly or in the past, and those who sponsor development. It means the world!&lt;/p>
&lt;div style="display: flex; flex-direction: row; align-items: center;">
&lt;img align="left" style="max-height: 12.5rem;" src="https://user-images.githubusercontent.com/3173176/187348488-0b52e87d-3a48-421c-9402-be78e32b5a20.png">&lt;/img>
&lt;ul>
&lt;li>Join the &lt;a href="https://discord.gg/XNG3NZgCqp">Mach Discord server&lt;/a>&lt;/li>
&lt;li>Check out &lt;a href="https://machengine.org">machengine.org&lt;/a>&lt;/li>
&lt;li>Consider &lt;a href="https://github.com/sponsors/slimsag">sponsoring development&lt;/a> so we can do more of it!&lt;/li>
&lt;/ul>
&lt;/div></description></item><item><title>Announcing Mach nominated Zig versions</title><link>https://devlog.hexops.com/2024/announcing-nominated-zig/</link><pubDate>Sun, 07 Jan 2024 00:00:00 +0000</pubDate><guid>https://devlog.hexops.com/2024/announcing-nominated-zig/</guid><description>&lt;p>Today we&amp;rsquo;re announcing Mach nominated Zig versions, a sweet-spot between stable Zig and nightly Zig which offers a different balance of latest-and-greatest features and fixes, and less of a moving target.&lt;/p>
&lt;p>If you are in the Zig community, you likely fall into one of two categories:&lt;/p>
&lt;ul>
&lt;li>You target Zig nightly, a target which moves every day&lt;/li>
&lt;li>You target Zig stable, which may be released once or twice per year.&lt;/li>
&lt;/ul>
&lt;h2 id="the-challenge-of-using-zig-stable">The challenge of using Zig stable&lt;/h2>
&lt;p>In recent years, Zig stable has about 2 releases per year. There are great benefits to using stable Zig:&lt;/p>
&lt;ul>
&lt;li>It is generally documented how to update/migrate your code to the new Zig version, rather than it being an ad-hoc process of discovery.&lt;/li>
&lt;li>The release is at a point where the Zig core team feels it is solid and ready to go (Zig releases are done when they are done, not usually timed.)&lt;/li>
&lt;li>These versions get nice numbers associated with them, package authors, distributions, etc. can easily target them.&lt;/li>
&lt;/ul>
&lt;p>But, for a language that is developed quite quickly, and has yet to reach v1.0 stability.. when you find that an awesome new feature like the package manager, incremental compilation, or something else you care about has just landed in Zig nightly.. are you going to wait 6 months or more to get that change?&lt;/p>
&lt;h2 id="the-challenge-of-using-zig-nightly">The challenge of using Zig nightly&lt;/h2>
&lt;p>Zig nightly is an ever-moving target. Although it is often nearly as stable as stable releases, that is not neccessarily the case during large refactors - such as the migration to the self-hosted compiler.&lt;/p>
&lt;p>There are benefits to using nightly, though! It means you are testing the latest version of Zig, and your project can exist in a sort of symbiotic relationship with the Zig project where you test new functionality, help provide feedback on it, discover new issues, and have a greater chance of getting them fixed/addressed while that code is on everyone&amp;rsquo;s mind.&lt;/p>
&lt;p>Unlike stable Zig, you&amp;rsquo;re not integrating 6+ months of breaking changes into your codebase all at once (quite painful!) but rather doing so as the breaks happen. Since many others in the Zig community do target nightly Zig, there are often people around who can help you with upgrading your code.&lt;/p>
&lt;p>One major downside, aside from death by a thousand paper cuts, is that everyone targets a different Zig nightly version. Often, it&amp;rsquo;s difficult to coordinate with others and keep your code compatible with theirs.&lt;/p>
&lt;h2 id="the-challenge-mach-has-using-zig-nightly">The challenge Mach has using Zig nightly&lt;/h2>
&lt;p>We use Zig nightly, but we only periodically update the version.&lt;/p>
&lt;p>Updating Mach&amp;rsquo;s Zig version involves updating a dependency tree of over &lt;a href="https://github.com/hexops/mach/issues/1135">40+ Zig repositories&lt;/a>, first updating the Zig code itself and testing manually, then updating their CI pipelines, then going and updating anyone who depends on that repository - from the bottom of the tree to the top!&lt;/p>
&lt;p>We&amp;rsquo;ve built some serious automation to help with this process, but it is still painful - and it is also the case that every time we update our Zig version, our users need to do the same: we&amp;rsquo;re not just updating Zig for us, we&amp;rsquo;re updating Zig for every user of Mach.&lt;/p>
&lt;p>This process has worked &lt;em>pretty&lt;/em> well for us, but the frequency of updates has always been ad-hoc, and when we do update it is a bit chaotic.&lt;/p>
&lt;h2 id="we-need-our-ecosystem-of-40-packages-to-be-compatible">We need our ecosystem of 40+ packages to be compatible&lt;/h2>
&lt;p>If we haven&amp;rsquo;t updated our Zig version for a bit of time, then we end up with tens of outstanding pull requests by people who maybe don&amp;rsquo;t use &lt;em>all of Mach&lt;/em> but rather just parts of it, and they can become (rightfully!) fairly frustrated that getting their pull-request merged takes us a while.&lt;/p>
&lt;p>We can&amp;rsquo;t just merge a one-off pull request to one repository, we have to update all 40+ to be compatible with the same Zig version.&lt;/p>
&lt;p>&lt;a href="https://devlog.hexops.com/img/2024/so-many-pull-requests.png">&lt;img alt="so many pull requests" src="https://devlog.hexops.com/img/2024/so-many-pull-requests.png">&lt;/a>&lt;/p>
&lt;h2 id="coordinating-outside-mach">Coordinating outside Mach&lt;/h2>
&lt;p>Although Mach provides a lot of libraries, there are still many important aspects of gamedev we do not have yet. Some folks in the Mach community will pull in third-party Zig projects, like those from zig-gamedev, introducing another challenge in ensuring their code works with the same version.&lt;/p>
&lt;h2 id="announcing-mach-nominated-zig-versions">Announcing Mach nominated Zig versions&lt;/h2>
&lt;p>Today we&amp;rsquo;re formalizing the process we&amp;rsquo;ve (generally) been following. This formalization will make it easier for others to understand what we&amp;rsquo;re doing and when, and also make it easier for other projects to align their Zig version with Mach&amp;rsquo;s if they desire.&lt;/p>
&lt;p>Throughout the year (aiming for the 4th day of the month), we will pick the latest Zig nightly version at that time and nominate it for use:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>When&lt;/th>
&lt;th>What&lt;/th>
&lt;th>ðŸš€ Other notable event&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>January&lt;/td>
&lt;td>&lt;/td>
&lt;td>ðŸš€ Mach version release&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>February&lt;/td>
&lt;td>&lt;/td>
&lt;td>ðŸ‘‹ Anticipated influx of new Machanists / Ziguanas&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>March&lt;/td>
&lt;td>âš¡ Zig version nominated&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>April&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>May&lt;/td>
&lt;td>âš¡ Zig version nominated&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>June&lt;/td>
&lt;td>âš¡ Zig version nominated&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>July&lt;/td>
&lt;td>&lt;/td>
&lt;td>ðŸš€ Mach version release&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>August&lt;/td>
&lt;td>&lt;/td>
&lt;td>ðŸ‘‹ Anticipated influx of new Machanists / Ziguanas&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>September&lt;/td>
&lt;td>âš¡ Zig version nominated&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>October&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>November&lt;/td>
&lt;td>âš¡ Zig version nominated&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>December&lt;/td>
&lt;td>&lt;/td>
&lt;td>ðŸ‘‹ Anticipated influx of new Machanists / Ziguanas&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>These versions will be noted as e.g. &amp;lsquo;2024.1.0-mach&amp;rsquo;, and will correspond to a specific Zig nightly version from that month.&lt;/p>
&lt;p>The exact versions, which nightly version they map to, and the whole process (which is more involved), is &lt;a href="https://machengine.org/about/nominated-zig/">documented in full here&lt;/a>.&lt;/p>
&lt;p>At the time of writing this, you&amp;rsquo;ll see that &lt;a href="https://machengine.org/about/nominated-zig/#202401">2024.1.0-mach&lt;/a> is marked as &amp;lsquo;in progress&amp;rsquo; - we will make sure that the Zig version we intend to nominate is at least compatible with all Mach projects before finalizing the nomination.&lt;/p>
&lt;h3 id="a-sweet-spot-between-nightly-and-stable">A sweet spot between nightly and stable&lt;/h3>
&lt;p>Mach&amp;rsquo;s nominated Zig versions provide a different set of tradeoffs, we believe it is a sweetspot between the two extremes of nightly and stable. You can benefit from the changes in Zig 2-3x faster than if you were using stable, and suffer less from the never-ending game of catch-up and incompatibilities between projects that nightly necessarily requires.&lt;/p>
&lt;p>Other projects can target the same Zig version if they wish to be compatible with Mach Zig packages. For example, zig-gamedev is aiming to target the same versions. We encourage other gamedevs using Zig to do the same.&lt;/p>
&lt;p>Projects that target nightly Zig can often be coincidentally compatible, too, since they possibly had a compatible Zig version around the time we nominated a Zig version for use.&lt;/p>
&lt;h2 id="final-thoughts">Final thoughts&lt;/h2>
&lt;p>You can read more about the specifics of everything in the &lt;a href="https://machengine.org/about/nominated-zig">Mach documentation&lt;/a>.&lt;/p>
&lt;p>We&amp;rsquo;re currently working on nominating the first version, which will likely be finalized in the next week or so.&lt;/p>
&lt;h2 id="thanks">Thanks&lt;/h2>
&lt;div style="display: flex; flex-direction: row; align-items: center;">
&lt;img align="left" style="max-height: 12.5rem;" src="https://user-images.githubusercontent.com/3173176/187348488-0b52e87d-3a48-421c-9402-be78e32b5a20.png">&lt;/img>
&lt;ul>
&lt;li>Join the &lt;a href="https://discord.gg/XNG3NZgCqp">Mach Discord server&lt;/a> (check #discuss for this article)&lt;/li>
&lt;li>Checkout &lt;a href="https://machengine.org">machengine.org&lt;/a>&lt;/li>
&lt;li>Consider &lt;a href="https://github.com/sponsors/slimsag">sponsoring development&lt;/a> so we can do more of it!&lt;/li>
&lt;/ul>
&lt;/div></description></item></channel></rss>