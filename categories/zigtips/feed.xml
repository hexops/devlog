<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>zigtips on Hexops' devlog</title><link>https://devlog.hexops.com/categories/zigtips/</link><description>Recent content in zigtips on Hexops' devlog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 14 Nov 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://devlog.hexops.com/categories/zigtips/feed.xml" rel="self" type="application/rss+xml"/><item><title>Debugging undefined behavior caught by Zig</title><link>https://devlog.hexops.com/2022/debugging-undefined-behavior/</link><pubDate>Mon, 14 Nov 2022 00:00:00 +0000</pubDate><guid>https://devlog.hexops.com/2022/debugging-undefined-behavior/</guid><description>&lt;p>&lt;a href="https://machengine.org/">Mach engine&lt;/a> uses &lt;a href="https://ziglang.org">Zig&lt;/a> as the C/C++ compiler for almost everything. Unlike other toolchains, Zig enables many more safety checks by default - such as clang&amp;rsquo;s undefined behavior sanitizer.&lt;/p>
&lt;p>Using Zig, we&amp;rsquo;ve caught undefined behavior in established projects like GLFW[&lt;a href="https://devlog.hexops.com/2021/perfecting-glfw-for-zig-and-finding-undefined-behavior/">1&lt;/a>], the DirectX Shader Compiler[&lt;a href="https://github.com/microsoft/DirectXShaderCompiler/pull/4178#discussion_r780733405">2&lt;/a>], and more. Undefined behavior is everywhere, often relatively innocuous, and hard to catch.&lt;/p>
&lt;p>Professional C/C++ developers know to run UBSan fuzzers as part of their test suite, but even with that we&amp;rsquo;ve found e.g. Google Chrome&amp;rsquo;s fuzzers weren&amp;rsquo;t running normally at one point, and we caught undefined behavior in Chrome&amp;rsquo;s implementation of WebGPU as a result[&lt;a href="https://dawn-review.googlesource.com/c/dawn/+/87380">3&lt;/a>].&lt;/p>
&lt;p>Zig having UBSan enabled by default is valuable, but it can also lead to tricky to debug errors that are a bit annoying to interpret today. And so this article is a walkthrough of how to debug such an error when it arises using Zig and LLDB.&lt;/p>
&lt;h2 id="the-situation">The situation&lt;/h2>
&lt;p>We&amp;rsquo;re looking at using &lt;a href="https://bztsrc.gitlab.io/model3d/">model3d&lt;/a> in Mach. Model3D is an up-and-coming compact, featureful, universal model format that tries to address the shortcomings of existing formats (yes, including glTF - see &lt;a href="https://gitlab.com/bztsrc/model3d/#rationale">their rationale&lt;/a>.) It is a small, zero-dependency single-header C implementation which in Zig we can simply import.&lt;/p>
&lt;p>As we&amp;rsquo;ve been testing it with various models, though, we found our Zig program just crashes when we use it:&lt;/p>
&lt;pre>&lt;code>% zig build test 2&amp;gt;&amp;amp;1|cat
1/1 test_0... The following command terminated unexpectedly:
cd /mach/libs/model3d &amp;amp;&amp;amp; /mach/libs/model3d/zig-cache/o/26c4104a1643fed2068dfa9244dfe90e/model3d-tests /Users/slimsag/zig-macos-aarch64-0.11.0-dev.38+b40fc7018/zig
error: the following build command failed with exit code 1:
/mach/libs/model3d/zig-cache/o/679e494577315c1bcc3749ee7068ea2f/build /Users/slimsag/zig-macos-aarch64-0.11.0-dev.38+b40fc7018/zig /mach/libs/model3d /mach/libs/model3d/zig-cache /Users/slimsag/.cache/zig test
&lt;/code>&lt;/pre>&lt;p>As you can see, we&amp;rsquo;re not getting much info here on why our tests crashed. This is a telltale sign of undefined behavior in Zig (and &lt;a href="https://github.com/ziglang/zig/issues/5163">there&amp;rsquo;s an open issue to make this error messaging way more clear&lt;/a>). When we compile our program with &lt;code>-Drelease-fast&lt;/code>, which disables safety checks, we find it runs as expected - which confirms our suspicion about it being a safety check.&lt;/p>
&lt;h2 id="debugging-with-lldb">Debugging with LLDB&lt;/h2>
&lt;p>In the output above, we can grab the path to the executable &lt;code>model3d-tests&lt;/code>. We can debug it using lldb (I think we should find a nicer way to invoke &lt;code>lldb&lt;/code> via &lt;code>zig build test&lt;/code> though!):&lt;/p>
&lt;pre>&lt;code>lldb -- /mach/libs/model3d/zig-cache/o/26c4104a1643fed2068dfa9244dfe90e/model3d-tests
&lt;/code>&lt;/pre>&lt;p>Next we just enter the &lt;code>run&lt;/code> command at the &lt;code>(lldb)&lt;/code> prompt:&lt;/p>
&lt;pre>&lt;code>(lldb) run
Process 6830 launched: '/mach/libs/model3d/zig-cache/o/26c4104a1643fed2068dfa9244dfe90e/model3d-tests' (arm64)
Process 6830 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BREAKPOINT (code=1, subcode=0x100033634)
frame #0: 0x0000000100033634 model3d-tests`m3d_load(data=&amp;quot;\xc3.:&amp;gt;&amp;quot;, readfilecb=0x0000000000000000, freecb=0x0000000000000000, mtllib=0x0000000000000000) at m3d.h:3356:56
3353 model-&amp;gt;tmap[i].v = (M3D_FLOAT)(*((uint16_t*)(data+2))) / (M3D_FLOAT)65535.0;
3354 break;
3355 case 4:
-&amp;gt; 3356 model-&amp;gt;tmap[i].u = (M3D_FLOAT)(*((float*)(data+0)));
3357 model-&amp;gt;tmap[i].v = (M3D_FLOAT)(*((float*)(data+4)));
3358 break;
3359 case 8:
&lt;/code>&lt;/pre>&lt;p>If you squint, you can see &lt;code>stop reason = EXC_BREAKPOINT&lt;/code> in the output. This is the sign I was looking for: it tells me that UBSan likely inserted a breakpoint for undefined behavior, and we hit it. There&amp;rsquo;s &lt;em>some&lt;/em> form of undefined behavior going on here!&lt;/p>
&lt;p>Thanks to lldb, we also got an exact line number, and see the source code where the crash occurred. Sometimes you may not get this much, in which case you may need to run the lldb &lt;code>up&lt;/code> command until you get to a line you can make sense of.&lt;/p>
&lt;p>In this instance, we&amp;rsquo;re running code inside of a for loop - and so one question I have is: what iteration of that loop are we at? We can get this info easily using &lt;code>p i&lt;/code> to inspect the &lt;code>i&lt;/code> variable:&lt;/p>
&lt;pre>&lt;code>(lldb) p i
(unsigned int) $1 = 0
&lt;/code>&lt;/pre>&lt;p>This shows us that the &lt;code>i&lt;/code> variable is an unsigned 32-bit int with the value &lt;code>0&lt;/code>. It crashed on the first iteration.&lt;/p>
&lt;p>(Note: we could also use &lt;code>frame variables&lt;/code> to get a list of variables in the local frame (i.e. our function), but in this case it&amp;rsquo;s quite a few and so I didn&amp;rsquo;t find that useful.)&lt;/p>
&lt;p>Next, I wanted to find out: what would the float at that address actually look like? Luckily, the LLDB &lt;code>p &amp;lt;expr&amp;gt;&lt;/code> command actually interprets C-like expressions for us. It&amp;rsquo;s rather easy to write the C expression for that:&lt;/p>
&lt;pre>&lt;code>(lldb) p *(float*)(data+0)
(float) $2 = 0.181819007
&lt;/code>&lt;/pre>&lt;p>Here we can see the float at the address of &lt;code>data&lt;/code> is &lt;code>0.181819007&lt;/code> - which is within the normalized range I&amp;rsquo;d expect for a UV coordinate. It seems correct. My next question was.. is the pointer address aligned? I know UBSan has a check for pointer alignment, so I looked at it:&lt;/p>
&lt;pre>&lt;code>(lldb) p data
(unsigned char *) $3 = 0x0000000101008251 &amp;quot;\xc3.:&amp;gt;&amp;quot;
&lt;/code>&lt;/pre>&lt;p>Since we&amp;rsquo;re accessing a float at this address, we&amp;rsquo;d expect it to be aligned to 4 bytes. We can check this easily by plopping the address into Python and dividing by 4. If there&amp;rsquo;s a remainder, it&amp;rsquo;s not aligned:&lt;/p>
&lt;pre>&lt;code>&amp;gt;&amp;gt;&amp;gt; 0x0000000101008251 % 4
1
&lt;/code>&lt;/pre>&lt;h2 id="what-are-the-consequences">What are the consequences?&lt;/h2>
&lt;p>Many times, UBSan will catch undefined behavior that in practice isn&amp;rsquo;t really harmful on modern machines you might care about. I wasn&amp;rsquo;t sure about the consequences of unaligned pointer accesses like this, so I asked someone smarter than myself and &lt;a href="https://gitlab.com/bztsrc/model3d/-/issues/19">filed an issue on model3d&lt;/a> which led to some very interesting insights &lt;a href="https://gitlab.com/bztsrc/model3d/-/issues/19#note_1171783061">from @bztsrc&lt;/a>.&lt;/p>
&lt;blockquote>
&lt;p>Short answer: the bug is in UBSan&lt;/p>
&lt;p>Long answer: it is true that in ancient times there were CPUs that couldn&amp;rsquo;t handle unaligned access. However that&amp;rsquo;s not the case with today mainstream processors: x86, ARM, RISC-V, etc. all handle unaligned access out-of-the-box. (Ok, for ARM it&amp;rsquo;s not out-of-the-box, you have to enable MMU which is surely done by the OS kernel otherwise virtual memory mapping would be impossible.)&lt;/p>
&lt;p>[&amp;hellip;] The reason for the unaligned access is pretty simple. In the binary bit-chunk that a compressed model file is, there&amp;rsquo;s obviously no guarantee that a value is aligned. Such compactness is absolutely needed for small file sizes, padding with zeros would insanely increase the required storage requirements.&lt;/p>
&lt;p>[&amp;hellip;] So the decision I had to make here was: keep UBSan happy but create crappy and slow code, or don&amp;rsquo;t care about UBSan and take advantage of modern CPU features. I&amp;rsquo;ve decided on the latter.&lt;/p>
&lt;/blockquote>
&lt;p>Which is a quite compelling argument for this just being noise for our purposes. :)&lt;/p>
&lt;h1 id="risc-v-a-notable-exception">RISC-V: a notable exception&lt;/h1>
&lt;p>It was pointed out to me by someone more knowledgable that RISC-V cores lack hardware support for unaligned accesses[0][1] (&amp;lsquo;if sifive doesn&amp;rsquo;t do this in hardware (unalignment) there&amp;rsquo;s no way any other risc-v cores do [&amp;hellip;due to sifive&amp;rsquo;s sheer popularity in the space]'), unalignment is done by trap handlers instead:&lt;/p>
&lt;p>&lt;img src="https://user-images.githubusercontent.com/3173176/201804903-5584f318-5832-4c76-9f1a-45a32ce10348.png" alt="image">&lt;/p>
&lt;blockquote>
&lt;p>Officially, programs running in any mode but M-Mode on risc-v are allowed to do unaligned accesses but that doesn&amp;rsquo;t mean it can&amp;rsquo;t be pretty painful&lt;/p>
&lt;/blockquote>
&lt;p>[0] &lt;a href="https://forums.sifive.com/t/ld-sd-alignment/5530/6">https://forums.sifive.com/t/ld-sd-alignment/5530/6&lt;/a>&lt;/p>
&lt;p>[1] &lt;a href="https://patchwork.kernel.org/project/linux-riscv/patch/60c1f087-1e8b-8f22-7d25-86f5f3dcee3f@gmail.com/#24313195">https://patchwork.kernel.org/project/linux-riscv/patch/60c1f087-1e8b-8f22-7d25-86f5f3dcee3f@gmail.com/#24313195&lt;/a>&lt;/p>
&lt;p>I don&amp;rsquo;t have any RISC-V hardware to test on, so this doesn&amp;rsquo;t affect us at present, but I figured it worth noting.&lt;/p>
&lt;h2 id="disabling-the-sanitizer">Disabling the sanitizer&lt;/h2>
&lt;p>In our case, we can just disable the alignment sanitizer for this one function:&lt;/p>
&lt;pre>&lt;code>+__attribute__((no_sanitize(&amp;quot;alignment&amp;quot;)))
m3d_t *m3d_load(unsigned char *data, m3dread_t readfilecb, m3dfree_t freecb, m3d_t *mtllib)
&lt;/code>&lt;/pre>&lt;p>And with this, our tests pass. And we continue to get all the other benefits and safety checks of UBSan elsewhere.&lt;/p>
&lt;p>In this case, though, I opted to just disable alignment sanitization entirely when building model3d by &lt;a href="https://github.com/hexops/mach/commit/c96ff64958c241249041856a8ea0e8a4349050a6">adding&lt;/a> the &lt;code>-fno-sanitize=alignment&lt;/code> compiler flag to our &lt;code>build.zig&lt;/code> to avoid this surprising us in other model3d functions.&lt;/p>
&lt;h2 id="thanks-for-reading">Thanks for reading&lt;/h2>
&lt;p>If you&amp;rsquo;re writing Zig, C, or C++ code - then I hope this &lt;code>zig: Tip&lt;/code> helps you! You can find &lt;a href="https://devlog.hexops.com/categories/zigtips/">other &lt;code>zig: Tips&lt;/code> here&lt;/a>.&lt;/p>
&lt;p>&lt;img align="left" style="max-height: 150px;" src="https://user-images.githubusercontent.com/3173176/187348488-0b52e87d-3a48-421c-9402-be78e32b5a20.png">&lt;/img>
Be sure to join the &lt;a href="https://discord.gg/XNG3NZgCqp">Mach engine Discord&lt;/a> where we&amp;rsquo;re building the future of Zig game development.
&lt;br>&lt;br>
You can also &lt;a href="https://github.com/sponsors/slimsag">sponsor my work&lt;/a> if you like what I&amp;rsquo;m doing! :)&lt;/p></description></item><item><title>Packed structs in Zig make bit/flag sets trivial</title><link>https://devlog.hexops.com/2022/packed-structs-in-zig/</link><pubDate>Mon, 29 Aug 2022 00:00:00 +0000</pubDate><guid>https://devlog.hexops.com/2022/packed-structs-in-zig/</guid><description>&lt;p>As we&amp;rsquo;ve been building &lt;a href="https://machengine.org/">Mach engine&lt;/a>, we&amp;rsquo;ve been using a neat little pattern in Zig that enables writing flag sets more nicely in Zig than in other languages.&lt;/p>
&lt;h2 id="what-is-a-flag-set">What is a flag set?&lt;/h2>
&lt;p>We&amp;rsquo;ve been rewriting &lt;code>mach/gpu&lt;/code> (WebGPU bindings for Zig) from scratch recently, so let&amp;rsquo;s take a flag set from the WebGPU C API:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">typedef&lt;/span> &lt;span class="kt">uint32_t&lt;/span> &lt;span class="n">WGPUFlags&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">typedef&lt;/span> &lt;span class="n">WGPUFlags&lt;/span> &lt;span class="n">WGPUColorWriteMaskFlags&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Effectively, &lt;code>WGPUColorWriteMaskFlags&lt;/code> here is a 32-bit unsigned integer where you can set specific bits in it to represent whether or not to write certain colors:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">typedef&lt;/span> &lt;span class="k">enum&lt;/span> &lt;span class="n">WGPUColorWriteMask&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">WGPUColorWriteMask_None&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mh">0x00000000&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">WGPUColorWriteMask_Red&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mh">0x00000001&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">WGPUColorWriteMask_Green&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mh">0x00000002&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">WGPUColorWriteMask_Blue&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mh">0x00000004&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">WGPUColorWriteMask_Alpha&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mh">0x00000008&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">WGPUColorWriteMask_All&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mh">0x0000000F&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">WGPUColorWriteMask_Force32&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mh">0x7FFFFFFF&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="n">WGPUColorWriteMask&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then to use it you&amp;rsquo;d use the various bit operations with those masks, e.g.:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="n">WGPUColorWriteMaskFlags&lt;/span> &lt;span class="n">mask&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">WGPUColorWriteMask_Red&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="n">WGPUColorWriteMask_Green&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">mask&lt;/span> &lt;span class="o">|=&lt;/span> &lt;span class="n">WGPUColorWriteMask_Blue&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// set blue bit
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This all works, people have been doing it for years in C, C++, Java, Rust, and more. In Zig, we can do better.&lt;/p>
&lt;h2 id="zig-packed-structs">Zig packed structs&lt;/h2>
&lt;p>&lt;img class="color-auto" style="max-height: 300px;" src="https://user-images.githubusercontent.com/3173176/184735519-cc78d19d-73e8-4914-8f3d-fc3a15d00bb7.png" />&lt;/p>
&lt;p>Zig has &lt;code>packed struct&lt;/code>s: these let us pack memory tightly, where a &lt;code>bool&lt;/code> is actually a single bit (in most other languages, this is not true.) Zig also has arbitrary bit-width integers, like &lt;code>u28&lt;/code>, &lt;code>u1&lt;/code> and so on.&lt;/p>
&lt;p>We can write &lt;code>WGPUColorWriteMaskFlags&lt;/code> from earlier in Zig using:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="kr">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">const&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ColorWriteMaskFlags&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">packed&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">red&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">bool&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">green&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">bool&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">blue&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">bool&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">alpha&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">bool&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">_padding&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">u28&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">};&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This is still just 32 bits of memory, and so can be passed to the same C APIs that expect a &lt;code>WGPUColorWriteMaskFlags&lt;/code> - but interacting with it is much nicer:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="kr">var&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">mask&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ColorWriteMaskFlags&lt;/span>&lt;span class="p">{.&lt;/span>&lt;span class="n">red&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">green&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="p">};&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="n">mask&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">blue&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// set blue bit
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In C you would need to write code like this:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">mask&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">WGPUColorWriteMask_Alpha&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// alpha is set..
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">mask&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">WGPUColorWriteMask_Alpha&lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="n">WGPUColorWriteMask_Blue&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// alpha and blue are set..
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">mask&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">WGPUColorWriteMask_Green&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// green not set
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>In Zig it&amp;rsquo;s just:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mask&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">alpha&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// alpha is set..
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mask&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">alpha&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">and&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">mask&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">blue&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// alpha is set..
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">mask&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">green&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// green not set
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="comptime-validation">Comptime validation&lt;/h2>
&lt;p>Making sure that our &lt;code>ColorWriteMaskFlags&lt;/code> ends up being the same size could be a bit tricky: what if we count the number of &lt;code>bool&lt;/code> wrong? Or what if we accidently get the padding size wrong? Then it might not be the same size as a &lt;code>uint32&lt;/code> anymore.&lt;/p>
&lt;p>Luckily, we can verify our expectations at comptime:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="kr">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">const&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ColorWriteMaskFlags&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">packed&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">red&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">bool&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">green&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">bool&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">blue&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">bool&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">alpha&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">bool&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">_padding&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">u28&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">comptime&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">debug&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">assert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">@sizeOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">@This&lt;/span>&lt;span class="p">())&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">@sizeOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">u32&lt;/span>&lt;span class="p">));&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">debug&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">assert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">@bitSizeOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">@This&lt;/span>&lt;span class="p">())&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">@bitSizeOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">u32&lt;/span>&lt;span class="p">));&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The Zig compiler will take care of running the &lt;code>comptime&lt;/code> code block here for us when building, and it will verify that the byte size of &lt;code>@This()&lt;/code> (the type we&amp;rsquo;re inside of, the &lt;code>ColorWriteMaskFlags&lt;/code> struct in this case) matches the &lt;code>@sizeOf(u32)&lt;/code>.&lt;/p>
&lt;p>Similarly we could check the &lt;code>@bitSizeOf&lt;/code> both types if we like.&lt;/p>
&lt;p>Note that &lt;a href="https://ziglang.org/documentation/master/#sizeOf">&lt;code>@sizeOf&lt;/code>&lt;/a> may include the size of padding for more complex types, while &lt;a href="https://ziglang.org/documentation/master/#bitSizeOf">&lt;code>@bitSizeOf&lt;/code>&lt;/a> returns the number of bits it takes to store &lt;code>T&lt;/code> in memory &lt;em>if the type were a field in a packed struct/union&lt;/em>. For flag sets like this, it doesn&amp;rsquo;t matter and either will do. For more complex types, be sure to recall this.&lt;/p>
&lt;h2 id="explicit-backing-integers-for-packed-structs">Explicit backing integers for packed structs&lt;/h2>
&lt;p>It&amp;rsquo;s worth noting that in Zig 0.10 (shipping in Nov), the new self-hosted compiler has support for &lt;a href="https://github.com/ziglang/zig/pull/12379">explicit backing integers for packed structs&lt;/a> which will simplify this even further.&lt;/p>
&lt;p>Instead of manually adding padding to make up 32 bits, one could simply write &lt;code>packed struct(u32)&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="kr">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">const&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ColorWriteMaskFlags&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">packed&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">u32&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">red&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">bool&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">green&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">bool&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">blue&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">bool&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">alpha&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">bool&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="thanks-for-reading">Thanks for reading&lt;/h2>
&lt;p>&lt;img align="left" style="max-height: 150px;" src="https://user-images.githubusercontent.com/3173176/187348488-0b52e87d-3a48-421c-9402-be78e32b5a20.png">&lt;/img>
Be sure to join the new &lt;a href="https://discord.gg/XNG3NZgCqp">Mach engine Discord server&lt;/a> where we&amp;rsquo;re building the future of Zig game development.
&lt;br>&lt;br>
You can also &lt;a href="https://github.com/sponsors/slimsag">sponsor my work&lt;/a> if you like what I&amp;rsquo;m doing! :)&lt;/p>
&lt;h2 id="but-c-has-had-bitfields-since-forever">&amp;ldquo;But C has had bitfields since forever!&amp;rdquo;&lt;/h2>
&lt;p>Shortly after posting this article I was inundated with comments proclaiming &amp;ldquo;But C has had bitfields since forever!&amp;rdquo;&lt;/p>
&lt;p>First, I&amp;rsquo;d like to say I was not aware of C bitfields at the time of writing - I simply had not ever come across usage of them. Secondly, I&amp;rsquo;d like to question: if C has bitfields, then why do seemingly all modern C APIs not use? Why do they all expose integer types instead?&lt;/p>
&lt;p>And then I found the answer in the TC3 C specification:&lt;/p>
&lt;img width="803" alt="image" src="https://user-images.githubusercontent.com/3173176/189488251-738931cc-820a-4cd8-84d4-7320e3d870e6.png">
&lt;p>As &lt;a href="https://news.ycombinator.com/item?id=32648232">this user writes&lt;/a>:&lt;/p>
&lt;blockquote>
&lt;p>The in-memory representation of bit fields is implementation-defined. Therefore, if you&amp;rsquo;re calling into an external API that takes a uint32_t like in the example without an explicit remapping, you may or may not like the results.&lt;/p>
&lt;p>In practice, everything you&amp;rsquo;re likely to come across will be little endian nowadays, and the ABI you&amp;rsquo;re using will most likely order your struct from top to bottom in memory, so they will look the same most of the time. However, it&amp;rsquo;s still technically not portable.&lt;/p>
&lt;/blockquote>
&lt;p>My intention behind this article wasn&amp;rsquo;t to say C is bad; but rather to say that I find Zig&amp;rsquo;s packed structs quite nice. I actually come from a background mostly in Go - which absolutely does not have bitfields, packed structs, or arbitrary bit-width integers. Having never come across them in C either, my claims against C bitfields today could be summarized as:&lt;/p>
&lt;ul>
&lt;li>C&amp;rsquo;s bitfields are more implementation-defined than Zig&amp;rsquo;s.&lt;/li>
&lt;li>C&amp;rsquo;s bitfields being so implementation-defined, tend not to be used in modern APIs - so the fact that Zig has come up with a variant which &lt;em>is used in practice in most APIs&lt;/em> is very important.&lt;/li>
&lt;/ul>
&lt;p>In any case, I am not an expert in C bitfields! I just hate masking to check if bits are set, and the &lt;a href="https://news.ycombinator.com/item?id=32646998">insane number of ways&lt;/a> that exact same logic can be written - both correctly and incorrectly. We deserve nicer syntax to check if a bit field is set out of the box, Zig provides that and I am happier for it.&lt;/p>
&lt;p>Please stop messaging me about how C has bitfields :)&lt;/p></description></item><item><title>Zig hashmaps explained</title><link>https://devlog.hexops.com/2022/zig-hashmaps-explained/</link><pubDate>Sat, 29 Jan 2022 00:00:00 +0000</pubDate><guid>https://devlog.hexops.com/2022/zig-hashmaps-explained/</guid><description>&lt;p>If you just got started with &lt;a href="https://ziglang.org">Zig&lt;/a>, you might quickly want to use a hashmap. Zig provides good defaults, with a lot of customization options.&lt;/p>
&lt;p>Here I will try to guide you into choosing the right hashmap type.&lt;/p>
&lt;h2 id="60-second-explainer">60-second explainer&lt;/h2>
&lt;p>You probably want:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="kr">var&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">my_hash_map&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">StringHashMap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">V&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="n">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">allocator&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Or if you do not have string keys, you can use an &lt;code>Auto&lt;/code> hashmap instead:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="kr">var&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">my_hash_map&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">AutoHashMap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">K&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">V&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="n">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">allocator&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Where &lt;code>K&lt;/code> and &lt;code>V&lt;/code> are your key and value data types, respectively. e.g. &lt;code>[]const u8&lt;/code> for a string.&lt;/p>
&lt;p>You can then use these APIs:&lt;/p>
&lt;h3 id="insert-a-value">Insert a value&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="k">try&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">my_hash_map&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">put&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="insert-a-value-assert-entry-does-not-already-exist">Insert a value, assert entry does not already exist&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="k">try&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">my_hash_map&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">putNoClobber&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Note &lt;code>putNoClobber&lt;/code> may be renamed to something like &lt;code>putAssumeNoEntry&lt;/code> in the near future: &lt;a href="https://github.com/ziglang/zig/issues/10736">ziglang/zig#10736&lt;/a>&lt;/p>
&lt;h3 id="get-a-value">Get a value&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="kr">var&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">my_hash_map&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="n">v&lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// got value &amp;#34;v&amp;#34;
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">else&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// doesn&amp;#39;t exist
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="get-a-value-insert-if-not-exist">Get a value, insert if not exist&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="kr">var&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">v&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">try&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">my_hash_map&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">getOrPut&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">v&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">found_existing&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// We inserted an entry, specify the new value
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// This is a conditional in case creating the new value is expensive
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">v&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">value_ptr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;my value&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="kr">var&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">v&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">value_ptr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// use the value
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>You can find more APIs &lt;a href="https://github.com/ziglang/zig/blob/master/lib/std/hash_map.zig#L342">by going here&lt;/a> and using your browser&amp;rsquo;s builtin search for &lt;code>pub fn&lt;/code>.&lt;/p>
&lt;h2 id="about-key-data-types">About key data types&lt;/h2>
&lt;p>Zig hash map types start with the data type of the key:&lt;/p>
&lt;ul>
&lt;li>&lt;code>std.StringHashMap&lt;/code> - uses a good default hashing function for string keys&lt;/li>
&lt;li>&lt;code>std.AutoHashMap&lt;/code> - uses a good default hashing function for most data types&lt;/li>
&lt;li>&lt;code>std.HashMap&lt;/code> - the &amp;ldquo;bring your own hashing function&amp;rdquo; option&lt;/li>
&lt;/ul>
&lt;p>Note: &lt;code>AutoHashMap&lt;/code> does not support &lt;em>slices&lt;/em>, such as &lt;code>[]const u8&lt;/code> string slices, because that is a pointer to an array and it is ambiguous whether or not you intend to hash &lt;em>the array elements&lt;/em> or &lt;em>the pointer itself&lt;/em>. You can use the generic &lt;code>std.HashMap&lt;/code> for any slice type, you just have to provide your own hash functions.&lt;/p>
&lt;h2 id="hashmaps-are-also-sets">Hashmaps are also sets&lt;/h2>
&lt;p>A set in Zig is just a hashmap with a &lt;code>void&lt;/code> value:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="kr">var&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">my_hash_map&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">AutoHashMap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">K&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="n">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">allocator&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">try&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">my_hash_map&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">put&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{});&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// `{}` is a value of type `void`
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="advanced-usages">Advanced usages&lt;/h2>
&lt;p>If you&amp;rsquo;re just getting started with Zig, don&amp;rsquo;t worry too much about the below. Just know that you have options available should you need to reduce memory usage or optimize your use of hashmaps in the future.&lt;/p>
&lt;h3 id="managed-vs-unmanaged-hashmaps">Managed vs. unmanaged hashmaps&lt;/h3>
&lt;p>You can add &lt;code>Unmanaged&lt;/code> to the end of a Zig hashmap data type, e.g. &lt;code>std.StringHashMapUnmanaged&lt;/code> in order to get the &lt;em>unmanaged&lt;/em> version.&lt;/p>
&lt;p>This merely doesn&amp;rsquo;t carry an &lt;code>allocator&lt;/code> internally, instead you must pass the allocator into every method of the hashmap. While only a few bytes, this can be a useful optimization if you&amp;rsquo;re storing many hashmaps for example.&lt;/p>
&lt;p>Managed:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="kr">var&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">my_hash_map&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">StringHashMap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">V&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="n">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">allocator&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Unmanaged:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="kr">var&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">my_hash_map&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">StringHashMapUnmanaged&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">V&lt;/span>&lt;span class="p">){};&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="array-hash-maps">Array hash maps&lt;/h3>
&lt;p>Zig actually provides &lt;a href="https://github.com/ziglang/zig/pull/5999">&lt;em>two hashmap implementations&lt;/em>&lt;/a> in the standard library&lt;/p>
&lt;p>&lt;code>std.HashMap&lt;/code>, perfect for every-day use cases:&lt;/p>
&lt;ul>
&lt;li>Optimized for lookup times primarily&lt;/li>
&lt;li>Optimized for insertion/removal times secondarily&lt;/li>
&lt;/ul>
&lt;p>&lt;code>std.ArrayHashMap&lt;/code>, useful in &lt;em>some&lt;/em> situations:&lt;/p>
&lt;ul>
&lt;li>Iterating over the hashmap is an order of magnitude faster (a contiguous array)&lt;/li>
&lt;li>Insertion order is preserved.&lt;/li>
&lt;li>You can index into the underlying data like an array if you like&lt;/li>
&lt;li>Deletions can be performed one of two ways, mirroring the &lt;code>ArrayList&lt;/code> API:
&lt;ul>
&lt;li>&lt;code>swapRemove&lt;/code>: swaps the target element with the last element in the list to remove it&lt;/li>
&lt;li>&lt;code>orderedRemove&lt;/code>: removes target element by shifting all elements forward, maintaining current ordering&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="hashmap-context">Hashmap context&lt;/h3>
&lt;p>If you choose to use &lt;code>std.HashMap&lt;/code> or &lt;code>std.ArrayHashMap&lt;/code> directly (without the &lt;code>String&lt;/code> or &lt;code>Auto&lt;/code> prefix), then you&amp;rsquo;ll find it wants a &lt;em>context&lt;/em> parameter and &lt;em>max load percentage&lt;/em>:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="kr">var&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">my_hash_map&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">HashMap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">K&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">V&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">hash_map&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">AutoContext&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">K&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">hash_map&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">default_max_load_percentage&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The &lt;em>context&lt;/em> parameter lets you embed some of your own data within the hash map type. This can be useful for &lt;a href="https://zig.news/andrewrk/how-to-use-hash-map-contexts-to-save-memory-when-doing-a-string-table-3l33">reducing the amount of memory that a hash map takes up when doing a string table&lt;/a>.&lt;/p>
&lt;h3 id="pick-your-hashmap">Pick your hashmap&lt;/h3>
&lt;p>Regular implementation:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Key type&lt;/th>
&lt;th>Managed?&lt;/th>
&lt;th>How to initialize&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>String&lt;/code>&lt;/td>
&lt;td>yes&lt;/td>
&lt;td>&lt;code>std.StringHashMap(V).init(allocator)&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Auto&lt;/code>&lt;/td>
&lt;td>yes&lt;/td>
&lt;td>&lt;code>std.AutoHashMap(K, V).init(allocator)&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>String&lt;/code>&lt;/td>
&lt;td>&lt;code>Unmanaged&lt;/code>&lt;/td>
&lt;td>&lt;code>std.StringHashMapUnmanaged(V){}&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Auto&lt;/code>&lt;/td>
&lt;td>&lt;code>Unmanaged&lt;/code>&lt;/td>
&lt;td>&lt;code>std.AutoHashMapUnmanaged(K, V){}&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;code>ArrayHashMap&lt;/code> implementation:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Key type&lt;/th>
&lt;th>Managed?&lt;/th>
&lt;th>How to initialize&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>String&lt;/code>&lt;/td>
&lt;td>yes&lt;/td>
&lt;td>&lt;code>std.StringArrayHashMap(V).init(allocator)&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Auto&lt;/code>&lt;/td>
&lt;td>yes&lt;/td>
&lt;td>&lt;code>std.AutoArrayHashMap(K, V).init(allocator)&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>String&lt;/code>&lt;/td>
&lt;td>&lt;code>Unmanaged&lt;/code>&lt;/td>
&lt;td>&lt;code>std.StringArrayHashMapUnmanaged(V){}&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Auto&lt;/code>&lt;/td>
&lt;td>&lt;code>Unmanaged&lt;/code>&lt;/td>
&lt;td>&lt;code>std.AutoArrayHashMapUnmanaged(K, V){}&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="learn-more">Learn more&lt;/h3>
&lt;p>The source code is very readable:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/ziglang/zig/blob/master/lib/std/hash_map.zig">&lt;code>std.HashMap&lt;/code>&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/ziglang/zig/blob/master/lib/std/hash_map.zig">&lt;code>std.ArrayHashMap&lt;/code>&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="help-improve-this-page">Help improve this page&lt;/h3>
&lt;p>I wrote this article quickly because I needed to explain my choice of hashmaps in the &lt;a href="https://devlog.hexops.com/categories/build-an-ecs/">&amp;ldquo;Let&amp;rsquo;s build an Entity Component System from scratch&amp;rdquo;&lt;/a> series and there was no better source of this info. I&amp;rsquo;m sure there are things that can be improved.&lt;/p>
&lt;p>&lt;a href="https://github.com/hexops/devlog/blob/main/_posts/2022-01-29-zig-hashmaps-explained.md">Feel free to send a PR!&lt;/a>&lt;/p></description></item></channel></rss>