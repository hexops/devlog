<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>graphics on Hexops' devlog</title><link>https://devlog.hexops.com/categories/graphics/</link><description>Recent content in graphics on Hexops' devlog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 11 Sep 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://devlog.hexops.com/categories/graphics/feed.xml" rel="self" type="application/rss+xml"/><item><title>Perfecting WebGPU/Dawn native graphics for Zig</title><link>https://devlog.hexops.com/2022/perfecting-webgpu-native/</link><pubDate>Sun, 11 Sep 2022 00:00:00 +0000</pubDate><guid>https://devlog.hexops.com/2022/perfecting-webgpu-native/</guid><description>&lt;picture>
&lt;source srcset="https://raw.githubusercontent.com/hexops/media/839b04fa5a72428052733d2095726894ff93466a/gpu/logo_dark.svg" media="(prefers-color-scheme: dark)">
&lt;img style="height: 100px;" src="https://raw.githubusercontent.com/hexops/media/839b04fa5a72428052733d2095726894ff93466a/gpu/logo_light.svg">
&lt;/picture>
&lt;p>We&amp;rsquo;ve just finished a complete rewrite of &lt;code>mach/gpu&lt;/code> (WebGPU/Dawn bindings for Zig), with 700+ commits, ~7.4k LOC, and 100% API coverage.&lt;/p>
&lt;p>WebGPU (not to be confused with WebGL) is a modern graphics API, acting as a unified API to the underlying Vulkan/Metal/DirectX APIs. Despite it&amp;rsquo;s name, it is also designed for use in native applications via its C API.&lt;/p>
&lt;p>Dawn is the C++ implementation of WebGPU by Google, used in Chrome, planned to be shipped to millions of browsers in the not too distant future.&lt;/p>
&lt;h2 id="machgpu-webgpu-for-zig">&lt;code>mach/gpu&lt;/code>: WebGPU for Zig&lt;/h2>
&lt;p>6 months ago we &lt;a href="https://devlog.hexops.com/2022/mach-v0.1-zig-graphics-in-60s/">released Mach v0.1&lt;/a> which enabled the creation of native applications using WebGPU graphics in Zig:&lt;/p>
&lt;img class="color" style="max-height: 300px;" src="https://user-images.githubusercontent.com/3173176/163936001-fd9eb918-7c29-4dcc-bfcb-5586f2ea1f9a.gif">
&lt;p>It all Just Works™ out of the box in under ~60s - all you need is &lt;code>zig&lt;/code>, &lt;code>git&lt;/code>, and &lt;code>curl&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">git clone https://github.com/hexops/mach
&lt;span class="nb">cd&lt;/span> mach/
zig build run-example-boids
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;small>(requires Zig v0.10+, see &lt;a href="https://github.com/hexops/mach/blob/main/doc/known-issues.md">known issues&lt;/a>.)&lt;/small>&lt;/p>
&lt;p>We do all the heavy-lifting behind the scenes for you: building Dawn using Zig as a C++ compiler, rewriting build scripts in Zig (so you don&amp;rsquo;t need ninja/cmake/etc), package up all required dependencies so you don&amp;rsquo;t need Google&amp;rsquo;s &lt;code>depot_tools&lt;/code>, and more.&lt;/p>
&lt;p>Because of this, cross-compilation to every major desktop OS is available at the flip of a switch:&lt;/p>
&lt;pre>&lt;code>$ zig build example-boids -Dtarget=x86_64-windows
$ zig build example-boids -Dtarget=x86_64-linux
$ zig build example-boids -Dtarget=x86_64-macos.12
$ zig build example-boids -Dtarget=aarch64-macos.12
&lt;/code>&lt;/pre>&lt;p>But this is old news! We released this 6 months ago-so what&amp;rsquo;s new since?&lt;/p>
&lt;h2 id="zig--webgpu-showcase-10-examples">Zig + WebGPU showcase (10+ examples)&lt;/h2>
&lt;p>The new &lt;a href="https://machengine.org/gpu">Zig WebGPU demo showcase&lt;/a> has 12+ examples you can try on your own machine to begin learning Zig and WebGPU quickly:&lt;/p>
&lt;video style="height: 40rem;" autoplay loop controls>
&lt;source src="https://user-images.githubusercontent.com/3173176/189518244-5a44ed7f-bb11-4c98-9a84-9fdc5613aec4.mp4" type="video/mp4">
&lt;/video>
&lt;h2 id="mach-core-vs-mach-engine">Mach core vs. Mach engine&lt;/h2>
&lt;p align="center">
&lt;img class="color-auto" src="https://user-images.githubusercontent.com/3173176/184719710-ebae4fbd-af14-4b2f-80ad-11527c5f3e8f.png" />
&lt;/p>
&lt;p>Mach has a choose-your-journey development strategy, where you don&amp;rsquo;t even have to adopt the entire engine to benefit from it. All the WebGPU examples we provide are &lt;em>Mach core apps&lt;/em>: they rely on Mach for window creation, user input, and setting up the WebGPU API - nothing else. Using &lt;em>Mach core&lt;/em>, you write your own engine!&lt;/p>
&lt;p>Why use this over, say, GLFW and WebGPU on your own? The benefit is that this will work on Desktop, WebAssembly (soon), Mobile (future), and consoles (long term.) You can write Mach core apps in Zig, or other languages via &lt;code>libmach&lt;/code> (more on this later.) Think of Mach core as &lt;em>a competitor to SDL/GLFW.&lt;/em>&lt;/p>
&lt;p>In the future we&amp;rsquo;ll offer &lt;em>Mach engine&lt;/em> apps, where you buy into our ECS, Unity/Unreal-like editor, and other composable building-blocks that make up the engine at your choosing. But this isn&amp;rsquo;t ready today.&lt;/p>
&lt;h3 id="dawnwebgpu-on-the-steam-deck">Dawn/WebGPU on the Steam Deck&lt;/h3>
&lt;p>We believe Linux should be a first-class platform, and because of this &lt;a href="https://twitter.com/slimsag/status/1544858201849376768">we&amp;rsquo;ve found&lt;/a> Mach all Just Works™ right out of the box on the Steam Deck (running natively as a Linux Vulkan application, no DirectX or Proton in the mix.):&lt;/p>
&lt;div class="video-container">&lt;video autoplay loop muted src="https://user-images.githubusercontent.com/3173176/184556247-6e039490-99ee-48f4-91b4-d2cfd7a7f847.mp4">&lt;/video>&lt;/div>
&lt;h2 id="a-complete-rewrite-of-machgpu-to-be-lean--mean">A complete rewrite of &lt;code>mach/gpu&lt;/code> to be lean &amp;amp; mean&lt;/h2>
&lt;p>When we wrote the initial WebGPU bindings for Zig 6+ months ago, our primary goal was just to get &lt;em>something&lt;/em> working to where we could start building out examples: we always knew we&amp;rsquo;d need to revisit things later, especially as Browser support, the use of native extensions in Dawn (like bindless support in the future, etc.), overhead &amp;amp; other aspects became clear.&lt;/p>
&lt;p>We&amp;rsquo;ve finally done that revisit in a month-long complete rewrite of &lt;code>mach/gpu&lt;/code> from the ground up. This brings 700+ commits, zero-overhead bindings, Dawn native extensions, and much more. Here are the highlights.&lt;/p>
&lt;h3 id="righting-our-wrongs-runtime-interfaces">Righting our wrongs: runtime interfaces&lt;/h3>
&lt;p>One goal of &lt;code>mach/gpu&lt;/code> is to be able to intercept WebGPU API calls, so that we can provide superior debugging facilities in the future (imagine record-and-replay, step-by-step debugging of WebGPU API calls, etc.)&lt;/p>
&lt;p>In the old &lt;code>mach/gpu&lt;/code>, we achieved this by wrapping each WebGPU API object that had methods (like textures, render pass encoders, etc.) in a &lt;em>runtime interface&lt;/em> similar to Zig&amp;rsquo;s &lt;code>std.mem.Allocator&lt;/code> interface:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="kr">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">const&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Texture&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">/// The type erased pointer to the Texture implementation
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">/// Equal to c.WGPUTexture for NativeInstance.
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ptr&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">anyopaque&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vtable&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="kr">const&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">VTable&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">};&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="kr">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">const&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">VTable&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">destroy&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ptr&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">anyopaque&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">};&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="kr">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">inline&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">destroy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tex&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Texture&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tex&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">vtable&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">destroy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tex&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ptr&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Our thought process was simply to follow any established patterns, learn what didn&amp;rsquo;t work about it by writing examples, and then revisiting the API later. Even six months ago, though, we knew there were issues with this approach.&lt;/p>
&lt;p>&lt;strong>The problem:&lt;/strong> In WebGPU, &lt;code>Descriptor&lt;/code> data structures are often passed to methods: these fairly large data structures contain a wide range of options and graphics pipeline state to use, and often involve passing a list of WebGPU objects as a field - or nested field - as part of the Descriptor data structure. Because our &lt;code>Texture&lt;/code> involves keeping a &lt;code>ptr&lt;/code> (the interface implementation) and a &lt;code>vtable&lt;/code> pointer (our implementation methods) it meant that a &lt;code>gpu.Texture&lt;/code> was two pointers, while a C &lt;code>WGPUTexture&lt;/code> was a single pointer - breaking ABI compatibility.&lt;/p>
&lt;p>This meant that our &lt;code>Texture&lt;/code> could not simply be passed to a C API expecting a &lt;code>WGPUTexture&lt;/code>: instead, we needed to pass our &lt;code>.ptr&lt;/code> field only. This had viral effects, though: every &lt;code>Descriptor&lt;/code> struct which embedded a &lt;code>Texture&lt;/code> needed to be copied/rewritten to convert our two-pointer &lt;code>Texture&lt;/code> to a single-pointer &lt;code>WGPUTexture&lt;/code>. Worse yet, some descriptors hold &lt;em>dynamic arrays&lt;/em> of such objects, requiring us to &lt;em>copy an array to a temporary (and worst-case, heap-allocated), buffer&lt;/em> just in order to call the actual WebGPU C API.&lt;/p>
&lt;p>Needless to say, this was a cancer we felt we absolutely had to get rid of in the rewrite.&lt;/p>
&lt;h3 id="comptime-interfaces">Comptime interfaces&lt;/h3>
&lt;p>While we want to get rid of runtime interfaces, maintain C ABI compatability, and be zero-overhead-we&amp;rsquo;d still like to be able to intercept WebGPU API calls if desired, so that we can provide superior debugging facilities in the future.&lt;/p>
&lt;p>Zig&amp;rsquo;s &lt;code>std.mem.Allocator&lt;/code> being a &lt;em>runtime interface&lt;/em> makes sense because they have different use cases, no existing ABI to remain compatible with, and importantly there are cases where you would want to have &lt;strong>multiple allocator implementations&lt;/strong> in the same program for different purposes.&lt;/p>
&lt;p>With WebGPU, we have different constraints: it&amp;rsquo;s very unlikely to want multiple WebGPU implementations per program. We do need to maintain ABI compatibility. So to address this, we introduce a &lt;em>comptime interface&lt;/em>.&lt;/p>
&lt;p>&lt;img class="color-auto" style="max-height: 200px;" src="https://user-images.githubusercontent.com/3173176/184733061-92f1165d-8d20-4c97-8852-34b1abf5b655.png" />&lt;/p>
&lt;p>Let&amp;rsquo;s look at the &lt;code>Texture.destroy&lt;/code> method from earlier:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="kr">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">inline&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">destroy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tex&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Texture&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tex&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">vtable&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">destroy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tex&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ptr&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>As you can see, this would&amp;rsquo;ve called the &lt;em>tex.vtable pointer&lt;/em>, and passed the &lt;code>tex.ptr&lt;/code> interface implementation pointer to it. It&amp;rsquo;s a classical runtime interface implementation. The key point here is that the data type can remain the same, while the &lt;em>implementation pointer&lt;/em> could be replaced at runtime with a different one. On the other side of this invocation, &lt;code>tex.vtable.destroy&lt;/code> would look like this:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="kr">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">destroy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ptr&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">anyopaque&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">wgpuTextureDestroy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">@ptrCast&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">WGPUTexture&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ptr&lt;/span>&lt;span class="p">));&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now let&amp;rsquo;s look at how the &lt;em>comptime interface&lt;/em> approach differs:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="kr">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">const&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Texture&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">opaque&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">inline&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">destroy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">texture&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">Texture&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Impl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">textureDestroy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">texture&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Firstly, we see that &lt;code>*gpu.Texture&lt;/code> is merely an opaque pointer (a C &lt;code>void*&lt;/code> if you like), just the same as before. Unlike before, however, there is no vtable pointer: there is only one pointer, it&amp;rsquo;s passed directly to the implementor via &lt;code>Impl.textureDestroy&lt;/code> - and the implementation &lt;em>cannot be changed at runtime&lt;/em>.&lt;/p>
&lt;p>This solves the issue of ABI compatibility (we have only one pointer now), but we still need to let the user of the library - say from their &lt;code>main.zig&lt;/code> file - decide which &lt;code>Impl&lt;/code>ementation of the interface to use.&lt;/p>
&lt;p>Traditionally, one might use generics for this (passing an &lt;code>Impl&lt;/code> type parameter to each method for example), but we&amp;rsquo;d rather not pass that around everywhere: after all, we know it will be decided by one user of the API for the entire program, and requiring a type parameter here would have viral effects to every user of the WebGPU API (every API they expose would need that same type parameter.)&lt;/p>
&lt;p>Luckily, in Zig there is a trick: from within our WebGPU API we can import the root file of the program (e.g. &lt;code>main.zig&lt;/code>). Zig allows this since it lazily evaluates code, so there&amp;rsquo;s no dependency loop here. So in our &lt;code>mach/gpu&lt;/code> package, we can define:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="kr">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">const&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Impl&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">blk&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">const&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">@import&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;root&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="nb">@hasDecl&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;GPUInterface&amp;#34;&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">@compileError&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;expected to find `pub const GPUInterface = T;` in root file&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">_&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">gpu&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Interface&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">GPUInterface&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// verify the type
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">break&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="n">blk&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">GPUInterface&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">};&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This effectively looks in the user&amp;rsquo;s &lt;code>main.zig&lt;/code> (&amp;ldquo;root&amp;rdquo;) file for a declaration like:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="kr">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">const&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">GPUInterface&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">gpu&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">dawn&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Interface&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Once resolved, our &lt;code>Impl&lt;/code> constant is known statically at compile time to be an exact interface implementation of the &lt;code>gpu.Interface&lt;/code>: &lt;code>gpu.dawn.Interface&lt;/code> in this case, which is just a struct type with functions in it calling the Dawn C API:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="kr">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">const&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Interface&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">inline&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">textureDestroy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">texture&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">gpu&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Texture&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">procs&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">textureDestroy&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="o">?&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">@ptrCast&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">WGPUTexture&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">texture&lt;/span>&lt;span class="p">));&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The trick here to ensuring that a type actually satisfies the &lt;code>gpu.Interface&lt;/code> is that you write a type validator function, which checks if the struct passes to it has the desired methods with matching function signatures:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="c1">/// Verifies that a gpu.Interface implementation exposes the expected function declarations.
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kr">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Interface&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kr">comptime&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">type&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">type&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">assertDecl&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;textureDestroy&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">texture&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">gpu&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Texture&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">callconv&lt;/span>&lt;span class="p">(.&lt;/span>&lt;span class="n">Inline&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">};&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Best of all, since the interface implementation is completely static and known at comptime, we can enforce every method invocation is &lt;code>inline&lt;/code> and we&amp;rsquo;re not adding any overhead.&lt;/p>
&lt;h3 id="libmach-and-gpuexport">libmach and gpu.Export&lt;/h3>
&lt;p>&lt;img class="color-auto" style="max-height: 300px;" src="https://user-images.githubusercontent.com/3173176/184734447-b3df59dc-9b8c-453f-9f8e-2c01eb45e086.png" />&lt;/p>
&lt;p>One recent development is &lt;code>libmach&lt;/code>, which will provide at least a C ABI for the creation of &lt;em>Mach core&lt;/em> applications from other languages (think a bit like SDL, but for WebGPU and it works on Desktop, Mobile, WebAssembly &amp;amp; more in the future.)&lt;/p>
&lt;p>One thing we&amp;rsquo;d like to retain, though, is the ability to have such applications get the same nice WebGPU debugging experience in the future, while still using that language&amp;rsquo;s existing WebGPU bindings. This means instead of calling Dawn&amp;rsquo;s &lt;code>wgpuTextureDestroy&lt;/code> for example, we&amp;rsquo;d need to call &lt;code>libmach&lt;/code>&amp;rsquo;s &lt;code>wgpuTextureDestroy&lt;/code>.&lt;/p>
&lt;p>This is where &lt;code>gpu.Export&lt;/code> comes in: it merely takes a &lt;code>gpu.Interface&lt;/code> struct with all of the Zig functions that implement the WebGPU API, and exports the WebGPU C ABI for them:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="c1">/// Exports C ABI function declarations for the given gpu.Interface implementation.
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kr">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Export&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kr">comptime&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">type&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">type&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">_&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Interface&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// verify implementation is a valid interface
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// WGPU_EXPORT void wgpuTextureDestroy(WGPUTexture texture);
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">export&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">wgpuTextureDestroy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">texture&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">gpu&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Texture&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">textureDestroy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">texture&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">};&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>From this, you might notice something important: We&amp;rsquo;ve maintained 100% C ABI compatability in the new &lt;code>mach/gpu&lt;/code> rewrite. Every data structure is ABI compatible with Dawn&amp;rsquo;s &lt;code>webgpu.h&lt;/code> header.&lt;/p>
&lt;h3 id="zig-flag-sets">Zig flag sets&lt;/h3>
&lt;p>One nice property of Zig is it&amp;rsquo;s &lt;code>packed struct&lt;/code>s. For example, in C there is a &lt;code>WGPUColorWriteMaskFlags&lt;/code> type which is a &lt;code>uint32_t&lt;/code> where the first four bits represent a color write mask for red, green, blue, and alpha respectively. The remaining 28 bits are unused at present.&lt;/p>
&lt;p>&lt;img class="color-auto" style="max-height: 300px;" src="https://user-images.githubusercontent.com/3173176/184735519-cc78d19d-73e8-4914-8f3d-fc3a15d00bb7.png" />&lt;/p>
&lt;p>Interacting with &lt;code>WGPUColorWriteMaskFlags&lt;/code> in C can be a bit cumbersome: you need to make sure you remember the right bit masking operations to set bits, check if they are set, and so on.&lt;/p>
&lt;p>In Zig, we have &lt;code>packed struct&lt;/code> in which &lt;code>bool&lt;/code> is just one bit - and we have integers of any bit width we desire. We can use this to compose a 32-bit data structure compatible with the C ABI variant, but using nice bools to represent those first four bits:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="kr">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">const&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ColorWriteMaskFlags&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">packed&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">red&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">bool&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">green&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">bool&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">blue&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">bool&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">alpha&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">bool&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">_padding&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">u28&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">};&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This is nice because now one can simply check &lt;code>if (write_mask.red and write_mask.blue)&lt;/code> for example, or simply pass it as a parameter to a function like &lt;code>ColorWriteMaskFlags{.red = true, .blue = true}&lt;/code>.&lt;/p>
&lt;p>Read more about how this works: &lt;a href="https://devlog.hexops.com/2022/packed-structs-in-zig/">&amp;ldquo;Packed structs in Zig make bit/flag sets trivial&amp;rdquo;&lt;/a>&lt;/p>
&lt;h3 id="dawn-native-extensions">Dawn native extensions&lt;/h3>
&lt;p>One not-so-friendly aspect of &lt;code>webgpu.h&lt;/code> (the C API for WebGPU) is that it allows for arbitrary extension of the API via so-called chaining. For example, let&amp;rsquo;s look at a descriptor struct used as the parameters to create a shader module from its text source code:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">typedef&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">WGPUShaderModuleDescriptor&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">WGPUChainedStruct&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">nextInChain&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">char&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">label&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// nullable
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="n">WGPUShaderModuleDescriptor&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Here you can obviously see there is a &lt;code>label&lt;/code> for the shader module - but where does our shader source code go? It&amp;rsquo;s not clear. And what goes in that &lt;code>nextInChain&lt;/code> field? It looks like this:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">typedef&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">WGPUChainedStruct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">WGPUChainedStruct&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">next&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">WGPUSType&lt;/span> &lt;span class="n">sType&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="n">WGPUChainedStruct&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Effectively, WebGPU implementations can take arbitrary data structures via this chaining process - as extensions to the WebGPU API for example - so long as the chained struct &lt;em>begins with these ABI-compatible fields&lt;/em>.&lt;/p>
&lt;p>For example-to construct a shader in Zig, you might write:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="kr">const&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">next_in_chain&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">WGPUShaderModuleWGSLDescriptor&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">chain&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">WGPUChainedStruct&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">next&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// nothing else to chain
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">sType&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">WGPUSType_ShaderModuleWGSLDescriptor&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// so it knows what type we chained!
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">},&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">source&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">my_shader_source_code_text&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">};&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="kr">const&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">shader_module_descriptor&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">WGPUShaderModuleDescriptor&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">nextInChain&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">@ptrCast&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">?*&lt;/span>&lt;span class="kr">const&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">WGPUChainedStruct&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">next_in_chain&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">label&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;my shader module&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">};&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>That&amp;rsquo;s pretty nasty! Also take note of how &lt;code>nextInChain&lt;/code> needs to be &lt;em>cast to&lt;/em> the &lt;code>WGPUChainedStruct&lt;/code> pointer type, only the &lt;code>sType&lt;/code> field identifies it (the C type system can&amp;rsquo;t.)&lt;/p>
&lt;p>More importantly: because &lt;code>nextInChain&lt;/code> is an opaque type, you can&amp;rsquo;t really know what type of pointer is legal at all to give to the API in a &lt;code>nextInChain&lt;/code> field. Oof!&lt;/p>
&lt;p>Needless to say, we didn&amp;rsquo;t want to adopt this lack of type safety (and lack of documentation), so we worked with the Dawn developers at Google &lt;a href="https://bugs.chromium.org/p/dawn/issues/detail?id=1486&amp;amp;q=reporter%3Ame&amp;amp;can=1">to add documentation about what structs are legal where&lt;/a>, and then in Zig we used this information to replace &lt;code>next_in_chain&lt;/code> fields with a union of pointers so it&amp;rsquo;s type safe (for all known structs) and self-documenting. Our example from before becomes just:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="kr">const&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">shader_module_descriptor&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">gpu&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ShaderModule&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Descriptor&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">next_in_chain&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">.{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">wgsl_descriptor&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="p">.{.&lt;/span>&lt;span class="n">source&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">my_shader_source_code_text&lt;/span>&lt;span class="p">},&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">},&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">label&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;my shader module&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">};&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>It may not seem much more readable, but all of the type system info is there to protect you and that&amp;rsquo;s what counts. Of course, we also added a helper to create WGSL shader modules so this ends up being truly clean:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="n">device&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">createShaderModuleWGSL&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;my shader module&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">my_shader_source_code_text&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="upstreamed-patches-to-dawn">Upstreamed patches to Dawn&lt;/h3>
&lt;p>Out of the box, Dawn needed a little love to be compiled with Zig as the C/C++ compiled - so we&amp;rsquo;ve contributed patches upstream for this:&lt;/p>
&lt;ul>
&lt;li>Resolving some undefined behavior in Dawn caught by Zig using UBSAN by default. &lt;a href="https://dawn-review.googlesource.com/c/dawn/+/87380">#87380&lt;/a>&lt;/li>
&lt;li>Improving constexpr compatibility for a DirectX constant, due to using MinGW DirectX headers. &lt;a href="https://dawn-review.googlesource.com/c/dawn/+/87381">#87381&lt;/a>&lt;/li>
&lt;li>Correcting an invocation of &lt;code>_uuidof&lt;/code> on Windows. &lt;a href="https://dawn-review.googlesource.com/c/dawn/+/87309">#87309&lt;/a>&lt;/li>
&lt;li>Adding an option to disable use of (Windows 10+) Windows UI, as we don&amp;rsquo;t have headers for it. &lt;a href="https://dawn-review.googlesource.com/c/dawn/+/87383">#87383&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="obvious-improvements">Obvious improvements&lt;/h3>
&lt;p>There were many other &lt;a href="https://github.com/hexops/mach/tree/main/gpu">obvious improvements&lt;/a> we won&amp;rsquo;t enumerate in detail here:&lt;/p>
&lt;ul>
&lt;li>Achieving 100% API coverage, and coming up with processes/rules/conventions to ensure this all remains up-to-date and correct going forward as Dawn&amp;rsquo;s &lt;code>webgpu.h&lt;/code> API changes.&lt;/li>
&lt;li>Setting the right default values for every field in the entire API, which reduces verbosity of the API substantially.&lt;/li>
&lt;li>Adding slice helpers where the C ABI uses pointers-and-lengths distinctly.&lt;/li>
&lt;li>Adding type-safe helpers to callbacks which would have a &lt;code>void*&lt;/code> userdata pointer in the C API.&lt;/li>
&lt;li>Exposing every Dawn native extension, e.g. in anticipation of bindless support in the future.&lt;/li>
&lt;/ul>
&lt;h2 id="standalone-repository">Standalone repository&lt;/h2>
&lt;p>As with all &lt;a href="https://github.com/hexops/mach/tree/main/libs">standalone Mach libraries&lt;/a> that reach a certain level of maturity, &lt;code>mach/gpu&lt;/code> is now available in it&amp;rsquo;s own standalone repository with an example using it with GLFW: &lt;a href="https://github.com/hexops/mach-gpu">https://github.com/hexops/mach-gpu&lt;/a>&lt;/p>
&lt;h2 id="whats-next-browser-support-more-examples">What&amp;rsquo;s next: browser support, more examples&lt;/h2>
&lt;p>I&amp;rsquo;d say we&amp;rsquo;re well on our way to having a perfect WebGPU/Dawn API for Zig, but we do have a little ways to go. Things coming up include:&lt;/p>
&lt;ul>
&lt;li>More examples&lt;/li>
&lt;li>Adding browser support: this will be achieved in the near future by direct WebAssembly-&amp;gt;JS calls (not via Emscripten.)&lt;/li>
&lt;li>Adding higher-level helpers (always 100% optional, the C ABI is always available and present via &lt;code>gpu.Impl.foobar&lt;/code> methods.)&lt;/li>
&lt;/ul>
&lt;p>We&amp;rsquo;re continuing to work towards &lt;a href="https://github.com/hexops/mach/issues/355">the Mach v0.2 release&lt;/a> otherwise (special thanks for all those contributing to Mach today!)&lt;/p>
&lt;h2 id="thanks-for-reading">Thanks for reading&lt;/h2>
&lt;div style="display: flex; flex-direction: row; align-items: center;">
&lt;img align="left" style="max-height: 12.5rem;" src="https://user-images.githubusercontent.com/3173176/187348488-0b52e87d-3a48-421c-9402-be78e32b5a20.png">&lt;/img>
&lt;ul>
&lt;li>Join the &lt;a href="https://discord.gg/XNG3NZgCqp">Mach Discord server&lt;/a>&lt;/li>
&lt;li>Check out the mach/gpu &lt;a href="https://machengine.org/gpu">example showcase&lt;/a>&lt;/li>
&lt;li>Help us &lt;a href="https://github.com/hexops/mach/issues/230">port/write more WebGPU examples&lt;/a> to Zig&lt;/li>
&lt;li>Read up on WebGPU &lt;a href="https://surma.dev/things/webgpu/">compute&lt;/a> and &lt;a href="https://alain.xyz/blog/raw-webgpu">rendering&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/sponsors/slimsag">Sponsor development&lt;/a> if you like what we're doing!&lt;/li>
&lt;/ul>
&lt;/div></description></item><item><title>Mach Engine: The future of graphics (with Zig)</title><link>https://devlog.hexops.com/2021/mach-engine-the-future-of-graphics-with-zig/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://devlog.hexops.com/2021/mach-engine-the-future-of-graphics-with-zig/</guid><description>&lt;p>In the coming months, we&amp;rsquo;ll begin to have truly cross-platform low-level graphics, with the ability to cross compile GPU-accelerated applications written in Zig from any OS and deploy to desktop, mobile, and (in the future) web.&lt;/p>
&lt;h2 id="mach-engine">Mach engine&lt;/h2>
&lt;img class="color-auto" alt="Mach: Game engine &amp; graphics toolkit for the future" src="https://user-images.githubusercontent.com/3173176/137651926-3734c3b2-4875-47de-b42f-0ece854756f7.png">
&lt;p>I&amp;rsquo;ve been working on &lt;a href="https://github.com/hexops/mach">Mach Engine&lt;/a> for about 4 months now, although it as a project is many years in the making, and I believe in the next 4-6 months we&amp;rsquo;ll have completion of the first key milestone: truly cross platform graphics and seamless cross compilation.&lt;/p>
&lt;h2 id="vision">Vision&lt;/h2>
&lt;p>Today, I share only the first milestone: Mach engine core. I&amp;rsquo;ve been working on this for around 1 year now, and we&amp;rsquo;re close (maybe 4-6 months away) from completion:&lt;/p>
&lt;p>&lt;a class="imglink" href="https://user-images.githubusercontent.com/3173176/137649720-072ff7fe-323d-49c6-ae88-51344e04e3e5.png">&lt;img class="color-auto" alt="Zero fuss installation, out of the box cross compilation, and a truly cross-platform graphics API" src="https://user-images.githubusercontent.com/3173176/137649720-072ff7fe-323d-49c6-ae88-51344e04e3e5.png">&lt;/a>&lt;/p>
&lt;h2 id="zero-fuss-installation--cross-compilation">Zero fuss installation &amp;amp; cross compilation&lt;/h2>
&lt;p>Only &lt;code>zig&lt;/code> and &lt;code>git&lt;/code> are needed to build from any OS and produce binaries for every OS. You do &lt;strong>not&lt;/strong> need any system dependencies, C libraries, SDKs (Xcode, etc.), C compilers or anything else.&lt;/p>
&lt;p>We&amp;rsquo;re able to achieve this thanks to two things:&lt;/p>
&lt;ol>
&lt;li>Zig has fantastic cross-compilation support, including its own custom linker &lt;code>zld&lt;/code> written by &lt;a href="http://www.jakubkonka.com/">Jakub Konka&lt;/a> which is capable of supporting MacOS cross compilation.&lt;/li>
&lt;li>Mach doing the heavy lifting of packaging the required system SDK libraries and C sources for e.g. GLFW so our Zig build scripts can simply &lt;code>git clone&lt;/code> them for you as needed for the target OS you&amp;rsquo;re building for, completely automagically.&lt;/li>
&lt;/ol>
&lt;h2 id="truly-cross-platform-graphics-api">Truly cross-platform graphics API&lt;/h2>
&lt;h3 id="directx-12-metal-vulkan--opengl">DirectX 12, Metal, Vulkan &amp;amp; OpenGL&lt;/h3>
&lt;p>Imagine a low-level, little to no overhead graphics API that unifies DirectX, Metal, Vulkan, and OpenGL (if no others are available):&lt;/p>
&lt;p>&lt;a class="imglink" href="https://user-images.githubusercontent.com/3173176/137646296-72ba698e-c710-4daf-aa75-222f8d717d00.png">&lt;img class="color-auto" alt="Simple, low-level unified graphics API mapping to DirectX 12, Metal, Vulkan, and OpenGL" src="https://user-images.githubusercontent.com/3173176/137646296-72ba698e-c710-4daf-aa75-222f8d717d00.png">&lt;/a>&lt;/p>
&lt;p>&lt;em>This isn&amp;rsquo;t anything new:&lt;/em> all modern engines provide this, Godot has been working towards this for &lt;em>years&lt;/em> (and still is), and there exist abstraction layers for Vulkan over most of these APIs as well.&lt;/p>
&lt;h3 id="vendor-support">Vendor support&lt;/h3>
&lt;p>&lt;strong>An API is only as good as the momentum behind it.&lt;/strong> What modern API can target the largest array of platforms with the most vendor backing?&lt;/p>
&lt;p>&lt;a class="imglink" href="https://user-images.githubusercontent.com/3173176/137647361-3340e33a-9b2f-4c0d-aba5-6bb99ffd1cd8.png">&lt;img class="color-auto" alt="Google to Vulkan, Microsoft to DirectX, Apple to Metal, AMD and NVidia to everything." src="https://user-images.githubusercontent.com/3173176/137647361-3340e33a-9b2f-4c0d-aba5-6bb99ffd1cd8.png">&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Microsoft sees DirectX as the future, not Vulkan.&lt;/strong> (DirectX 13 is coming by the end of 2022.)&lt;/li>
&lt;li>&lt;strong>Apple sees Metal as the future, not Vulkan.&lt;/strong> OpenGL and OpenCL are deprecated, and private legal arguments with Khoronos make it unlikely we&amp;rsquo;ll ever see OpenGL or Vulkan on Apple hardware ever again.&lt;/li>
&lt;li>Google, with their Fuschia OS &lt;a href="https://fuchsia.dev/fuchsia-src/concepts/graphics/magma">appears to be primarily into Vulkan&lt;/a> from a system-level POV.&lt;/li>
&lt;li>&lt;strong>NVIDIA, AMD, and Intel generally support as many graphics APIs as possible&lt;/strong>, they want to sell hardware.&lt;/li>
&lt;/ul>
&lt;h3 id="one-api-that-apple-microsoft-and-google-can-all-agree-on">One API that Apple, Microsoft, and Google can all agree on&lt;/h3>
&lt;p>&lt;a class="imglink" href="https://user-images.githubusercontent.com/3173176/137647342-abf2bde6-a8bb-4276-b072-95c279c5d92f.png">&lt;img class="color-auto" alt="Mozilla, Google, Microsoft, Apple, and Intel all to WebGPU" src="https://user-images.githubusercontent.com/3173176/137647342-abf2bde6-a8bb-4276-b072-95c279c5d92f.png">&lt;/a>&lt;/p>
&lt;p>Outside the bounds of traditional graphics APIs there exists an attempt to provide a unified API across all platforms, &lt;a href="https://en.wikipedia.org/wiki/WebGPU">WebGPU&lt;/a> (not to be confused with the much older &lt;em>WebGL&lt;/em>).&lt;/p>
&lt;p>Mozilla, Google, Apple, and Microsoft all got together to build an abstraction layer over the modern graphics APIs - finding the common ground between Direct3D 12, Metal, and Vulkan - plus a safe way to expose that functionality in browsers.&lt;/p>
&lt;p>The name &lt;em>WebGPU&lt;/em> might lead you to believe that this is only for browsers, and that it may not be low-level or fast - but this really couldn&amp;rsquo;t be further from the truth.&lt;/p>
&lt;h3 id="apple--googles-role-is-what-makes-webgpu-unique-and-why-we-chose-it">Apple &amp;amp; Google&amp;rsquo;s role is what makes WebGPU unique, and why we chose it&lt;/h3>
&lt;p>&lt;a class="imglink" href="https://user-images.githubusercontent.com/3173176/137648560-e15820d7-6427-4ebd-95bb-c7c9f026477a.png">&lt;img class="color-auto" alt="Khronos group out of the piture in the future" src="https://user-images.githubusercontent.com/3173176/137648560-e15820d7-6427-4ebd-95bb-c7c9f026477a.png">&lt;/a>&lt;/p>
&lt;p>What is new about WebGPU in my view is the vendors playing key roles in its development, and the fact that it grew outside the Khronos Group.&lt;/p>
&lt;p>Although abstraction layers over modern graphics APIs are nothing new - as Apple, Google, and Microsoft continue to get more into manufacturing their own hardware (it&amp;rsquo;s clear this is a strategic move for them) we should ask ourselves how this will change the landscape, and WebGPU is the first cross-vendor API to be produced by this new ecosystem.&lt;/p>
&lt;h3 id="webgpu-extended-thoughts">WebGPU extended thoughts&lt;/h3>
&lt;details>
&lt;summary>Is WebGPU "native enough"? Yes&lt;/summary>
&lt;p>For browsers, WebGPU will require sandboxing and validation layers. But in native uses, this can all be turned off, and the WebGPU developers are clearly thinking about this use case:&lt;/p>
&lt;ul>
&lt;li>Google's implementation of WebGPU, &lt;a href="https://dawn.googlesource.com/dawn">Dawn&lt;/a>, can be configured to effectively turn off all browser sandboxing / validation that could harm performance due to its client/server architecture.&lt;/li>
&lt;li>Mozilla / gfx-rs Rust engineers have published articles such as &lt;a href="http://kvark.github.io/web/gpu/native/2020/05/03/point-of-webgpu-native.html">"The point of WebGPU on native"&lt;/a>.&lt;/li>
&lt;/ul>
&lt;p>As for the quality of implementations, we could compare the amount of resources going into e.g. Google's WebGPU implementation vs. the amount of resources going into Unity/Unreal/MoltenVK/other graphics abstraction layers - but I suspect they're &lt;em>about equal&lt;/em>.&lt;/p>
&lt;/details>
&lt;details>
&lt;summary>Will WebGPU be implemented on GPUs natively? Maybe someday&lt;/summary>
&lt;p>Not anytime soon. We get some insight into this &lt;a href="https://github.com/gpuweb/gpuweb/issues/847#issuecomment-642883924">via @kvark&lt;/a>, a WebGPU developer:&lt;/p>
&lt;blockquote>
&lt;p>[...] We are not in Khronos, and therefore we have limited participation from IHVs (only Intel and Apple are active). WebGPU was never designed to be implemented by the drivers. I mean, it would totally be rad, in the context of how usable WebGPU &lt;a href="http://kvark.github.io/web/gpu/native/2020/05/03/point-of-webgpu-native.html">can be on native&lt;/a>, but it couldn't be the requirement from the start.&lt;/p>
&lt;/blockquote>
&lt;p>But as WebGPU usage grows or even becomes prodominate due to it being the most powerful API in browsers, and as Microsoft, Google, and Apple continue to develop their own hardware - I think it's not unreasonable to think that it's possible some day WebGPU will be an even more direct 1:1 mapping between a cross-platform API and low-level APIs, more direct than Vulkan abstraction layers such as MoltenVK (which is required to get Vulkan working on top of MacOS's Metal API) - with the potential that some vendor starts asking "what would a GPU native WebGPU implementation look like?"&lt;/p>
&lt;/details>
&lt;details>
&lt;summary>Momentum of WebGPU vs. Vulkan&lt;/summary>
&lt;p>To &lt;a href="https://news.ycombinator.com/item?id=23090432">quote&lt;/a> &lt;a href="http://kvark.github.io/about/">Dzmitry Malyshau / kvark&lt;/a>, a Mozilla engineer working on gfx-rs and WebGPU:&lt;/p>
&lt;blockquote>
&lt;p>At some point, it comes down to the amount of momentum behind the API. In case of WebGPU, we have strong support from Intel and Apple, which are hardware vendors, as well as Google, who can influence mobile hardware vendors. We are making the specification and have resources to appropriately test it and develop the necessary workarounds. It's the quantity to quality transition that sometimes just needs to cross a certain threshold in order to succeed.&lt;/p>
&lt;/blockquote>
&lt;p>According to some, Nvidia and AMD tend to develop new features with Microsoft as part of DirectX. Only then are they "ported" back to Vulkan and OpenGL. I think that says a lot.&lt;/p>
&lt;/details>
&lt;h2 id="what-progress-has-been-made-so-far-on-mach-engine">What progress has been made so far on Mach Engine?&lt;/h2>
&lt;p>Today, we have cross-compilation of GLFW on all desktop OSs working out of the box with nothing more than &lt;code>zig&lt;/code> and &lt;code>git&lt;/code>:&lt;/p>
&lt;p>&lt;a class="imglink" href="https://user-images.githubusercontent.com/3173176/137650099-cd370046-eb43-4fe4-a72a-f54ebe3153c1.png">&lt;img class="color-auto" alt="Cross compilation from Mac, Linux, and Windows to eachother on all major architectures." src="https://user-images.githubusercontent.com/3173176/137650099-cd370046-eb43-4fe4-a72a-f54ebe3153c1.png">&lt;/a>&lt;/p>
&lt;p>This involved:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/hexops/sdk-macos-11.3">Packaging MacOS SDKs&lt;/a> and &lt;a href="https://github.com/hexops/sdk-linux-x86_64">Linux system X11/Wayland libraries&lt;/a> into SDKs, and creating Zig build scripts that could merely &lt;code>git clone&lt;/code> them and utilize them for cross-compilation.&lt;/li>
&lt;li>Purchasing Apple M1 hardware to test on, and for GitHub Actions as it doesn&amp;rsquo;t support it.&lt;/li>
&lt;li>Normalizing symlinks in Mac/Linux SDKs everywhere so that Windows users don&amp;rsquo;t have a hard time with Git symlink management.&lt;/li>
&lt;li>Contributing &lt;a href="https://github.com/ziglang/zig/pull/9734">a small fix to the Zig linker&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>All this to say, we&amp;rsquo;re really taking a holistic approach to achieve this.&lt;/p>
&lt;h2 id="whats-next-webgpu">What&amp;rsquo;s next? WebGPU&lt;/h2>
&lt;p>I&amp;rsquo;m happy to report that a fair amount of progress on this front has been made.&lt;/p>
&lt;p>Here is Google&amp;rsquo;s WebGPU implementation, Dawn, compiled using &lt;code>zig&lt;/code>:
&lt;a class="imglink" href="https://user-images.githubusercontent.com/3173176/137650403-290c6a94-7ee4-44be-8ed0-94f96adcde4e.png">&lt;img alt="A red triangle in a black window titled 'Dawn Window', the" src="https://user-images.githubusercontent.com/3173176/137650403-290c6a94-7ee4-44be-8ed0-94f96adcde4e.png">&lt;/a>
&lt;a class="imglink" href="https://user-images.githubusercontent.com/3173176/137650621-f304f20b-5f74-4a3d-956d-7feb3838351d.png">&lt;img alt="A Zig code file, hello_triangle.zig showing Dawn and WebGPU API usage in Zig" src="https://user-images.githubusercontent.com/3173176/137650621-f304f20b-5f74-4a3d-956d-7feb3838351d.png">&lt;/a>&lt;/p>
&lt;p>This includes:&lt;/p>
&lt;ul>
&lt;li>A ~500 line port of the &lt;code>hello_triangle&lt;/code> example from Dawn to Zig&lt;/li>
&lt;li>A ~1200 line &lt;code>build.zig&lt;/code> file which compiles all the Dawn sources using Zig, without using Google&amp;rsquo;s ninja/etc development tools.&lt;/li>
&lt;li>A hack to workaround a bug in Zig where ObjC++ &lt;code>.mm&lt;/code> files are not yet recognized.&lt;/li>
&lt;li>C shims for the &lt;code>dawn_native&lt;/code> C++ API and utility APIs, which are required in order to bind Dawn to an actual GLFW window.&lt;/li>
&lt;/ul>
&lt;p>There are a few weeks of work to do before this can be merged and will be usable by others, please stay tuned for that.&lt;/p>
&lt;p>After that will be development of idiomatic Zig bindings to the &lt;a href="https://github.com/webgpu-native/webgpu-headers">WebGPU C API&lt;/a> which is shared between implementations such as Dawn and the Rust&amp;rsquo;s &lt;a href="https://github.com/gfx-rs/wgpu-native">gfx-rs/wgpu-native&lt;/a> implementation (we could theoretically switch between them at startup in the future, but we&amp;rsquo;ll probably stick with Dawn as it does not require a separate Rust toolchain and it would prevent out-of-the-box cross compilation.)&lt;/p>
&lt;h2 id="when-will-there-be-games-examples-etc">When will there be games, examples, etc.?&lt;/h2>
&lt;p>It&amp;rsquo;ll be a while because I am focusing purely on the groundwork first. It&amp;rsquo;s unlikely you&amp;rsquo;ll see anything with &lt;em>real demo value&lt;/em> before later next year.&lt;/p>
&lt;p>I&amp;rsquo;m sure that will be disheartening to hear - and may make you to think there&amp;rsquo;s nothing of substance here. I totally understand that view, but I hope you&amp;rsquo;ll stay tuned because I&amp;rsquo;m in this for the long haul and it&amp;rsquo;s not my first rodeo (I previously spent 4 years writing &lt;a href="https://azul3d.org">a game engine in Go&lt;/a>, and have worked &lt;a href="https://sourcegraph.com">at a devtools startup for 7 years&lt;/a>, with my biggest lesson from of those experiences being the importance of demos and examples.&lt;/p>
&lt;h2 id="follow-along">Follow along&lt;/h2>
&lt;p>Major developments will be posted here, as well as on Twitter &lt;a href="https://twitter.com/machengine">@machengine&lt;/a>.&lt;/p>
&lt;p>You can also follow the project at &lt;a href="https://github.com/hexops/mach">github.com/hexops/mach&lt;/a>.&lt;/p>
&lt;p>If you like what I&amp;rsquo;m doing, you can &lt;a href="https://github.com/sponsors/slimsag">sponsor me on GitHub&lt;/a>.&lt;/p>
&lt;p>Thanks for reading!&lt;/p></description></item></channel></rss>