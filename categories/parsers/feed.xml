<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>parsers on Hexops' devlog</title><link>https://devlog.hexops.com/categories/parsers/</link><description>Recent content in parsers on Hexops' devlog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 10 Mar 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://devlog.hexops.com/categories/parsers/feed.xml" rel="self" type="application/rss+xml"/><item><title>Zig, Parser Combinators - and Why They're Awesome</title><link>https://devlog.hexops.com/2021/zig-parser-combinators-and-why-theyre-awesome/</link><pubDate>Wed, 10 Mar 2021 00:00:00 +0000</pubDate><guid>https://devlog.hexops.com/2021/zig-parser-combinators-and-why-theyre-awesome/</guid><description>&lt;p>In this article we will be exploring what &lt;a href="https://en.wikipedia.org/wiki/Parser_combinator">parser combinators&lt;/a> are, what &lt;em>runtime parser generation&lt;/em> is - why they&amp;rsquo;re useful, and then walking through a &lt;a href="https://ziglang.org">Zig&lt;/a> implementation of them.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="#what-are-parser-combinators">What are parser combinators?&lt;/a>&lt;/li>
&lt;li>&lt;a href="#why-are-parser-combinators-useful">Why are parser combinators useful?&lt;/a>&lt;/li>
&lt;li>&lt;a href="#going-deeper-runtime-parser-generation">Going deeper: &lt;em>runtime parser generation&lt;/em>&lt;/a>&lt;/li>
&lt;li>&lt;a href="#a-note-about-traditional-regex-engines">A note about traditional regex engines&lt;/a>&lt;/li>
&lt;li>&lt;a href="#implementing-the-parser-interface">Implementing the Parser interface&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#compile-time-vs-run-time">Compile-time vs. run-time&lt;/a>&lt;/li>
&lt;li>&lt;a href="#the-parser-interface">The parser interface&lt;/a>&lt;/li>
&lt;li>&lt;a href="#zig-generics-are-provided-via-type-parameters">Zig generics are provided via type parameters&lt;/a>&lt;/li>
&lt;li>&lt;a href="#zig-runtime-interfaces">Zig runtime interfaces&lt;/a>&lt;/li>
&lt;li>&lt;a href="#type-parameters">Type parameters&lt;/a>&lt;/li>
&lt;li>&lt;a href="#errors-the-parser-interface-can-produce">Errors the Parser interface can produce&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#our-first-parser">Our first Parser&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#what-actually-is-a-reader">What actually is a &amp;ldquo;Reader&amp;rdquo;?&lt;/a>&lt;/li>
&lt;li>&lt;a href="#a-parser-that-parses-a-literal-string">A Parser that parses a literal string&lt;/a>&lt;/li>
&lt;li>&lt;a href="#passing-parameters-to-a-parser-implementation">Passing parameters to a parser implementation&lt;/a>&lt;/li>
&lt;li>&lt;a href="#understanding-zigs-wildconfusing-fieldparentptr">Understanding Zig&amp;rsquo;s wild/confusing &lt;code>@fieldParentPtr&lt;/code>&lt;/a>&lt;/li>
&lt;li>&lt;a href="#implementing-the-rest-of-parse">Implementing the rest of &lt;code>parse&lt;/code>&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#our-first-parser-combinator">Our first &lt;em>parser combinator&lt;/em>&lt;/a>&lt;/li>
&lt;li>&lt;a href="#using-our-oneof-parser-combinator">Using our OneOf parser combinator&lt;/a>&lt;/li>
&lt;li>&lt;a href="#runtime-parser-generation">Runtime parser generation&lt;/a>&lt;/li>
&lt;li>&lt;a href="#closing-thoughts">Closing thoughts&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="what-are-parser-combinators">What are parser combinators?&lt;/h2>
&lt;p>A parser parses some text to produce a result:&lt;/p>
&lt;img class="color-auto" src="https://user-images.githubusercontent.com/3173176/110372092-1c234080-800b-11eb-8095-654c3c81354d.png">
&lt;p>A &lt;a href="https://en.wikipedia.org/wiki/Parser_combinator">parser combinator&lt;/a> is a &lt;a href="https://en.wikipedia.org/wiki/Higher-order_function">higher-order function&lt;/a> which &lt;em>takes parsers as input&lt;/em> and &lt;em>produces a new parser&lt;/em> as output:&lt;/p>
&lt;img class="color-auto" src="https://user-images.githubusercontent.com/3173176/110372575-b4b9c080-800b-11eb-9ef8-58f3ee0e1f1d.png">
&lt;h2 id="why-are-parser-combinators-useful">Why are parser combinators useful?&lt;/h2>
&lt;p>Let&amp;rsquo;s say we want to parse the syntax which describes a regular expression: &lt;code>a[bc].*abc&lt;/code>&lt;/p>
&lt;p>We can define some &lt;em>parsers&lt;/em> to help us parse this syntax (e.g. into tokens or AST nodes):&lt;/p>
&lt;img class="color-auto" src="https://user-images.githubusercontent.com/3173176/110375065-b1740400-800e-11eb-987e-b5a7c5a3381b.png">
&lt;p>Suppose that for &lt;code>a[bc].*abc&lt;/code>:&lt;/p>
&lt;ul>
&lt;li>&lt;code>RegexLiteralParser&lt;/code> can parse &lt;code>a&lt;/code>, &lt;code>b&lt;/code>, and &lt;code>c&lt;/code>, but not &lt;code>abc&lt;/code> (the string.)&lt;/li>
&lt;li>&lt;code>RegexRangeOpenParser&lt;/code> can parse &lt;code>[&lt;/code>.&lt;/li>
&lt;li>&lt;code>RegexRangeCloseParser&lt;/code> can parse &lt;code>]&lt;/code>&lt;/li>
&lt;li>&lt;code>RegexAnyParser&lt;/code> can parse the &lt;code>.&lt;/code> &amp;ldquo;any character&amp;rdquo; syntax.&lt;/li>
&lt;li>&lt;code>RegexRepetitionParser&lt;/code> can parse the &lt;code>*&lt;/code> repetition operator.&lt;/li>
&lt;/ul>
&lt;p>Now that we have these &lt;em>parsers&lt;/em>, we can define &lt;em>parser combinators&lt;/em> to help us parse the full regular expression. First, we need something to parse a string &lt;code>abc&lt;/code> which we can define as:&lt;/p>
&lt;img class="color-auto" src="https://user-images.githubusercontent.com/3173176/110413375-fa49ae00-804a-11eb-8311-64e737513000.png">
&lt;p>What is &lt;code>OneOrMore&lt;/code>, though? That&amp;rsquo;s our first parser combinator!&lt;/p>
&lt;p>It takes a single parser as input (in this case, &lt;code>RegexLiteralParser&lt;/code>) and uses it to parse the input one or more times. If it succeeded once, the parser combinator succeeded. Otherwise, it failed to parse anything.&lt;/p>
&lt;p>Now if we want to parse the &lt;code>[bc]&lt;/code> part of our regex, let&amp;rsquo;s say it can only contain a literal like &lt;code>bc&lt;/code> (of course, real regex allows far more than this) we can e.g. reuse our new &lt;code>RegexStringLiteralParser&lt;/code>:&lt;/p>
&lt;img class="color-auto" src="https://user-images.githubusercontent.com/3173176/110413643-780db980-804b-11eb-8fe5-8ca97b2e96ca.png">
&lt;p>In this case, &lt;code>Sequence&lt;/code> is a parser combinator which takes multiple parsers and tries to parse them one-after-the-other in order, requiring all to succeed or failing otherwise.&lt;/p>
&lt;p>Building upon this basic idea, we can use parser combinators to build a full regex syntax parser:&lt;/p>
&lt;img class="color-auto" src="https://user-images.githubusercontent.com/3173176/110414508-2ebe6980-804d-11eb-9422-0888208fac19.png">
&lt;h2 id="going-deeper-_runtime-parser-generation_">Going deeper: &lt;em>runtime parser generation&lt;/em>&lt;/h2>
&lt;p>From before, our &lt;em>parser combinator&lt;/em> &lt;code>RegexSyntaxParser&lt;/code> is built out of multiple parsers (&lt;code>Regex...Parser&lt;/code>) and ultimately produces an AST describing the syntax for a given regex.&lt;/p>
&lt;p>We can use the same combinatorial principle here to introduce a new &lt;em>parser generator&lt;/em> called &lt;code>RegexParser&lt;/code> which uses &lt;code>RegexSyntaxParser&lt;/code> to create a &lt;em>brand new parser at runtime&lt;/em> that is capable of parsing the actual semantics the regex describes - forming a full regex engine:&lt;/p>
&lt;img class="color-auto" src="https://user-images.githubusercontent.com/3173176/110528627-94eecf00-80d5-11eb-8fb6-f6bb051d9394.png">
&lt;h2 id="a-note-about-traditional-regex-engines">A note about traditional regex engines&lt;/h2>
&lt;p>&lt;small>&lt;em>Revised Mar 10, 2021&lt;/em> to clarify a misunderstanding I had about about the difference between DFA and NFA regex engines. Thanks &lt;a href="https://news.ycombinator.com/item?id=26419048">@burntsushi&lt;/a> for helping me to learn!&lt;/small>&lt;/p>
&lt;p>Production grade regex engines are either &lt;em>finite automata based&lt;/em> or &lt;em>backtracking based&lt;/em>, and are described in great detail in &lt;a href="https://swtch.com/~rsc/regexp/regexp1.html">Russ Cox&amp;rsquo;s article here&lt;/a> and &lt;a href="https://swtch.com/~rsc/regexp/regexp2.html">his second article here&lt;/a> covering the virtual-machine approach commonly used in regex engines.&lt;/p>
&lt;p>It&amp;rsquo;s worth noting that combinatorial parsing and generating parsers at runtime is very much an &lt;em>uncommon&lt;/em> method of implementing a regular expression engine. This is &lt;em>somewhat&lt;/em> close to what &lt;a href="https://comby.dev">Comby&lt;/a> does in practice, although we use a runtime parser generator instead of parser parser combinators.&lt;/p>
&lt;p>One could argue this makes what we&amp;rsquo;re parsing not strictly &lt;em>regular expressions&lt;/em>, although as Larry Wall (author of the Perl programming language) &lt;a href="https://raku.org/archive/doc/design/apo/A05.html">writes&lt;/a>, neither are the modern &amp;ldquo;regexp&amp;rdquo; pattern matchers you are likely used to:&lt;/p>
&lt;blockquote>
&lt;p>&amp;ldquo;Regular expressions&amp;rdquo; [â€¦] are only marginally related to real regular expressions. Nevertheless, the term has grown with the capabilities of our pattern matching engines, so I&amp;rsquo;m not going to try to fight linguistic necessity here. I will, however, generally call them &amp;ldquo;regexes&amp;rdquo; (or &amp;ldquo;regexen&amp;rdquo;, when I&amp;rsquo;m in an Anglo-Saxon mood).&lt;/p>
&lt;/blockquote>
&lt;h2 id="implementing-the-parser-interface">Implementing the Parser interface&lt;/h2>
&lt;p>Parser combinators &lt;em>tend&lt;/em> to be written in higher-level languages with much fancier type-systems such as Haskell and OCaml, which lend themselves well to higher-order functions like parser combinators.&lt;/p>
&lt;p>We&amp;rsquo;ll be implementing this in &lt;a href="https://ziglang.org">Zig&lt;/a>, which is a new low-level language aiming to be a better C.&lt;/p>
&lt;h3 id="compile-time-vs-run-time">Compile-time vs. run-time&lt;/h3>
&lt;p>Zig has very cool &lt;a href="https://ziglang.org/documentation/master/#comptime">compile-time code execution semantics&lt;/a> which help provide its generics. We&amp;rsquo;ll be exploring these a bit, but since we want to ultimately &lt;em>build parser generators at runtime&lt;/em> (in order to execute a regexp) what we&amp;rsquo;ll be looking at is mostly &lt;em>runtime parser interfaces&lt;/em> rather than &lt;em>compile-time parser interfaces&lt;/em> (which are very much possible!)&lt;/p>
&lt;p>Since we&amp;rsquo;ll be dealing with heap allocations, our parser will not be able to run at comptime for now. Once &lt;a href="https://github.com/ziglang/zig/issues/1291">Zig gets comptime heap allocations&lt;/a> this should be possible and opens up interesting new opportunities.&lt;/p>
&lt;h3 id="the-parser-interface">The parser interface&lt;/h3>
&lt;p>We need an interface in Zig which describes a &lt;em>parser&lt;/em> as we previously mentioned:&lt;/p>
&lt;img class="color-auto" src="https://user-images.githubusercontent.com/3173176/110372092-1c234080-800b-11eb-8095-654c3c81354d.png">
&lt;p>Here it is - there&amp;rsquo;s a lot to unpack here so we&amp;rsquo;ll walk through it step-by-step:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="kr">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Parser&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kr">comptime&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Value&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">type&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">comptime&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Reader&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">type&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">type&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">const&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Self&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">@This&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">_parse&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">self&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">Self&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">allocator&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">Allocator&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">src&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">Reader&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">callconv&lt;/span>&lt;span class="p">(.&lt;/span>&lt;span class="n">Inline&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Error&lt;/span>&lt;span class="o">!?&lt;/span>&lt;span class="n">Value&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">parse&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">self&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">Self&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">allocator&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">Allocator&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">src&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">Reader&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">callconv&lt;/span>&lt;span class="p">(.&lt;/span>&lt;span class="n">Inline&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Error&lt;/span>&lt;span class="o">!?&lt;/span>&lt;span class="n">Value&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">self&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">_parse&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">self&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">allocator&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">src&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">};&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="zig-generics-are-provided-via-type-parameters">Zig generics are provided via type parameters&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="kr">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Parser&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kr">comptime&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Value&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">type&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">comptime&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Reader&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">type&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">type&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">...&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">};&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This is a Zig function which takes two arbitrary &lt;code>type&lt;/code> arguments at &lt;code>comptime&lt;/code>, named &lt;code>Value&lt;/code> and &lt;code>Reader&lt;/code>. Uppercase is used to denote the name of a type in Zig. Thes are:&lt;/p>
&lt;ul>
&lt;li>&lt;code>Value&lt;/code> will be the type of the actual value that the parser will produce (e.g. a string of matched text, or an AST note.)&lt;/li>
&lt;li>&lt;code>Reader&lt;/code> will be the type of the actual source of the raw text to parse (we&amp;rsquo;ll cover this more later.)&lt;/li>
&lt;/ul>
&lt;p>The function itself &lt;em>returns a new type&lt;/em>.&lt;/p>
&lt;p>What we&amp;rsquo;re seeing here is the key way in which &lt;a href="https://ziglang.org/documentation/master/#Generic-Data-Structures">Zig approaches generic data structures&lt;/a>: you merely pass around types as parameters - as if they were values - and you write functions which take types as parameters and return types as values. Some examples of valid calls to this function are:&lt;/p>
&lt;ul>
&lt;li>&lt;code>Parser(u8, []u8)&lt;/code> where &lt;code>u8&lt;/code> is an unsigned 8-bit integer and &lt;code>[]u8&lt;/code> is a slice of unsigned 8-bit integers.&lt;/li>
&lt;li>&lt;code>Parser([]const u8, @TypeOf(reader))&lt;/code> where &lt;code>[]const u8&lt;/code> is describing a slice of UTF-8 text (a string) and &lt;code>reader&lt;/code> is some reader type, such as &lt;code>std.io.fixedBufferStream(&amp;quot;foobar&amp;quot;)&lt;/code>.&lt;/li>
&lt;/ul>
&lt;h3 id="zig-runtime-interfaces">Zig runtime interfaces&lt;/h3>
&lt;p>Now, since we&amp;rsquo;re trying to define an interface whose actual implementation can be swapped out &lt;em>at runtime&lt;/em> - what we need is pretty simple:&lt;/p>
&lt;ul>
&lt;li>A &lt;code>struct&lt;/code> type which has the methods we want every implementation to provide.&lt;/li>
&lt;li>Those methods to &lt;em>call function pointers&lt;/em> which are defined as &lt;em>fields&lt;/em> of our struct.&lt;/li>
&lt;/ul>
&lt;p>Basically, if someone wants to implement our interface they just need to create a new instance of &lt;code>Parser&lt;/code> and populate the fields (callbacks) so their implementation is called when the interface is used.&lt;/p>
&lt;p>This is the same pattern used by the Zig &lt;a href="https://sourcegraph.com/github.com/ziglang/zig/-/blob/lib/std/mem/Allocator.zig">&lt;code>std.mem.Allocator&lt;/code> interface&lt;/a>.&lt;/p>
&lt;p>In our case here, the returned struct has a method that consumers of the interface would invoke called &lt;code>parse&lt;/code> - and the function pointer field that implementors will set to get a callback is the &lt;code>_parse&lt;/code> field:&lt;/p>
&lt;img class="color-auto" src="https://user-images.githubusercontent.com/3173176/110578739-ad390b00-8122-11eb-816c-09e1e281db9d.png">
&lt;h3 id="type-parameters">Type parameters&lt;/h3>
&lt;p>Let&amp;rsquo;s look at some of the data types going around here:&lt;/p>
&lt;img class="color-auto" src="https://user-images.githubusercontent.com/3173176/110578578-60553480-8122-11eb-897b-e52e2d45eede.png">
&lt;p>A few other notes:&lt;/p>
&lt;ul>
&lt;li>&lt;code>Error!?Value&lt;/code> is just describing the function can return an &lt;code>Error&lt;/code> OR no value OR a &lt;code>Value&lt;/code> type. See Zig&amp;rsquo;s &lt;a href="https://ziglang.org/documentation/master/#Error-Union-Type">error union types&lt;/a> and &lt;a href="https://ziglang.org/documentation/master/#Optionals">optional types&lt;/a>.&lt;/li>
&lt;li>&lt;code>callconv(.Inline)&lt;/code> is just telling the compiler to inline the function call - since our function isn&amp;rsquo;t doing a ton.&lt;/li>
&lt;/ul>
&lt;h3 id="errors-the-parser-interface-can-produce">Errors the Parser interface can produce&lt;/h3>
&lt;p>Our error type might start out looking something like this:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="kr">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">const&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Error&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">error&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">EndOfStream&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">||&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">mem&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Allocator&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Error&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>error{...}&lt;/code> describes &lt;a href="https://ziglang.org/documentation/master/#Error-Set-Type">a set of potential errors&lt;/a> and &lt;code>|| std.mem.Allocator.Error&lt;/code> merely says to &lt;em>merge&lt;/em> the allocator type&amp;rsquo;s error set with ours - so our potential set of errors includes &lt;em>ours and theirs&lt;/em>.&lt;/p>
&lt;p>As we start performing different operations within parsers, it will become more complex to describe more potential sources of errors:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="kr">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">const&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Error&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">error&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">EndOfStream&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Utf8InvalidStartByte&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">||&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">fs&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">File&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ReadError&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">||&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">fs&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">File&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">SeekError&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">||&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">mem&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Allocator&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Error&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Zig can often &lt;a href="https://ziglang.org/documentation/master/#Inferred-Error-Sets">infer error sets&lt;/a> but only in some contexts today.&lt;/p>
&lt;h2 id="our-first-parser">Our first Parser&lt;/h2>
&lt;p>All we need to do in order to implement a &lt;code>Parser&lt;/code> is provide the &lt;code>_parse&lt;/code> method, and define its return &lt;code>Value&lt;/code> type and &lt;code>Reader&lt;/code> input type:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="kr">const&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">parser&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Parser&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">@TypeOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">reader&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">.{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">_parse&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">myParse&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">};&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In the above, the type &lt;code>T&lt;/code> in &lt;code>const parser: T&lt;/code> is denoting the type of the constant named &lt;code>parser&lt;/code> - in this case it&amp;rsquo;ll be the type returned by &lt;code>Parser([]u8, @TypeOf(reader))&lt;/code>. And this:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="n">something&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">.{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">_parse&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">myParse&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Is the Zig syntax for populating a struct. We&amp;rsquo;re setting the &lt;code>_parse&lt;/code> field to &lt;code>myParse&lt;/code>. Zig can infer the type of the struct if you write a &lt;code>.{}&lt;/code> instead of &lt;code>T{}&lt;/code> - which avoids the need for us to repeat the call to the &lt;code>Parser()&lt;/code> function which is verbose.&lt;/p>
&lt;h3 id="what-actually-is-a-reader">What actually is a &amp;ldquo;Reader&amp;rdquo;?&lt;/h3>
&lt;p>Up to this point, we&amp;rsquo;ve just talked about &lt;code>Reader&lt;/code> as being &lt;em>any type&lt;/em>.&lt;/p>
&lt;p>Similar to our &lt;code>Parser&lt;/code> interface, the Zig standard library &lt;a href="https://sourcegraph.com/github.com/ziglang/zig@f2b96782ecdc9e2f8740eb7d294203b2a585ea52/-/blob/lib/std/io/reader.zig#L13-20">provides a &lt;code>std.io.Reader&lt;/code> interface&lt;/a> and there are &lt;a href="https://sourcegraph.com/search?q=repo:%5Egithub%5C.com/ziglang/zig%24+file:%5Elib/std/+fn+reader%28&amp;amp;patternType=literal">many implementors of it&lt;/a> including:&lt;/p>
&lt;ul>
&lt;li>&lt;code>std.fs.File&lt;/code>&lt;/li>
&lt;li>&lt;code>std.io.fixedBufferStream(&amp;quot;foobar&amp;quot;)&lt;/code>&lt;/li>
&lt;li>&lt;code>std.net.Stream&lt;/code> (network sockets)&lt;/li>
&lt;/ul>
&lt;p>However, in contrast to our &lt;code>Parser&lt;/code> type which invokes &lt;em>function pointers&lt;/em> at runtime, the &lt;code>std.io.Reader&lt;/code> interface is a &lt;em>compile time type&lt;/em> - meaning calls to the underlying implementation do not involve a pointer dereference.&lt;/p>
&lt;p>Today, Zig is in early stages (version 0.7) and does not have anything like an interface or trait type (although &lt;a href="https://github.com/ziglang/zig/issues/1268">it seems likely this will be improved in the future&lt;/a>.)&lt;/p>
&lt;p>This means that, for now, we cannot simply define our function as accepting &lt;em>only&lt;/em> an &lt;code>std.io.Reader&lt;/code> interface - instead we must declare that we accept &lt;em>any type&lt;/em> which we&amp;rsquo;ll call &lt;code>Reader&lt;/code>, write our code &lt;em>as if it is an &lt;code>std.io.Reader&lt;/code>&lt;/em> - and the compiler will just barf if anybody passes something in that &lt;em>isn&amp;rsquo;t&lt;/em> an &lt;code>std.io.Reader&lt;/code>. This can sometimes lead to confusing compiler error messages (&amp;ldquo;there&amp;rsquo;s an error in the standard library code? Ah, no, I just needed to pass a &lt;code>.reader()&lt;/code>!&amp;quot;).&lt;/p>
&lt;h3 id="a-parser-that-parses-a-literal-string">A Parser that parses a literal string&lt;/h3>
&lt;p>If we want a &lt;code>Parser&lt;/code> interface implementation that parses a specific string literal, one way to do that is to also make that a generic function which accepts &lt;em>any&lt;/em> reader type (so we&amp;rsquo;re not restricted to e.g. just file inputs):&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="kr">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Literal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kr">comptime&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Reader&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">type&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">type&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// TODO
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">};&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This is pretty good - but we need some way to have the type we return &lt;em>implement&lt;/em> the &lt;code>Parser&lt;/code> interface we defined. The way to do this is by defining a field in our struct:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="kr">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Literal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kr">comptime&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Reader&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">type&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">type&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">parser&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Parser&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Reader&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">.{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">_parse&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">parse&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">},&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">};&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now a consumer can write the following to get a literal string parser:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="kr">const&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">parser&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Literal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">@TypeOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">reader&lt;/span>&lt;span class="p">)).&lt;/span>&lt;span class="n">parser&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="passing-parameters-to-a-parser-implementation">Passing parameters to a parser implementation&lt;/h3>
&lt;p>If we want our &lt;code>Literal&lt;/code> parser to accept a parameter &amp;ndash; the literal string to look for &amp;ndash; we need to give it a parameter.&lt;/p>
&lt;p>In the case of merely passing it a string, we &lt;em>could&lt;/em> adjust the signature so that this is possible:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="kr">const&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">parser&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Literal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;some string&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">@TypeOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">reader&lt;/span>&lt;span class="p">)).&lt;/span>&lt;span class="n">parser&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>However, we&amp;rsquo;ll define ours using an &lt;code>init&lt;/code> method which is more common in Zig data structures:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="kr">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Literal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kr">comptime&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Reader&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">type&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">type&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">parser&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Parser&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Reader&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">.{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">_parse&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">parse&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">},&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">want&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[]&lt;/span>&lt;span class="kr">const&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">const&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Self&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">@This&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// The `want` string must stay alive for as long as the parser will be used.
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">want&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[]&lt;/span>&lt;span class="kr">const&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Self&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Self&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">want&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">want&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">};&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">};&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In this case, &lt;code>want&lt;/code> is the string literal we want to match - and &lt;code>[]const u8&lt;/code> is Zig&amp;rsquo;s string type. It describes a slice of immutable (non-modifiable) encoded UTF-8 bytes.&lt;/p>
&lt;p>Unlike C, &lt;code>[]const u8&lt;/code> being a slice means it is &lt;em>a pointer to the string in memory and its length&lt;/em> - so we don&amp;rsquo;t have to pass around the length parameter separately or use a null-terminated string. In Zig, there are two ways to represent a string:&lt;/p>
&lt;ul>
&lt;li>&lt;code>[]const u8&lt;/code> (unmodifiable string, most common)&lt;/li>
&lt;li>&lt;code>[]u8&lt;/code> (modifiable string)&lt;/li>
&lt;/ul>
&lt;h3 id="understanding-zigs-wildconfusing-fieldparentptr">Understanding Zig&amp;rsquo;s wild/confusing &lt;code>@fieldParentPtr&lt;/code>&lt;/h3>
&lt;p>We&amp;rsquo;re finally ready to actually have our &lt;code>Literal&lt;/code> parser &lt;em>parse&lt;/em> something! We just need to implement our &lt;code>parse&lt;/code> method:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="kr">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Literal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kr">comptime&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Reader&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">type&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">type&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">parser&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Parser&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Reader&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">.{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">_parse&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">parse&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">},&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">want&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[]&lt;/span>&lt;span class="kr">const&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">...&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">const&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Self&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">@This&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">parse&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">parser&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">Parser&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Reader&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">allocator&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">Allocator&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">src&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">Reader&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">callconv&lt;/span>&lt;span class="p">(.&lt;/span>&lt;span class="n">Inline&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Error&lt;/span>&lt;span class="o">!?&lt;/span>&lt;span class="p">[]&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">const&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">self&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">@fieldParentPtr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Self&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;parser&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">parser&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">...&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">};&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>But wait a minute! In order for the &lt;code>._parse = parse,&lt;/code> assignment to work the first argument to &lt;code>parse&lt;/code> needs to be the &lt;code>self&lt;/code> parameter for a &lt;code>Parser([]u8, Reader)&lt;/code> - so how does &lt;em>our&lt;/em> &lt;code>parse&lt;/code> implementation method get to access the &lt;code>want&lt;/code> field of our struct?&lt;/p>
&lt;p>This is where some Zig magic comes in: on obscure builtin function we can use inside of our &lt;code>parse&lt;/code> method:&lt;/p>
&lt;pre>&lt;code>const self = @fieldParentPtr(Self, &amp;quot;parser&amp;quot;, parser);
&lt;/code>&lt;/pre>&lt;p>To understand this, first let&amp;rsquo;s get a look at what these parameters are referring to:&lt;/p>
&lt;img class="color-auto" src="https://user-images.githubusercontent.com/3173176/110593977-7b7f6e80-8139-11eb-8ecc-41dff5766ec2.png">
&lt;p>We can see from the Zig documentation that this function operates as follows:&lt;/p>
&lt;blockquote>
&lt;p>Given a pointer to a field, returns the base pointer of a struct.&lt;/p>
&lt;/blockquote>
&lt;p>So in our case:&lt;/p>
&lt;ul>
&lt;li>&lt;code>Self&lt;/code> is the &amp;ldquo;parent struct&amp;rdquo; we&amp;rsquo;re trying to acquire a reference to (our type)&lt;/li>
&lt;li>&lt;code>&amp;quot;parser&amp;quot;&lt;/code> is the name of our struct&amp;rsquo;s field.&lt;/li>
&lt;li>&lt;code>parser&lt;/code> is the &lt;em>pointer to our &lt;code>parser&lt;/code> struct field&lt;/em>.&lt;/li>
&lt;/ul>
&lt;p>Hopefully you can start to see the link here: &lt;code>parser&lt;/code> is a pointer to &lt;em>our struct field&lt;/em>, so Zig has a little helper &lt;code>@fieldParentPtr&lt;/code> which can rely on that fact to give us &lt;em>our struct&lt;/em> given a pointer to &lt;em>our struct field&lt;/em>.&lt;/p>
&lt;h3 id="implementing-the-rest-of-parse">Implementing the rest of &lt;code>parse&lt;/code>&lt;/h3>
&lt;p>Our full &lt;code>parse&lt;/code> method will look like this:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="c1">// If a value is returned, it is up to the caller to free it.
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">fn&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">parse&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">parser&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">Parser&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Reader&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">allocator&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">Allocator&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">src&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">Reader&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">callconv&lt;/span>&lt;span class="p">(.&lt;/span>&lt;span class="n">Inline&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Error&lt;/span>&lt;span class="o">!?&lt;/span>&lt;span class="p">[]&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">const&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">self&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">@fieldParentPtr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Self&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;parser&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">parser&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">const&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">try&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">allocator&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">alloc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">self&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">want&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">len&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">errdefer&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">allocator&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">free&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">const&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">read&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">try&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">src&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">reader&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="n">readAll&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">read&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">self&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">want&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">len&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">or&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">mem&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">eql&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">self&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">want&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">try&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">src&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">seekableStream&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="n">seekBy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="nb">@intCast&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">i64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">read&lt;/span>&lt;span class="p">));&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">allocator&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">free&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// parsing failed
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>There are a few notable things here:&lt;/p>
&lt;ul>
&lt;li>We&amp;rsquo;re trying to return a string from our &lt;code>parse&lt;/code> function, i.e. the value it emits is a string (instead of an AST node).&lt;/li>
&lt;li>The &lt;code>want&lt;/code> string we &lt;em>got&lt;/em> inside of our &lt;code>init&lt;/code> method is agreed to only be valid while &lt;code>parse&lt;/code> will still be called. We&amp;rsquo;ve decided to create a contract that all of our &lt;code>Parser&lt;/code> implementations will either not hold onto memory given by others - or if they do, only do so until &lt;code>parse&lt;/code> returns. Hence, we need to allocate a new string in our method.&lt;/li>
&lt;li>Normally we could rely solely on &lt;code>defer&lt;/code> (&amp;ldquo;run at end of function&amp;rdquo;) or &lt;code>errdefer&lt;/code> (&amp;ldquo;run if an error is returned&amp;rdquo;), but since we&amp;rsquo;ve chosen to reserve the &lt;em>none optional&lt;/em> &lt;code>null&lt;/code> as &amp;ldquo;we didn&amp;rsquo;t parse anything&amp;rdquo; we need to manually free if we &lt;code>return null;&lt;/code>. A &lt;code>nulldefer&lt;/code> and &lt;code>somedefer&lt;/code> could be nice, maybe?&lt;/li>
&lt;/ul>
&lt;p>Putting it all together, you&amp;rsquo;ll get something like this: &lt;a href="https://gist.github.com/emidoots/8f098a13177b4bc008a7741505819f90">GitHub gist&lt;/a>.&lt;/p>
&lt;h2 id="our-first-_parser-combinator_">Our first &lt;em>parser combinator&lt;/em>&lt;/h2>
&lt;p>To demonstrate how a &lt;em>parser combinator&lt;/em> would be implemented, we&amp;rsquo;ll try implementing the &lt;code>OneOf&lt;/code> operator. It will take any number of &lt;em>parsers&lt;/em> as input and run them consecutively until one succeeds or none do.&lt;/p>
&lt;p>Let&amp;rsquo;s first start by writing out the basic structure of our function:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="kr">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">OneOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kr">comptime&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Value&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">type&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">comptime&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Reader&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">type&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">type&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">parser&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Parser&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Value&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Reader&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">.{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">_parse&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">parse&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">},&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">...&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">};&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>You&amp;rsquo;ll notice here that in contrast to our &lt;code>Literal&lt;/code> &lt;em>parser&lt;/em> function from earlier, this function takes a second &lt;code>comptime Value: type&lt;/code> parameter. This is because we want it to work with any existing &lt;code>Parser&lt;/code> implementation, regardless of what type of value it produces.&lt;/p>
&lt;p>We can start to fill in the type by adding our &lt;code>init&lt;/code> method:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="kr">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">OneOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kr">comptime&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Value&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">type&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">comptime&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Reader&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">type&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">type&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">parser&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Parser&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Value&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Reader&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">.{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">_parse&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">parse&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">},&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">parsers&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[]&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">Parser&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Value&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Reader&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">const&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Self&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">@This&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// `parsers` slice must stay alive for as long as the parser will be
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// used.
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">parsers&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[]&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">Parser&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Value&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Reader&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Self&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Self&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">parsers&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">parsers&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">};&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">};&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>As you can see here, we&amp;rsquo;re going to simply take in a list of pointers to parsers. They&amp;rsquo;ll all need to have the same return &lt;code>Value&lt;/code> as was specified in the call to &lt;code>OneOf&lt;/code>.&lt;/p>
&lt;p>One reason for this is that &lt;a href="https://github.com/ziglang/zig/issues/447">Zig does not support &lt;em>return type inference&lt;/em>&lt;/a>. You can have a function which takes &lt;code>anytype&lt;/code> as a parameter, but it cannot return an &lt;code>anytype&lt;/code>. This just means we need to have a generic function (in this case, &lt;code>OneOf&lt;/code>) which accepts a type parameter and then use that &lt;code>Value&lt;/code> type later. In a language like Haskell or OCaml, this would not be true.&lt;/p>
&lt;p>Finally, we can implement our &lt;code>parse&lt;/code> method:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="kr">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">OneOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kr">comptime&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Value&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">type&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">comptime&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Reader&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">type&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">type&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">...&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// Caller is responsible for freeing the value, if any.
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">parse&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">parser&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">Parser&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Value&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Reader&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">allocator&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">Allocator&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">src&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">Reader&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">callconv&lt;/span>&lt;span class="p">(.&lt;/span>&lt;span class="n">Inline&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Error&lt;/span>&lt;span class="o">!?&lt;/span>&lt;span class="n">Value&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">const&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">self&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">@fieldParentPtr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Self&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;parser&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">parser&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">self&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">parsers&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">one_of_parser&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kr">const&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">try&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">one_of_parser&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">parse&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">allocator&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">src&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">!=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">};&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>There are a few things to unpack here:&lt;/p>
&lt;ul>
&lt;li>&lt;code>try one_of_parser.parse(allocator, src);&lt;/code> indicates that if parsing using &lt;code>one_of_parser&lt;/code> returns an &lt;em>error&lt;/em> that our function should return immediately and not continue attempting to parse with other parsers.&lt;/li>
&lt;li>&lt;code>if (result != null) {&lt;/code> is how you check if an Optional type in Zig is &amp;ldquo;None&amp;rdquo;. I find this pretty interesting: it&amp;rsquo;s not &lt;code>null&lt;/code>, it&amp;rsquo;s actually an optional &amp;ldquo;none&amp;rdquo; type - but it is called &lt;code>null&lt;/code>. I&amp;rsquo;m not sure why, but can imagine this making the language friendlier to people unfamiliar with optional types.&lt;/li>
&lt;/ul>
&lt;h2 id="using-our-oneof-parser-combinator">Using our OneOf parser combinator&lt;/h2>
&lt;p>Now for the cool part: we get to put both our &lt;code>Literal&lt;/code> parser and &lt;code>OneOf&lt;/code> parser combinator to &lt;em>build a new parser&lt;/em>!&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="c1">// Define our parser.
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kr">var&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">one_of&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">OneOf&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">@TypeOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">reader&lt;/span>&lt;span class="p">)).&lt;/span>&lt;span class="n">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="p">.{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">Literal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">@TypeOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">reader&lt;/span>&lt;span class="p">)).&lt;/span>&lt;span class="n">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;dog&amp;#34;&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="n">parser&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">Literal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">@TypeOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">reader&lt;/span>&lt;span class="p">)).&lt;/span>&lt;span class="n">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;sheep&amp;#34;&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="n">parser&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">Literal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">@TypeOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">reader&lt;/span>&lt;span class="p">)).&lt;/span>&lt;span class="n">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;cat&amp;#34;&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="n">parser&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">});&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The above will parse one of &lt;code>&amp;quot;dog&amp;quot;&lt;/code>, &lt;code>&amp;quot;sheep&amp;quot;&lt;/code>, or &lt;code>&amp;quot;cat&amp;quot;&lt;/code> from the input reader.&lt;/p>
&lt;p>We&amp;rsquo;re passing &lt;code>@TypeOf(reader)&lt;/code> frequently above which makes the code a bit more cryptic than needed, and it would be possible to introduce a &lt;code>OneOfLiteral&lt;/code> helper which makes the above instead read:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="c1">// Define our parser.
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kr">var&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">one_of&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">OneOfLiteral&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">@TypeOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">reader&lt;/span>&lt;span class="p">)).&lt;/span>&lt;span class="n">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="p">.{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;dog&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;cat&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;sheep&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">});&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>One thing to unpack here is this syntax for passing an array to &lt;code>init&lt;/code>: &lt;code>&amp;amp;.{...}&lt;/code>:&lt;/p>
&lt;ul>
&lt;li>The function takes a parameter &lt;code>parsers: []*Parser(Value, Reader)&lt;/code>&lt;/li>
&lt;li>&lt;code>.{...}&lt;/code> would give us &lt;em>a fixed size array&lt;/em> &lt;code>[3]*Parser(Value, Reader)&lt;/code>&lt;/li>
&lt;li>&lt;code>&amp;amp;.{}&lt;/code> gives us a pointer to an array, i.e. &lt;em>a slice&lt;/em> &lt;code>[]*Parser(Value, Reader)&lt;/code>.&lt;/li>
&lt;/ul>
&lt;p>Since our list is known at compile time, we don&amp;rsquo;t have to allocate or free memory for the slice. If our list was dynamic, we would need to do so.&lt;/p>
&lt;p>Finally, we can actually use our parser above:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-zig" data-lang="zig">&lt;span class="kr">var&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">one_of&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">parser&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="kr">var&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">try&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">parse&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">allocator&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">reader&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">testing&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">expectEqualStrings&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;cat&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="o">?&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">allocator&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">free&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="runtime-parser-generation">Runtime parser generation&lt;/h2>
&lt;p>You might be wondering how we would go from the &lt;code>Literal&lt;/code> &lt;em>parser&lt;/em> and &lt;code>OneOf&lt;/code> &lt;em>parser combinator&lt;/em> to actually &lt;em>generating a parser at runtime that can parse the semantics defined in a regexp string&lt;/em>.&lt;/p>
&lt;p>Since our &lt;code>Parser&lt;/code> interface is a runtime interface (you can swap out the implementation at runtime) and since our parser combinator &lt;code>OneOf&lt;/code> operates using that interface (only the return value must be known at compile time, it could be a generic AST node) it means that we can easily dynamically create slices of &lt;code>[]*Parser(...)&lt;/code> at runtime based on the result of a parser combinator we have built - like our &amp;ldquo;dog, cat, sheep&amp;rdquo; parser from earlier.&lt;/p>
&lt;p>The challenge left for you as a reader is to:&lt;/p>
&lt;ul>
&lt;li>Write &lt;em>parsers&lt;/em> like our &lt;code>Literal&lt;/code> parser that can parse the components of our regexp &lt;code>a[bc].*abc&lt;/code>:
&lt;ul>
&lt;li>&lt;code>RegexLiteralParser&lt;/code> can parse &lt;code>a&lt;/code>, &lt;code>b&lt;/code>, and &lt;code>c&lt;/code>, but not &lt;code>abc&lt;/code> (the string.)&lt;/li>
&lt;li>&lt;code>RegexRangeOpenParser&lt;/code> can parse &lt;code>[&lt;/code>.&lt;/li>
&lt;li>&lt;code>RegexRangeCloseParser&lt;/code> can parse &lt;code>]&lt;/code>&lt;/li>
&lt;li>&lt;code>RegexAnyParser&lt;/code> can parse the &lt;code>.&lt;/code> &amp;ldquo;any character&amp;rdquo; syntax.&lt;/li>
&lt;li>&lt;code>RegexRepetitionParser&lt;/code> can parse the &lt;code>*&lt;/code> repetition operator.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Write a &lt;em>parser combinators&lt;/em> like our &lt;code>OneOf&lt;/code> parser, except have it parse a &lt;code>Sequence&lt;/code> of parsers.&lt;/li>
&lt;li>Use our &lt;code>Sequence&lt;/code> parser combinator and &lt;code>RegexLiteralParser&lt;/code> to build a &lt;code>RegexStringLiteralParser&lt;/code> - similar to how we built out &amp;ldquo;dog, cat, sheep&amp;rdquo; parser.&lt;/li>
&lt;li>Write a &lt;em>new kind of function&lt;/em> called a &lt;em>runtime parser generator&lt;/em> named &lt;code>RegexParser&lt;/code> which will be super familiar:
&lt;ul>
&lt;li>Take in a &lt;em>parser combinator&lt;/em> called &lt;code>RegexSyntaxParser&lt;/code> which can turn your regexp syntax into some intermediary like an AST.&lt;/li>
&lt;li>Have your function &lt;em>use parser combinators like OneOf, Sequence, etc.&lt;/em> to build a brand new parser at runtime based on that intermediary AST.&lt;/li>
&lt;li>Return that new parser which parses the actual semantics described by the input regexp!&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="closing-thoughts">Closing thoughts&lt;/h2>
&lt;p>I am sorry for not giving you a full (or even partial) regex engine :) I am still exploring this and it is a large undertaking, this blog post would be far too long if it was included.&lt;/p>
&lt;p>You can find a copy of the final code with &lt;em>parsers&lt;/em> and &lt;em>parser combinators&lt;/em> &lt;a href="https://gist.github.com/emidoots/db2dd2c49aa038e23b654120e70c9b00">here&lt;/a>. Just &lt;code>zig init-exe&lt;/code> and plop them into your &lt;code>src/&lt;/code> directory.&lt;/p>
&lt;p>You may also want to check out &lt;a href="https://github.com/Hejsil/mecha">Mecha&lt;/a>, a parser combinator library for Zig.&lt;/p>
&lt;p>If anything was unclear or confusing, I&amp;rsquo;m happy to help: shoot me an email &lt;a href="mailto:stephen@hexops.com">stephen@hexops.com&lt;/a> or leave a comment on Hacker News / Reddit and I&amp;rsquo;ll follow up.&lt;/p></description></item></channel></rss>