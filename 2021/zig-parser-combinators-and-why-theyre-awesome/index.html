<!doctype html><html><head><link rel=stylesheet href=https://devlog.hexops.com/assets/font/stylesheet.css><link rel=stylesheet href=https://devlog.hexops.com/main.959becff4f3640c2ba19521949a93832fa147f951930301c1c72e74e25823239.css><script async defer data-domain=hexops.com src=https://hexops.com/opendata.js></script><meta charset=utf-8><title>Zig, Parser Combinators - and Why They're Awesome | Hexops' devlog</title><link rel=canonical href=https://devlog.hexops.com/2021/zig-parser-combinators-and-why-theyre-awesome/><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><meta property="og:title" content="Zig, Parser Combinators - and Why They're Awesome"><meta property="og:description" content="In this article we will be exploring what parser combinators are, what runtime parser generation is - why they're useful, and then walking through a Zig implementation of them."><meta property="og:type" content="article"><meta property="og:url" content="https://devlog.hexops.com/2021/zig-parser-combinators-and-why-theyre-awesome/"><meta property="article:section" content="2021"><meta property="article:published_time" content="2021-03-10T00:00:00+00:00"><meta property="article:modified_time" content="2021-03-10T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Zig, Parser Combinators - and Why They're Awesome"><meta name=twitter:description content="In this article we will be exploring what parser combinators are, what runtime parser generation is - why they're useful, and then walking through a Zig implementation of them."></head><body><div class=navbar><div class=content><a href=/ class=logo><img src=https://raw.githubusercontent.com/hexops/media/234e15f265b19743c580a078b2d68660c92675d4/logo.svg>' devlog</a><div><a href=https://hexops.com/about class=item>About</a>
<a href=/archives class=item>Archives</a>
<a href=https://github.com/hexops class=item>GitHub</a></div></div></div><div id=content><main aria-role=main class=main-single><div class=single><header class=header><h1>Zig, Parser Combinators - and Why They're Awesome</h1><div class=metadata><time>March 10, 2021</time>
• <a class=category href=/categories/zig>zig</a>
• <a class=category href=/categories/regex>regex</a>
• <a class=category href=/categories/parsers>parsers</a></div></header><p>In this article we will be exploring what <a href=https://en.wikipedia.org/wiki/Parser_combinator>parser combinators</a> are, what <em>runtime parser generation</em> is - why they&rsquo;re useful, and then walking through a <a href=https://ziglang.org>Zig</a> implementation of them.</p><ul><li><a href=#what-are-parser-combinators>What are parser combinators?</a></li><li><a href=#why-are-parser-combinators-useful>Why are parser combinators useful?</a></li><li><a href=#going-deeper-runtime-parser-generation>Going deeper: <em>runtime parser generation</em></a></li><li><a href=#a-note-about-traditional-regex-engines>A note about traditional regex engines</a></li><li><a href=#implementing-the-parser-interface>Implementing the Parser interface</a><ul><li><a href=#compile-time-vs-run-time>Compile-time vs. run-time</a></li><li><a href=#the-parser-interface>The parser interface</a></li><li><a href=#zig-generics-are-provided-via-type-parameters>Zig generics are provided via type parameters</a></li><li><a href=#zig-runtime-interfaces>Zig runtime interfaces</a></li><li><a href=#type-parameters>Type parameters</a></li><li><a href=#errors-the-parser-interface-can-produce>Errors the Parser interface can produce</a></li></ul></li><li><a href=#our-first-parser>Our first Parser</a><ul><li><a href=#what-actually-is-a-reader>What actually is a &ldquo;Reader&rdquo;?</a></li><li><a href=#a-parser-that-parses-a-literal-string>A Parser that parses a literal string</a></li><li><a href=#passing-parameters-to-a-parser-implementation>Passing parameters to a parser implementation</a></li><li><a href=#understanding-zigs-wildconfusing-fieldparentptr>Understanding Zig&rsquo;s wild/confusing <code>@fieldParentPtr</code></a></li><li><a href=#implementing-the-rest-of-parse>Implementing the rest of <code>parse</code></a></li></ul></li><li><a href=#our-first-parser-combinator>Our first <em>parser combinator</em></a></li><li><a href=#using-our-oneof-parser-combinator>Using our OneOf parser combinator</a></li><li><a href=#runtime-parser-generation>Runtime parser generation</a></li><li><a href=#closing-thoughts>Closing thoughts</a></li></ul><h2 id=what-are-parser-combinators>What are parser combinators?</h2><p>A parser parses some text to produce a result:</p><img class=color-auto src=https://user-images.githubusercontent.com/3173176/110372092-1c234080-800b-11eb-8095-654c3c81354d.png><p>A <a href=https://en.wikipedia.org/wiki/Parser_combinator>parser combinator</a> is a <a href=https://en.wikipedia.org/wiki/Higher-order_function>higher-order function</a> which <em>takes parsers as input</em> and <em>produces a new parser</em> as output:</p><img class=color-auto src=https://user-images.githubusercontent.com/3173176/110372575-b4b9c080-800b-11eb-9ef8-58f3ee0e1f1d.png><h2 id=why-are-parser-combinators-useful>Why are parser combinators useful?</h2><p>Let&rsquo;s say we want to parse the syntax which describes a regular expression: <code>a[bc].*abc</code></p><p>We can define some <em>parsers</em> to help us parse this syntax (e.g. into tokens or AST nodes):</p><img class=color-auto src=https://user-images.githubusercontent.com/3173176/110375065-b1740400-800e-11eb-987e-b5a7c5a3381b.png><p>Suppose that for <code>a[bc].*abc</code>:</p><ul><li><code>RegexLiteralParser</code> can parse <code>a</code>, <code>b</code>, and <code>c</code>, but not <code>abc</code> (the string.)</li><li><code>RegexRangeOpenParser</code> can parse <code>[</code>.</li><li><code>RegexRangeCloseParser</code> can parse <code>]</code></li><li><code>RegexAnyParser</code> can parse the <code>.</code> &ldquo;any character&rdquo; syntax.</li><li><code>RegexRepetitionParser</code> can parse the <code>*</code> repetition operator.</li></ul><p>Now that we have these <em>parsers</em>, we can define <em>parser combinators</em> to help us parse the full regular expression. First, we need something to parse a string <code>abc</code> which we can define as:</p><p>&lt;img class=&ldquo;color-autoc=&ldquo;<a href=https://user-images.githubusercontent.com/3173176/110413375-fa49ae00-804a-11eb-8311-64e737513000.png%22%3E>https://user-images.githubusercontent.com/3173176/110413375-fa49ae00-804a-11eb-8311-64e737513000.png"></a></p><p>What is <code>OneOrMore</code>, though? That&rsquo;s our first parser combinator!</p><p>It takes a single parser as input (in this case, <code>RegexLiteralParser</code>) and uses it to parse the input one or more times. If it succeeded once, the parser combinator succeeded. Otherwise, it failed to parse anything.</p><p>Now if we want to parse the <code>[bc]</code> part of our regex, let&rsquo;s say it can only contain a literal like <code>bc</code> (of course, real regex allows far more than this) we can e.g. reuse our new <code>RegexStringLiteralParser</code>:</p><p>&lt;img class=&ldquo;color-autoc=&ldquo;<a href=https://user-images.githubusercontent.com/3173176/110413643-780db980-804b-11eb-8fe5-8ca97b2e96ca.png%22%3E>https://user-images.githubusercontent.com/3173176/110413643-780db980-804b-11eb-8fe5-8ca97b2e96ca.png"></a></p><p>In this case, <code>Sequence</code> is a parser combinator which takes multiple parsers and tries to parse them one-after-the-other in order, requiring all to succeed or failing otherwise.</p><p>Building upon this basic idea, we can use parser combinators to build a full regex syntax parser:</p><img class=color-auto src=https://user-images.githubusercontent.com/3173176/110414508-2ebe6980-804d-11eb-9422-0888208fac19.png><h2 id=going-deeper-_runtime-parser-generation_>Going deeper: <em>runtime parser generation</em></h2><p>From before, our <em>parser combinator</em> <code>RegexSyntaxParser</code> is built out of multiple parsers (<code>Regex...Parser</code>) and ultimately produces an AST describing the syntax for a given regex.</p><p>We can use the same combinatorial principle here to introduce a new <em>parser generator</em> called <code>RegexParser</code> which uses <code>RegexSyntaxParser</code> to create a <em>brand new parser at runtime</em> that is capable of parsing the actual semantics the regex describes - forming a full regex engine:</p><img class=color-auto src=https://user-images.githubusercontent.com/3173176/110528627-94eecf00-80d5-11eb-8fb6-f6bb051d9394.png><h2 id=a-note-about-traditional-regex-engines>A note about traditional regex engines</h2><p><small><em>Revised Mar 10, 2021</em> to clarify a misunderstanding I had about about the difference between DFA and NFA regex engines. Thanks <a href="https://news.ycombinator.com/item?id=26419048">@burntsushi</a> for helping me to learn!</small></p><p>Production grade regex engines are either <em>finite automata based</em> or <em>backtracking based</em>, and are described in great detail in <a href=https://swtch.com/~rsc/regexp/regexp1.html>Russ Cox&rsquo;s article here</a> and <a href=https://swtch.com/~rsc/regexp/regexp2.html>his second article here</a> covering the virtual-machine approach commonly used in regex engines.</p><p>It&rsquo;s worth noting that combinatorial parsing and generating parsers at runtime is very much an <em>uncommon</em> method of implementing a regular expression engine. This is <em>somewhat</em> close to what <a href=https://comby.dev>Comby</a> does in practice, although we use a runtime parser generator instead of parser parser combinators.</p><p>One could argue this makes what we&rsquo;re parsing not strictly <em>regular expressions</em>, although as Larry Wall (author of the Perl programming language) <a href=https://raku.org/archive/doc/design/apo/A05.html>writes</a>, neither are the modern &ldquo;regexp&rdquo; pattern matchers you are likely used to:</p><blockquote><p>&ldquo;Regular expressions&rdquo; […] are only marginally related to real regular expressions. Nevertheless, the term has grown with the capabilities of our pattern matching engines, so I&rsquo;m not going to try to fight linguistic necessity here. I will, however, generally call them &ldquo;regexes&rdquo; (or &ldquo;regexen&rdquo;, when I&rsquo;m in an Anglo-Saxon mood).</p></blockquote><h2 id=implementing-the-parser-interface>Implementing the Parser interface</h2><p>Parser combinators <em>tend</em> to be written in higher-level languages with much fancier type-systems such as Haskell and OCaml, which lend themselves well to higher-order functions like parser combinators.</p><p>We&rsquo;ll be implementing this in <a href=https://ziglang.org>Zig</a>, which is a new low-level language aiming to be a better C.</p><h3 id=compile-time-vs-run-time>Compile-time vs. run-time</h3><p>Zig has very cool <a href=https://ziglang.org/documentation/master/#comptime>compile-time code execution semantics</a> which help provide its generics. We&rsquo;ll be exploring these a bit, but since we want to ultimately <em>build parser generators at runtime</em> (in order to execute a regexp) what we&rsquo;ll be looking at is mostly <em>runtime parser interfaces</em> rather than <em>compile-time parser interfaces</em> (which are very much possible!)</p><p>Since we&rsquo;ll be dealing with heap allocations, our parser will not be able to run at comptime for now. Once <a href=https://github.com/ziglang/zig/issues/1291>Zig gets comptime heap allocations</a> this should be possible and opens up interesting new opportunities.</p><h3 id=the-parser-interface>The parser interface</h3><p>We need an interface in Zig which describes a <em>parser</em> as we previously mentioned:</p><img class=color-auto src=https://user-images.githubusercontent.com/3173176/110372092-1c234080-800b-11eb-8095-654c3c81354d.png><p>Here it is - there&rsquo;s a lot to unpack here so we&rsquo;ll walk through it step-by-step:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>pub</span><span class=w> </span><span class=k>fn</span><span class=w> </span><span class=n>Parser</span><span class=p>(</span><span class=kr>comptime</span><span class=w> </span><span class=n>Value</span><span class=o>:</span><span class=w> </span><span class=kt>type</span><span class=p>,</span><span class=w> </span><span class=kr>comptime</span><span class=w> </span><span class=n>Reader</span><span class=o>:</span><span class=w> </span><span class=kt>type</span><span class=p>)</span><span class=w> </span><span class=kt>type</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kr>const</span><span class=w> </span><span class=n>Self</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>@This</span><span class=p>();</span><span class=w>
</span><span class=w>        </span><span class=n>_parse</span><span class=o>:</span><span class=w> </span><span class=k>fn</span><span class=p>(</span><span class=n>self</span><span class=o>:</span><span class=w> </span><span class=o>*</span><span class=n>Self</span><span class=p>,</span><span class=w> </span><span class=n>allocator</span><span class=o>:</span><span class=w> </span><span class=o>*</span><span class=n>Allocator</span><span class=p>,</span><span class=w> </span><span class=n>src</span><span class=o>:</span><span class=w> </span><span class=o>*</span><span class=n>Reader</span><span class=p>)</span><span class=w> </span><span class=n>callconv</span><span class=p>(.</span><span class=n>Inline</span><span class=p>)</span><span class=w> </span><span class=n>Error</span><span class=o>!?</span><span class=n>Value</span><span class=p>,</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=kr>pub</span><span class=w> </span><span class=k>fn</span><span class=w> </span><span class=n>parse</span><span class=p>(</span><span class=n>self</span><span class=o>:</span><span class=w> </span><span class=o>*</span><span class=n>Self</span><span class=p>,</span><span class=w> </span><span class=n>allocator</span><span class=o>:</span><span class=w> </span><span class=o>*</span><span class=n>Allocator</span><span class=p>,</span><span class=w> </span><span class=n>src</span><span class=o>:</span><span class=w> </span><span class=o>*</span><span class=n>Reader</span><span class=p>)</span><span class=w> </span><span class=n>callconv</span><span class=p>(.</span><span class=n>Inline</span><span class=p>)</span><span class=w> </span><span class=n>Error</span><span class=o>!?</span><span class=n>Value</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=n>self</span><span class=p>.</span><span class=n>_parse</span><span class=p>(</span><span class=n>self</span><span class=p>,</span><span class=w> </span><span class=n>allocator</span><span class=p>,</span><span class=w> </span><span class=n>src</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><h3 id=zig-generics-are-provided-via-type-parameters>Zig generics are provided via type parameters</h3><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>pub</span><span class=w> </span><span class=k>fn</span><span class=w> </span><span class=n>Parser</span><span class=p>(</span><span class=kr>comptime</span><span class=w> </span><span class=n>Value</span><span class=o>:</span><span class=w> </span><span class=kt>type</span><span class=p>,</span><span class=w> </span><span class=kr>comptime</span><span class=w> </span><span class=n>Reader</span><span class=o>:</span><span class=w> </span><span class=kt>type</span><span class=p>)</span><span class=w> </span><span class=kt>type</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=p>...</span><span class=w>
</span><span class=w>    </span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>This is a Zig function which takes two arbitrary <code>type</code> arguments at <code>comptime</code>, named <code>Value</code> and <code>Reader</code>. Uppercase is used to denote the name of a type in Zig. Thes are:</p><ul><li><code>Value</code> will be the type of the actual value that the parser will produce (e.g. a string of matched text, or an AST note.)</li><li><code>Reader</code> will be the type of the actual source of the raw text to parse (we&rsquo;ll cover this more later.)</li></ul><p>The function itself <em>returns a new type</em>.</p><p>What we&rsquo;re seeing here is the key way in which <a href=https://ziglang.org/documentation/master/#Generic-Data-Structures>Zig approaches generic data structures</a>: you merely pass around types as parameters - as if they were values - and you write functions which take types as parameters and return types as values. Some examples of valid calls to this function are:</p><ul><li><code>Parser(u8, []u8)</code> where <code>u8</code> is an unsigned 8-bit integer and <code>[]u8</code> is a slice of unsigned 8-bit integers.</li><li><code>Parser([]const u8, @TypeOf(reader))</code> where <code>[]const u8</code> is describing a slice of UTF-8 text (a string) and <code>reader</code> is some reader type, such as <code>std.io.fixedBufferStream("foobar")</code>.</li></ul><h3 id=zig-runtime-interfaces>Zig runtime interfaces</h3><p>Now, since we&rsquo;re trying to define an interface whose actual implementation can be swapped out <em>at runtime</em> - what we need is pretty simple:</p><ul><li>A <code>struct</code> type which has the methods we want every implementation to provide.</li><li>Those methods to <em>call function pointers</em> which are defined as <em>fields</em> of our struct.</li></ul><p>Basically, if someone wants to implement our interface they just need to create a new instance of <code>Parser</code> and populate the fields (callbacks) so their implementation is called when the interface is used.</p><p>This is the same pattern used by the Zig <a href=https://sourcegraph.com/github.com/ziglang/zig/-/blob/lib/std/mem/Allocator.zig><code>std.mem.Allocator</code> interface</a>.</p><p>In our case here, the returned struct has a method that consumers of the interface would invoke called <code>parse</code> - and the function pointer field that implementors will set to get a callback is the <code>_parse</code> field:</p><img class=color-auto src=https://user-images.githubusercontent.com/3173176/110578739-ad390b00-8122-11eb-816c-09e1e281db9d.png><h3 id=type-parameters>Type parameters</h3><p>Let&rsquo;s look at some of the data types going around here:</p><img class=color-auto src=https://user-images.githubusercontent.com/3173176/110578578-60553480-8122-11eb-897b-e52e2d45eede.png><p>A few other notes:</p><ul><li><code>Error!?Value</code> is just describing the function can return an <code>Error</code> OR no value OR a <code>Value</code> type. See Zig&rsquo;s <a href=https://ziglang.org/documentation/master/#Error-Union-Type>error union types</a> and <a href=https://ziglang.org/documentation/master/#Optionals>optional types</a>.</li><li><code>callconv(.Inline)</code> is just telling the compiler to inline the function call - since our function isn&rsquo;t doing a ton.</li></ul><h3 id=errors-the-parser-interface-can-produce>Errors the Parser interface can produce</h3><p>Our error type might start out looking something like this:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>pub</span><span class=w> </span><span class=kr>const</span><span class=w> </span><span class=n>Error</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>error</span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>EndOfStream</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=n>std</span><span class=p>.</span><span class=n>mem</span><span class=p>.</span><span class=n>Allocator</span><span class=p>.</span><span class=n>Error</span><span class=p>;</span><span class=w>
</span></code></pre></div><p><code>error{...}</code> describes <a href=https://ziglang.org/documentation/master/#Error-Set-Type>a set of potential errors</a> and <code>|| std.mem.Allocator.Error</code> merely says to <em>merge</em> the allocator type&rsquo;s error set with ours - so our potential set of errors includes <em>ours and theirs</em>.</p><p>As we start performing different operations within parsers, it will become more complex to describe more potential sources of errors:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>pub</span><span class=w> </span><span class=kr>const</span><span class=w> </span><span class=n>Error</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>error</span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>EndOfStream</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>Utf8InvalidStartByte</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=n>std</span><span class=p>.</span><span class=n>fs</span><span class=p>.</span><span class=n>File</span><span class=p>.</span><span class=n>ReadError</span><span class=w>
</span><span class=w>  </span><span class=o>||</span><span class=w> </span><span class=n>std</span><span class=p>.</span><span class=n>fs</span><span class=p>.</span><span class=n>File</span><span class=p>.</span><span class=n>SeekError</span><span class=w>
</span><span class=w>  </span><span class=o>||</span><span class=w> </span><span class=n>std</span><span class=p>.</span><span class=n>mem</span><span class=p>.</span><span class=n>Allocator</span><span class=p>.</span><span class=n>Error</span><span class=p>;</span><span class=w>
</span></code></pre></div><p>Zig can often <a href=https://ziglang.org/documentation/master/#Inferred-Error-Sets>infer error sets</a> but only in some contexts today.</p><h2 id=our-first-parser>Our first Parser</h2><p>All we need to do in order to implement a <code>Parser</code> is provide the <code>_parse</code> method, and define its return <code>Value</code> type and <code>Reader</code> input type:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>const</span><span class=w> </span><span class=n>parser</span><span class=o>:</span><span class=w> </span><span class=n>Parser</span><span class=p>([]</span><span class=kt>u8</span><span class=p>,</span><span class=w> </span><span class=nb>@TypeOf</span><span class=p>(</span><span class=n>reader</span><span class=p>))</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>.{</span><span class=w>
</span><span class=w>    </span><span class=p>.</span><span class=n>_parse</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>myParse</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>};</span><span class=w>
</span></code></pre></div><p>In the above, the type <code>T</code> in <code>const parser: T</code> is denoting the type of the constant named <code>parser</code> - in this case it&rsquo;ll be the type returned by <code>Parser([]u8, @TypeOf(reader))</code>. And this:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=n>something</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>.{</span><span class=w>
</span><span class=w>    </span><span class=p>.</span><span class=n>_parse</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>myParse</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Is the Zig syntax for populating a struct. We&rsquo;re setting the <code>_parse</code> field to <code>myParse</code>. Zig can infer the type of the struct if you write a <code>.{}</code> instead of <code>T{}</code> - which avoids the need for us to repeat the call to the <code>Parser()</code> function which is verbose.</p><h3 id=what-actually-is-a-reader>What actually is a &ldquo;Reader&rdquo;?</h3><p>Up to this point, we&rsquo;ve just talked about <code>Reader</code> as being <em>any type</em>.</p><p>Similar to our <code>Parser</code> interface, the Zig standard library <a href=https://sourcegraph.com/github.com/ziglang/zig@f2b96782ecdc9e2f8740eb7d294203b2a585ea52/-/blob/lib/std/io/reader.zig#L13-20>provides a <code>std.io.Reader</code> interface</a> and there are <a href="https://sourcegraph.com/search?q=repo:%5Egithub%5C.com/ziglang/zig%24+file:%5Elib/std/+fn+reader%28&patternType=literal">many implementors of it</a> including:</p><ul><li><code>std.fs.File</code></li><li><code>std.io.fixedBufferStream("foobar")</code></li><li><code>std.net.Stream</code> (network sockets)</li></ul><p>However, in contrast to our <code>Parser</code> type which invokes <em>function pointers</em> at runtime, the <code>std.io.Reader</code> interface is a <em>compile time type</em> - meaning calls to the underlying implementation do not involve a pointer dereference.</p><p>Today, Zig is in early stages (version 0.7) and does not have anything like an interface or trait type (although <a href=https://github.com/ziglang/zig/issues/1268>it seems likely this will be improved in the future</a>.)</p><p>This means that, for now, we cannot simply define our function as accepting <em>only</em> an <code>std.io.Reader</code> interface - instead we must declare that we accept <em>any type</em> which we&rsquo;ll call <code>Reader</code>, write our code <em>as if it is an <code>std.io.Reader</code></em> - and the compiler will just barf if anybody passes something in that <em>isn&rsquo;t</em> an <code>std.io.Reader</code>. This can sometimes lead to confusing compiler error messages (&ldquo;there&rsquo;s an error in the standard library code? Ah, no, I just needed to pass a <code>.reader()</code>!").</p><h3 id=a-parser-that-parses-a-literal-string>A Parser that parses a literal string</h3><p>If we want a <code>Parser</code> interface implementation that parses a specific string literal, one way to do that is to also make that a generic function which accepts <em>any</em> reader type (so we&rsquo;re not restricted to e.g. just file inputs):</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>pub</span><span class=w> </span><span class=k>fn</span><span class=w> </span><span class=n>Literal</span><span class=p>(</span><span class=kr>comptime</span><span class=w> </span><span class=n>Reader</span><span class=o>:</span><span class=w> </span><span class=kt>type</span><span class=p>)</span><span class=w> </span><span class=kt>type</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=c1>// TODO
</span><span class=c1></span><span class=w>    </span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>This is pretty good - but we need some way to have the type we return <em>implement</em> the <code>Parser</code> interface we defined. The way to do this is by defining a field in our struct:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>pub</span><span class=w> </span><span class=k>fn</span><span class=w> </span><span class=n>Literal</span><span class=p>(</span><span class=kr>comptime</span><span class=w> </span><span class=n>Reader</span><span class=o>:</span><span class=w> </span><span class=kt>type</span><span class=p>)</span><span class=w> </span><span class=kt>type</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>parser</span><span class=o>:</span><span class=w> </span><span class=n>Parser</span><span class=p>([]</span><span class=kt>u8</span><span class=p>,</span><span class=w> </span><span class=n>Reader</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>.{</span><span class=w>
</span><span class=w>            </span><span class=p>.</span><span class=n>_parse</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>parse</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=p>},</span><span class=w>
</span><span class=w>    </span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Now a consumer can write the following to get a literal string parser:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>const</span><span class=w> </span><span class=n>parser</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Literal</span><span class=p>(</span><span class=nb>@TypeOf</span><span class=p>(</span><span class=n>reader</span><span class=p>)).</span><span class=n>parser</span><span class=p>;</span><span class=w>
</span></code></pre></div><h3 id=passing-parameters-to-a-parser-implementation>Passing parameters to a parser implementation</h3><p>If we want our <code>Literal</code> parser to accept a parameter &ndash; the literal string to look for &ndash; we need to give it a parameter.</p><p>In the case of merely passing it a string, we <em>could</em> adjust the signature so that this is possible:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>const</span><span class=w> </span><span class=n>parser</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Literal</span><span class=p>(</span><span class=s>&#34;some string&#34;</span><span class=p>,</span><span class=w> </span><span class=nb>@TypeOf</span><span class=p>(</span><span class=n>reader</span><span class=p>)).</span><span class=n>parser</span><span class=p>;</span><span class=w>
</span></code></pre></div><p>However, we&rsquo;ll define ours using an <code>init</code> method which is more common in Zig data structures:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>pub</span><span class=w> </span><span class=k>fn</span><span class=w> </span><span class=n>Literal</span><span class=p>(</span><span class=kr>comptime</span><span class=w> </span><span class=n>Reader</span><span class=o>:</span><span class=w> </span><span class=kt>type</span><span class=p>)</span><span class=w> </span><span class=kt>type</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>parser</span><span class=o>:</span><span class=w> </span><span class=n>Parser</span><span class=p>([]</span><span class=kt>u8</span><span class=p>,</span><span class=w> </span><span class=n>Reader</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>.{</span><span class=w>
</span><span class=w>            </span><span class=p>.</span><span class=n>_parse</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>parse</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=p>},</span><span class=w>
</span><span class=w>        </span><span class=n>want</span><span class=o>:</span><span class=w> </span><span class=p>[]</span><span class=kr>const</span><span class=w> </span><span class=kt>u8</span><span class=p>,</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=kr>const</span><span class=w> </span><span class=n>Self</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>@This</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=c1>// The `want` string must stay alive for as long as the parser will be used.
</span><span class=c1></span><span class=w>        </span><span class=kr>pub</span><span class=w> </span><span class=k>fn</span><span class=w> </span><span class=n>init</span><span class=p>(</span><span class=n>want</span><span class=o>:</span><span class=w> </span><span class=p>[]</span><span class=kr>const</span><span class=w> </span><span class=kt>u8</span><span class=p>)</span><span class=w> </span><span class=n>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=n>Self</span><span class=p>{</span><span class=w>
</span><span class=w>                </span><span class=p>.</span><span class=n>want</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>want</span><span class=w>
</span><span class=w>            </span><span class=p>};</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>In this case, <code>want</code> is the string literal we want to match - and <code>[]const u8</code> is Zig&rsquo;s string type. It describes a slice of immutable (non-modifiable) encoded UTF-8 bytes.</p><p>Unlike C, <code>[]const u8</code> being a slice means it is <em>a pointer to the string in memory and its length</em> - so we don&rsquo;t have to pass around the length parameter separately or use a null-terminated string. In Zig, there are two ways to represent a string:</p><ul><li><code>[]const u8</code> (unmodifiable string, most common)</li><li><code>[]u8</code> (modifiable string)</li></ul><h3 id=understanding-zigs-wildconfusing-fieldparentptr>Understanding Zig&rsquo;s wild/confusing <code>@fieldParentPtr</code></h3><p>We&rsquo;re finally ready to actually have our <code>Literal</code> parser <em>parse</em> something! We just need to implement our <code>parse</code> method:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>pub</span><span class=w> </span><span class=k>fn</span><span class=w> </span><span class=n>Literal</span><span class=p>(</span><span class=kr>comptime</span><span class=w> </span><span class=n>Reader</span><span class=o>:</span><span class=w> </span><span class=kt>type</span><span class=p>)</span><span class=w> </span><span class=kt>type</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>parser</span><span class=o>:</span><span class=w> </span><span class=n>Parser</span><span class=p>([]</span><span class=kt>u8</span><span class=p>,</span><span class=w> </span><span class=n>Reader</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>.{</span><span class=w>
</span><span class=w>            </span><span class=p>.</span><span class=n>_parse</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>parse</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=p>},</span><span class=w>
</span><span class=w>        </span><span class=n>want</span><span class=o>:</span><span class=w> </span><span class=p>[]</span><span class=kr>const</span><span class=w> </span><span class=kt>u8</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=p>...</span><span class=w>
</span><span class=w>        </span><span class=kr>const</span><span class=w> </span><span class=n>Self</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>@This</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=k>fn</span><span class=w> </span><span class=n>parse</span><span class=p>(</span><span class=n>parser</span><span class=o>:</span><span class=w> </span><span class=o>*</span><span class=n>Parser</span><span class=p>([]</span><span class=kt>u8</span><span class=p>,</span><span class=w> </span><span class=n>Reader</span><span class=p>),</span><span class=w> </span><span class=n>allocator</span><span class=o>:</span><span class=w> </span><span class=o>*</span><span class=n>Allocator</span><span class=p>,</span><span class=w> </span><span class=n>src</span><span class=o>:</span><span class=w> </span><span class=o>*</span><span class=n>Reader</span><span class=p>)</span><span class=w> </span><span class=n>callconv</span><span class=p>(.</span><span class=n>Inline</span><span class=p>)</span><span class=w> </span><span class=n>Error</span><span class=o>!?</span><span class=p>[]</span><span class=kt>u8</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=kr>const</span><span class=w> </span><span class=n>self</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>@fieldParentPtr</span><span class=p>(</span><span class=n>Self</span><span class=p>,</span><span class=w> </span><span class=s>&#34;parser&#34;</span><span class=p>,</span><span class=w> </span><span class=n>parser</span><span class=p>);</span><span class=w>
</span><span class=w>            </span><span class=p>...</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>But wait a minute! In order for the <code>._parse = parse,</code> assignment to work the first argument to <code>parse</code> needs to be the <code>self</code> parameter for a <code>Parser([]u8, Reader)</code> - so how does <em>our</em> <code>parse</code> implementation method get to access the <code>want</code> field of our struct?</p><p>This is where some Zig magic comes in: on obscure builtin function we can use inside of our <code>parse</code> method:</p><pre><code>const self = @fieldParentPtr(Self, &quot;parser&quot;, parser);
</code></pre><p>To understand this, first let&rsquo;s get a look at what these parameters are referring to:</p><img class=color-auto src=https://user-images.githubusercontent.com/3173176/110593977-7b7f6e80-8139-11eb-8ecc-41dff5766ec2.png><p>We can see from the Zig documentation that this function operates as follows:</p><blockquote><p>Given a pointer to a field, returns the base pointer of a struct.</p></blockquote><p>So in our case:</p><ul><li><code>Self</code> is the &ldquo;parent struct&rdquo; we&rsquo;re trying to acquire a reference to (our type)</li><li><code>"parser"</code> is the name of our struct&rsquo;s field.</li><li><code>parser</code> is the <em>pointer to our <code>parser</code> struct field</em>.</li></ul><p>Hopefully you can start to see the link here: <code>parser</code> is a pointer to <em>our struct field</em>, so Zig has a little helper <code>@fieldParentPtr</code> which can rely on that fact to give us <em>our struct</em> given a pointer to <em>our struct field</em>.</p><h3 id=implementing-the-rest-of-parse>Implementing the rest of <code>parse</code></h3><p>Our full <code>parse</code> method will look like this:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=c1>// If a value is returned, it is up to the caller to free it.
</span><span class=c1></span><span class=k>fn</span><span class=w> </span><span class=n>parse</span><span class=p>(</span><span class=n>parser</span><span class=o>:</span><span class=w> </span><span class=o>*</span><span class=n>Parser</span><span class=p>([]</span><span class=kt>u8</span><span class=p>,</span><span class=w> </span><span class=n>Reader</span><span class=p>),</span><span class=w> </span><span class=n>allocator</span><span class=o>:</span><span class=w> </span><span class=o>*</span><span class=n>Allocator</span><span class=p>,</span><span class=w> </span><span class=n>src</span><span class=o>:</span><span class=w> </span><span class=o>*</span><span class=n>Reader</span><span class=p>)</span><span class=w> </span><span class=n>callconv</span><span class=p>(.</span><span class=n>Inline</span><span class=p>)</span><span class=w> </span><span class=n>Error</span><span class=o>!?</span><span class=p>[]</span><span class=kt>u8</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kr>const</span><span class=w> </span><span class=n>self</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>@fieldParentPtr</span><span class=p>(</span><span class=n>Self</span><span class=p>,</span><span class=w> </span><span class=s>&#34;parser&#34;</span><span class=p>,</span><span class=w> </span><span class=n>parser</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=kr>const</span><span class=w> </span><span class=n>buf</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>try</span><span class=w> </span><span class=n>allocator</span><span class=p>.</span><span class=n>alloc</span><span class=p>(</span><span class=kt>u8</span><span class=p>,</span><span class=w> </span><span class=n>self</span><span class=p>.</span><span class=n>want</span><span class=p>.</span><span class=n>len</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=k>errdefer</span><span class=w> </span><span class=n>allocator</span><span class=p>.</span><span class=n>free</span><span class=p>(</span><span class=n>buf</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=kr>const</span><span class=w> </span><span class=n>read</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>try</span><span class=w> </span><span class=n>src</span><span class=p>.</span><span class=n>reader</span><span class=p>().</span><span class=n>readAll</span><span class=p>(</span><span class=n>buf</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>read</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>self</span><span class=p>.</span><span class=n>want</span><span class=p>.</span><span class=n>len</span><span class=w> </span><span class=k>or</span><span class=w> </span><span class=o>!</span><span class=n>std</span><span class=p>.</span><span class=n>mem</span><span class=p>.</span><span class=n>eql</span><span class=p>(</span><span class=kt>u8</span><span class=p>,</span><span class=w> </span><span class=n>buf</span><span class=p>,</span><span class=w> </span><span class=n>self</span><span class=p>.</span><span class=n>want</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=k>try</span><span class=w> </span><span class=n>src</span><span class=p>.</span><span class=n>seekableStream</span><span class=p>().</span><span class=n>seekBy</span><span class=p>(</span><span class=o>-</span><span class=nb>@intCast</span><span class=p>(</span><span class=kt>i64</span><span class=p>,</span><span class=w> </span><span class=n>read</span><span class=p>));</span><span class=w>
</span><span class=w>        </span><span class=n>allocator</span><span class=p>.</span><span class=n>free</span><span class=p>(</span><span class=n>buf</span><span class=p>);</span><span class=w> </span><span class=c1>// parsing failed
</span><span class=c1></span><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>buf</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>There are a few notable things here:</p><ul><li>We&rsquo;re trying to return a string from our <code>parse</code> function, i.e. the value it emits is a string (instead of an AST node).</li><li>The <code>want</code> string we <em>got</em> inside of our <code>init</code> method is agreed to only be valid while <code>parse</code> will still be called. We&rsquo;ve decided to create a contract that all of our <code>Parser</code> implementations will either not hold onto memory given by others - or if they do, only do so until <code>parse</code> returns. Hence, we need to allocate a new string in our method.</li><li>Normally we could rely solely on <code>defer</code> (&ldquo;run at end of function&rdquo;) or <code>errdefer</code> (&ldquo;run if an error is returned&rdquo;), but since we&rsquo;ve chosen to reserve the <em>none optional</em> <code>null</code> as &ldquo;we didn&rsquo;t parse anything&rdquo; we need to manually free if we <code>return null;</code>. A <code>nulldefer</code> and <code>somedefer</code> could be nice, maybe?</li></ul><p>Putting it all together, you&rsquo;ll get something like this: <a href=https://gist.github.com/slimsag/8f098a13177b4bc008a7741505819f90>GitHub gist</a>.</p><h2 id=our-first-_parser-combinator_>Our first <em>parser combinator</em></h2><p>To demonstrate how a <em>parser combinator</em> would be implemented, we&rsquo;ll try implementing the <code>OneOf</code> operator. It will take any number of <em>parsers</em> as input and run them consecutively until one succeeds or none do.</p><p>Let&rsquo;s first start by writing out the basic structure of our function:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>pub</span><span class=w> </span><span class=k>fn</span><span class=w> </span><span class=n>OneOf</span><span class=p>(</span><span class=kr>comptime</span><span class=w> </span><span class=n>Value</span><span class=o>:</span><span class=w> </span><span class=kt>type</span><span class=p>,</span><span class=w> </span><span class=kr>comptime</span><span class=w> </span><span class=n>Reader</span><span class=o>:</span><span class=w> </span><span class=kt>type</span><span class=p>)</span><span class=w> </span><span class=kt>type</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>parser</span><span class=o>:</span><span class=w> </span><span class=n>Parser</span><span class=p>(</span><span class=n>Value</span><span class=p>,</span><span class=w> </span><span class=n>Reader</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>.{</span><span class=w>
</span><span class=w>            </span><span class=p>.</span><span class=n>_parse</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>parse</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=p>},</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=p>...</span><span class=w>
</span><span class=w>    </span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>You&rsquo;ll notice here that in contrast to our <code>Literal</code> <em>parser</em> function from earlier, this function takes a second <code>comptime Value: type</code> parameter. This is because we want it to work with any existing <code>Parser</code> implementation, regardless of what type of value it produces.</p><p>We can start to fill in the type by adding our <code>init</code> method:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>pub</span><span class=w> </span><span class=k>fn</span><span class=w> </span><span class=n>OneOf</span><span class=p>(</span><span class=kr>comptime</span><span class=w> </span><span class=n>Value</span><span class=o>:</span><span class=w> </span><span class=kt>type</span><span class=p>,</span><span class=w> </span><span class=kr>comptime</span><span class=w> </span><span class=n>Reader</span><span class=o>:</span><span class=w> </span><span class=kt>type</span><span class=p>)</span><span class=w> </span><span class=kt>type</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>parser</span><span class=o>:</span><span class=w> </span><span class=n>Parser</span><span class=p>(</span><span class=n>Value</span><span class=p>,</span><span class=w> </span><span class=n>Reader</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>.{</span><span class=w>
</span><span class=w>            </span><span class=p>.</span><span class=n>_parse</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>parse</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=p>},</span><span class=w>
</span><span class=w>        </span><span class=n>parsers</span><span class=o>:</span><span class=w> </span><span class=p>[]</span><span class=o>*</span><span class=n>Parser</span><span class=p>(</span><span class=n>Value</span><span class=p>,</span><span class=w> </span><span class=n>Reader</span><span class=p>),</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=kr>const</span><span class=w> </span><span class=n>Self</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>@This</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=c1>// `parsers` slice must stay alive for as long as the parser will be
</span><span class=c1></span><span class=w>        </span><span class=c1>// used.
</span><span class=c1></span><span class=w>        </span><span class=kr>pub</span><span class=w> </span><span class=k>fn</span><span class=w> </span><span class=n>init</span><span class=p>(</span><span class=n>parsers</span><span class=o>:</span><span class=w> </span><span class=p>[]</span><span class=o>*</span><span class=n>Parser</span><span class=p>(</span><span class=n>Value</span><span class=p>,</span><span class=w> </span><span class=n>Reader</span><span class=p>))</span><span class=w> </span><span class=n>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=n>Self</span><span class=p>{</span><span class=w>
</span><span class=w>                </span><span class=p>.</span><span class=n>parsers</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>parsers</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=p>};</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>As you can see here, we&rsquo;re going to simply take in a list of pointers to parsers. They&rsquo;ll all need to have the same return <code>Value</code> as was specified in the call to <code>OneOf</code>.</p><p>One reason for this is that <a href=https://github.com/ziglang/zig/issues/447>Zig does not support <em>return type inference</em></a>. You can have a function which takes <code>anytype</code> as a parameter, but it cannot return an <code>anytype</code>. This just means we need to have a generic function (in this case, <code>OneOf</code>) which accepts a type parameter and then use that <code>Value</code> type later. In a language like Haskell or OCaml, this would not be true.</p><p>Finally, we can implement our <code>parse</code> method:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>pub</span><span class=w> </span><span class=k>fn</span><span class=w> </span><span class=n>OneOf</span><span class=p>(</span><span class=kr>comptime</span><span class=w> </span><span class=n>Value</span><span class=o>:</span><span class=w> </span><span class=kt>type</span><span class=p>,</span><span class=w> </span><span class=kr>comptime</span><span class=w> </span><span class=n>Reader</span><span class=o>:</span><span class=w> </span><span class=kt>type</span><span class=p>)</span><span class=w> </span><span class=kt>type</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=p>...</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=c1>// Caller is responsible for freeing the value, if any.
</span><span class=c1></span><span class=w>        </span><span class=k>fn</span><span class=w> </span><span class=n>parse</span><span class=p>(</span><span class=n>parser</span><span class=o>:</span><span class=w> </span><span class=o>*</span><span class=n>Parser</span><span class=p>(</span><span class=n>Value</span><span class=p>,</span><span class=w> </span><span class=n>Reader</span><span class=p>),</span><span class=w> </span><span class=n>allocator</span><span class=o>:</span><span class=w> </span><span class=o>*</span><span class=n>Allocator</span><span class=p>,</span><span class=w> </span><span class=n>src</span><span class=o>:</span><span class=w> </span><span class=o>*</span><span class=n>Reader</span><span class=p>)</span><span class=w> </span><span class=n>callconv</span><span class=p>(.</span><span class=n>Inline</span><span class=p>)</span><span class=w> </span><span class=n>Error</span><span class=o>!?</span><span class=n>Value</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=kr>const</span><span class=w> </span><span class=n>self</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>@fieldParentPtr</span><span class=p>(</span><span class=n>Self</span><span class=p>,</span><span class=w> </span><span class=s>&#34;parser&#34;</span><span class=p>,</span><span class=w> </span><span class=n>parser</span><span class=p>);</span><span class=w>
</span><span class=w>            </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>self</span><span class=p>.</span><span class=n>parsers</span><span class=p>)</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>one_of_parser</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                </span><span class=kr>const</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>try</span><span class=w> </span><span class=n>one_of_parser</span><span class=p>.</span><span class=n>parse</span><span class=p>(</span><span class=n>allocator</span><span class=p>,</span><span class=w> </span><span class=n>src</span><span class=p>);</span><span class=w>
</span><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>result</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                    </span><span class=k>return</span><span class=w> </span><span class=n>result</span><span class=p>;</span><span class=w>
</span><span class=w>                </span><span class=p>}</span><span class=w>
</span><span class=w>            </span><span class=p>}</span><span class=w>
</span><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>There are a few things to unpack here:</p><ul><li><code>try one_of_parser.parse(allocator, src);</code> indicates that if parsing using <code>one_of_parser</code> returns an <em>error</em> that our function should return immediately and not continue attempting to parse with other parsers.</li><li><code>if (result != null) {</code> is how you check if an Optional type in Zig is &ldquo;None&rdquo;. I find this pretty interesting: it&rsquo;s not <code>null</code>, it&rsquo;s actually an optional &ldquo;none&rdquo; type - but it is called <code>null</code>. I&rsquo;m not sure why, but can imagine this making the language friendlier to people unfamiliar with optional types.</li></ul><h2 id=using-our-oneof-parser-combinator>Using our OneOf parser combinator</h2><p>Now for the cool part: we get to put both our <code>Literal</code> parser and <code>OneOf</code> parser combinator to <em>build a new parser</em>!</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=c1>// Define our parser.
</span><span class=c1></span><span class=kr>var</span><span class=w> </span><span class=n>one_of</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>OneOf</span><span class=p>([]</span><span class=kt>u8</span><span class=p>,</span><span class=w> </span><span class=nb>@TypeOf</span><span class=p>(</span><span class=n>reader</span><span class=p>)).</span><span class=n>init</span><span class=p>(</span><span class=o>&amp;</span><span class=p>.{</span><span class=w>
</span><span class=w>    </span><span class=o>&amp;</span><span class=n>Literal</span><span class=p>(</span><span class=nb>@TypeOf</span><span class=p>(</span><span class=n>reader</span><span class=p>)).</span><span class=n>init</span><span class=p>(</span><span class=s>&#34;dog&#34;</span><span class=p>).</span><span class=n>parser</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=o>&amp;</span><span class=n>Literal</span><span class=p>(</span><span class=nb>@TypeOf</span><span class=p>(</span><span class=n>reader</span><span class=p>)).</span><span class=n>init</span><span class=p>(</span><span class=s>&#34;sheep&#34;</span><span class=p>).</span><span class=n>parser</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=o>&amp;</span><span class=n>Literal</span><span class=p>(</span><span class=nb>@TypeOf</span><span class=p>(</span><span class=n>reader</span><span class=p>)).</span><span class=n>init</span><span class=p>(</span><span class=s>&#34;cat&#34;</span><span class=p>).</span><span class=n>parser</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>});</span><span class=w>
</span></code></pre></div><p>The above will parse one of <code>"dog"</code>, <code>"sheep"</code>, or <code>"cat"</code> from the input reader.</p><p>We&rsquo;re passing <code>@TypeOf(reader)</code> frequently above which makes the code a bit more cryptic than needed, and it would be possible to introduce a <code>OneOfLiteral</code> helper which makes the above instead read:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=c1>// Define our parser.
</span><span class=c1></span><span class=kr>var</span><span class=w> </span><span class=n>one_of</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>OneOfLiteral</span><span class=p>([]</span><span class=kt>u8</span><span class=p>,</span><span class=w> </span><span class=nb>@TypeOf</span><span class=p>(</span><span class=n>reader</span><span class=p>)).</span><span class=n>init</span><span class=p>(</span><span class=o>&amp;</span><span class=p>.{</span><span class=w>
</span><span class=w>    </span><span class=s>&#34;dog&#34;</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=s>&#34;cat&#34;</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=s>&#34;sheep&#34;</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>});</span><span class=w>
</span></code></pre></div><p>One thing to unpack here is this syntax for passing an array to <code>init</code>: <code>&.{...}</code>:</p><ul><li>The function takes a parameter <code>parsers: []*Parser(Value, Reader)</code></li><li><code>.{...}</code> would give us <em>a fixed size array</em> <code>[3]*Parser(Value, Reader)</code></li><li><code>&.{}</code> gives us a pointer to an array, i.e. <em>a slice</em> <code>[]*Parser(Value, Reader)</code>.</li></ul><p>Since our list is known at compile time, we don&rsquo;t have to allocate or free memory for the slice. If our list was dynamic, we would need to do so.</p><p>Finally, we can actually use our parser above:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>var</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>one_of</span><span class=p>.</span><span class=n>parser</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=kr>var</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>try</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>parse</span><span class=p>(</span><span class=n>allocator</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>reader</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=n>std</span><span class=p>.</span><span class=n>testing</span><span class=p>.</span><span class=n>expectEqualStrings</span><span class=p>(</span><span class=s>&#34;cat&#34;</span><span class=p>,</span><span class=w> </span><span class=n>result</span><span class=p>.</span><span class=o>?</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>result</span><span class=p>)</span><span class=w> </span><span class=o>|</span><span class=n>r</span><span class=o>|</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>allocator</span><span class=p>.</span><span class=n>free</span><span class=p>(</span><span class=n>r</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><h2 id=runtime-parser-generation>Runtime parser generation</h2><p>You might be wondering how we would go from the <code>Literal</code> <em>parser</em> and <code>OneOf</code> <em>parser combinator</em> to actually <em>generating a parser at runtime that can parse the semantics defined in a regexp string</em>.</p><p>Since our <code>Parser</code> interface is a runtime interface (you can swap out the implementation at runtime) and since our parser combinator <code>OneOf</code> operates using that interface (only the return value must be known at compile time, it could be a generic AST node) it means that we can easily dynamically create slices of <code>[]*Parser(...)</code> at runtime based on the result of a parser combinator we have built - like our &ldquo;dog, cat, sheep&rdquo; parser from earlier.</p><p>The challenge left for you as a reader is to:</p><ul><li>Write <em>parsers</em> like our <code>Literal</code> parser that can parse the components of our regexp <code>a[bc].*abc</code>:<ul><li><code>RegexLiteralParser</code> can parse <code>a</code>, <code>b</code>, and <code>c</code>, but not <code>abc</code> (the string.)</li><li><code>RegexRangeOpenParser</code> can parse <code>[</code>.</li><li><code>RegexRangeCloseParser</code> can parse <code>]</code></li><li><code>RegexAnyParser</code> can parse the <code>.</code> &ldquo;any character&rdquo; syntax.</li><li><code>RegexRepetitionParser</code> can parse the <code>*</code> repetition operator.</li></ul></li><li>Write a <em>parser combinators</em> like our <code>OneOf</code> parser, except have it parse a <code>Sequence</code> of parsers.</li><li>Use our <code>Sequence</code> parser combinator and <code>RegexLiteralParser</code> to build a <code>RegexStringLiteralParser</code> - similar to how we built out &ldquo;dog, cat, sheep&rdquo; parser.</li><li>Write a <em>new kind of function</em> called a <em>runtime parser generator</em> named <code>RegexParser</code> which will be super familiar:<ul><li>Take in a <em>parser combinator</em> called <code>RegexSyntaxParser</code> which can turn your regexp syntax into some intermediary like an AST.</li><li>Have your function <em>use parser combinators like OneOf, Sequence, etc.</em> to build a brand new parser at runtime based on that intermediary AST.</li><li>Return that new parser which parses the actual semantics described by the input regexp!</li></ul></li></ul><h2 id=closing-thoughts>Closing thoughts</h2><p>I am sorry for not giving you a full (or even partial) regex engine :) I am still exploring this and it is a large undertaking, this blog post would be far too long if it was included.</p><p>You can find a copy of the final code with <em>parsers</em> and <em>parser combinators</em> <a href=https://gist.github.com/slimsag/db2dd2c49aa038e23b654120e70c9b00>here</a>. Just <code>zig init-exe</code> and plop them into your <code>src/</code> directory.</p><p>You may also want to check out <a href=https://github.com/Hejsil/mecha>Mecha</a>, a parser combinator library for Zig.</p><p>If anything was unclear or confusing, I&rsquo;m happy to help: shoot me an email <a href=mailto:stephen@hexops.com>stephen@hexops.com</a> or leave a comment on Hacker News / Reddit and I&rsquo;ll follow up.</p></div></main><script>function addAnchor(a){a.insertAdjacentHTML('afterbegin',`<a href="#${a.id}" class="hanchor" ariaLabel="Anchor">#</a> `)}document.addEventListener('DOMContentLoaded',function(){var a=document.querySelectorAll('h1[id], h2[id], h3[id], h4[id]');a&&a.forEach(addAnchor)})</script></div><div class=footer><div class=row-1><a href=https://hexops.com/privacy>Privacy matters</a>
<a href=https://github.com/sponsors/slimsag>Sponsor on GitHub</a>
<a href=https://machengine.org>machengine.org</a></div><div class=row-2><a href=/feed.xml><img alt="RSS feed" src="https://shields.io/badge/RSS-follow-green?logo=RSS"></a></div><div class=row-3><a href=https://hexops.com><img class="logo color-auto" alt="Hexops logo" src=https://raw.githubusercontent.com/hexops/media/234e15f265b19743c580a078b2d68660c92675d4/logo.svg height=50px></a></div></div></body></html>