<!doctype html><html><head><link rel=stylesheet href=https://devlog.hexops.com/assets/font/stylesheet.css><link rel=stylesheet href=https://devlog.hexops.com/main.542172aae70a7994b0407dbd1f63f48ead97025b8fe9f77d87673847fca7629b.css><script async defer data-domain=hexops.com src=https://hexops.com/opendata.js></script><meta charset=utf-8><title>Perfecting GLFW for Zig, and finding lurking undefined behavior that went unnoticed for 6+ years | Hexops' devlog</title><link rel=canonical href=https://devlog.hexops.com/2021/perfecting-glfw-for-zig-and-finding-undefined-behavior/><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><meta property="og:title" content="Perfecting GLFW for Zig, and finding lurking undefined behavior that went unnoticed for 6+ years"><meta property="og:description" content="Today, I am announcing mach/glfw: Ziggified GLFW bindings with 100% API coverage, zero-fuss installation, cross compilation, and more."><meta property="og:type" content="article"><meta property="og:url" content="https://devlog.hexops.com/2021/perfecting-glfw-for-zig-and-finding-undefined-behavior/"><meta property="og:image" content="https://user-images.githubusercontent.com/3173176/139573985-d862f35a-e78e-40c2-bc0c-9c4fb68d6ecd.png"><meta property="article:section" content="2021"><meta property="article:published_time" content="2021-10-31T00:00:00+00:00"><meta property="article:modified_time" content="2021-10-31T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://user-images.githubusercontent.com/3173176/139573985-d862f35a-e78e-40c2-bc0c-9c4fb68d6ecd.png"><meta name=twitter:title content="Perfecting GLFW for Zig, and finding lurking undefined behavior that went unnoticed for 6+ years"><meta name=twitter:description content="Today, I am announcing mach/glfw: Ziggified GLFW bindings with 100% API coverage, zero-fuss installation, cross compilation, and more."></head><body><div class=navbar><div class=content><a href=/ class=logo><img src=https://raw.githubusercontent.com/hexops/media/234e15f265b19743c580a078b2d68660c92675d4/logo.svg>' devlog</a><div><a href=https://hexops.com/about class=item>About</a>
<a href=/archives class=item>Archives</a>
<a href=https://github.com/hexops class=item>GitHub</a></div></div></div><div id=content><main aria-role=main class=main-single><div class=single><header class=header><h1>Perfecting GLFW for Zig, and finding lurking undefined behavior that went unnoticed for 6+ years</h1><div class=metadata><time>October 31, 2021</time>
• <a class=category href=/categories/mach>mach</a>
• <a class=category href=/categories/zig>zig</a>
• <a class=category href=/categories/gamedev>gamedev</a>
• <a class=category href=/categories/glfw>glfw</a></div></header><p><strong>Today, I am announcing <a href=https://github.com/hexops/mach-glfw>mach-glfw</a>: Ziggified GLFW bindings with 100% API coverage, zero-fuss installation, cross compilation, and more.</strong></p><h2 id=building-mach-for-everyone>Building Mach for everyone</h2><p>If <a href=https://github.com/hexops/mach>Mach engine</a> only benefits people interested in using that engine, and not the broader Zig (and even gamedev) community I would consider that <em>a total failure</em>.</p><p>Whether you&rsquo;re interested in using all of Mach, just some of it with your own engine / project, or just the tools/ideas we develop in the future (with Unity, Unreal, etc.), <em>I truly aim to produce something that benefits you</em>.</p><p>Mach is in super early stages, I&rsquo;ve spent the last four months perfecting a Zig interface to GLFW, and making no-fuss installation and cross-compilation a reality. Today, you can benefit from that work too.</p><h2 id=building-glfw-for-every-platform>Building GLFW for every platform</h2><p>Just <code>zig</code> and <code>git</code>, that&rsquo;s the idea. The GLFW C code is compiled with <code>zig</code>, and the <code>build.zig</code> file automatically uses <code>git</code> to clone (a very minimal set of) system dependencies for you (X11 libraries, etc.)</p><p>No installing apt packages. No dealing with missing header errors. It should just work out-of-the-box, and for every platform:</p><p><a href=https://user-images.githubusercontent.com/3173176/137650099-cd370046-eb43-4fe4-a72a-f54ebe3153c1.png><img alt="Mach engine platform support, including Windows, Linux, Mac and cross-compilation between them with Android/iOS coming soon." class=color src=https://user-images.githubusercontent.com/3173176/137650099-cd370046-eb43-4fe4-a72a-f54ebe3153c1.png></a></p><p>Today, this works for GLFW itself. Cross-compilation of <em>OpenGL and Vulkan apps</em> is not yet fully functional. <a href=https://github.com/hexops/mach/issues/59>We&rsquo;re working on it, though.</a></p><h2 id=perfecting-glfw-for-zig>Perfecting GLFW for Zig</h2><p>Aside from platform support, mach-glfw now has:</p><ul><li><strong>100% API coverage</strong> of GLFW v3.3.4. Every function, type, constant, etc. has been wrapped in a ziggified API.</li><li><strong>130+ tests</strong>, with CI testing Linux, Windows, Mac (x86 and M1/ARM) and cross-compilation between them.</li></ul><p>You might be asking: <em>why Zig bindings, when Zig can interface directly with C?</em> Ziggified bindings to GLFW get us:</p><ul><li>Errors as <a href=https://ziglang.org/documentation/master/#Errors>zig errors</a> instead of via a callback function.</li><li><strong>Enums</strong>: always know what value a GLFW function can accept as everything is strictly typed. And use the nice Zig syntax to access enums, like <code>window.getKey(.escape)</code> instead of <code>c.glfwGetKey(window, c.GLFW_KEY_ESCAPE)</code></li><li>Slices instead of C pointers and lengths.</li><li><a href=https://ziglang.org/documentation/master/#packed-struct>packed structs</a> represent bit masks, so you can use <code>if (joystick.down and joystick.right)</code> instead of <code>&</code> <code>|</code> etc. bitwise operators.</li><li><code>true</code> and <code>false</code> instead of <code>c.GLFW_TRUE</code> and <code>c.GLFW_FALSE</code>.</li><li>Generics: use <code>window.hint</code> instead of <code>glfwWindowHint</code>, <code>glfwWindowHintString</code>, etc.</li><li>Methods, e.g. <code>my_window.hint(...)</code> instead of <code>glfwWindowHint(my_window, ...)</code></li></ul><h2 id=explicit-error-handling-solves-a-real-problem>Explicit error handling solves a real problem</h2><p>GLFW traditionally passes errors to the user via a callback. This can make errors easy to ignore, as well as difficult to correlate and handle effectively at the time of the function invocation.</p><p>We translated a <a href=https://github.com/hexops/mach-glfw-vulkan-example>a Vulkan example to mach-glfw</a>, which you can try for yourself today:</p><p><a href=https://user-images.githubusercontent.com/3173176/139573985-d862f35a-e78e-40c2-bc0c-9c4fb68d6ecd.png><img alt="mach-glfw and vulkan-zig libraries working together to produce a triangle." class=color src=https://user-images.githubusercontent.com/3173176/139573985-d862f35a-e78e-40c2-bc0c-9c4fb68d6ecd.png></a></p><p>After porting it, we found that the example was crashing with a <code>NoWindowContext</code> error. Strange?</p><p>As it turns out, we had found <a href=https://github.com/Snektron/vulkan-zig/pull/21>a small bug in the vulkan-zig example code</a>, it was calling <code>glfwSwapBuffers</code> which is not needed for Vulkan. The error went unnoticed because it&rsquo;s easy to miss errors with GLFW&rsquo;s error callback handling style. But with mach-glfw, it was an explicit error you have to handle e.g. via <code>try glfw.swapBuffers()</code> - we literally couldn&rsquo;t miss it.</p><h2 id=finding-lurking-undefined-behavior-in-6-year-old-glfw-code>Finding lurking undefined behavior in 6+ year old GLFW code</h2><p>One <em>particularly frustrating</em> issue was tracking down why the last part of the GLFW API we needed to wrap for 100% coverage, the <code>glfwSetWindowIcon</code> function, was crashing:</p><pre><code>Test [76/135] Window.test &quot;setIcon&quot;... Illegal instruction at address 0x2cee09
upstream/glfw/src/x11_window.c:0:0: 0x2cee09 in _glfwPlatformSetWindowIcon (/mach/glfw/upstream/glfw/src/x11_window.c)
upstream/glfw/src/window.c:511:5: 0x2de484 in glfwSetWindowIcon (/mach/glfw/upstream/glfw/src/window.c)
    _glfwPlatformSetWindowIcon(window, count, images);
    ^
/mach/glfw/src/Window.zig:508:28: 0x23a083 in Window.test &quot;setIcon&quot; (test)
        c.glfwSetWindowIcon(self.handle, @intCast(c_int, im.len), &amp;tmp[0]);
                           ^
/usr/local/bin/lib/std/special/test_runner.zig:77:28: 0x25a0d1 in std.special.main (test)
        } else test_fn.func();
                           ^
/usr/local/bin/lib/std/start.zig:517:22: 0x2896bc in std.start.callMain (test)
            root.main();
                     ^
/usr/local/bin/lib/std/start.zig:469:12: 0x25c117 in std.start.callMainWithArgs (test)
    return @call(.{ .modifier = .always_inline }, callMain, .{});
           ^
/usr/local/bin/lib/std/start.zig:434:12: 0x25bec2 in std.start.main (test)
    return @call(.{ .modifier = .always_inline }, callMainWithArgs, .{ @intCast(usize, c_argc), c_argv, envp });
           ^
???:?:?: 0x7f4b7c3280b2 in ??? (???)
</code></pre><p>That&rsquo;s odd? <code>Illegal instruction at address 0x2cee09</code> - are we corrupting the stack somehow? Is this a Zig compiler bug?</p><p>Running in <code>lldb</code> didn&rsquo;t help with shining any light on the problem, either:</p><p><a href=https://user-images.githubusercontent.com/3173176/139576146-775371fd-8003-46ba-aa30-8b81a2f22ce0.png><img alt="lldb showing nothing particularly useful" class=color src=https://user-images.githubusercontent.com/3173176/139576146-775371fd-8003-46ba-aa30-8b81a2f22ce0.png></a></p><p>After poking around at the stack, checking all pointers and lengths were valid, etc. I was at a loss. The mach-glfw code <em>sure seemed valid</em>, and yet, this crash. I managed to track the crash down to the first iteration of a loop in GLFW&rsquo;s <code>x11_window.c</code>:</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=kt>void</span> <span class=nf>_glfwSetWindowIconX11</span><span class=p>(</span><span class=n>_GLFWwindow</span><span class=o>*</span> <span class=n>window</span><span class=p>,</span> <span class=kt>int</span> <span class=n>count</span><span class=p>,</span> <span class=k>const</span> <span class=n>GLFWimage</span><span class=o>*</span> <span class=n>images</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>count</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=kt>int</span> <span class=n>longCount</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>

        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>  <span class=n>i</span> <span class=o>&lt;</span> <span class=n>count</span><span class=p>;</span>  <span class=n>i</span><span class=o>++</span><span class=p>)</span>
            <span class=n>longCount</span> <span class=o>+=</span> <span class=mi>2</span> <span class=o>+</span> <span class=n>images</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>width</span> <span class=o>*</span> <span class=n>images</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>height</span><span class=p>;</span>

        <span class=kt>long</span><span class=o>*</span> <span class=n>icon</span> <span class=o>=</span> <span class=n>_glfw_calloc</span><span class=p>(</span><span class=n>longCount</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>long</span><span class=p>));</span>
        <span class=kt>long</span><span class=o>*</span> <span class=n>target</span> <span class=o>=</span> <span class=n>icon</span><span class=p>;</span>

        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>  <span class=n>i</span> <span class=o>&lt;</span> <span class=n>count</span><span class=p>;</span>  <span class=n>i</span><span class=o>++</span><span class=p>)</span>
        <span class=p>{</span>
            <span class=o>*</span><span class=n>target</span><span class=o>++</span> <span class=o>=</span> <span class=n>images</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>width</span><span class=p>;</span>
            <span class=o>*</span><span class=n>target</span><span class=o>++</span> <span class=o>=</span> <span class=n>images</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>height</span><span class=p>;</span>

            <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>  <span class=n>j</span> <span class=o>&lt;</span> <span class=n>images</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>width</span> <span class=o>*</span> <span class=n>images</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>height</span><span class=p>;</span>  <span class=n>j</span><span class=o>++</span><span class=p>)</span>
            <span class=p>{</span>
                <span class=c1>// illegal instruction on first iteration?
</span><span class=c1></span>                <span class=o>*</span><span class=n>target</span><span class=o>++</span> <span class=o>=</span> <span class=p>(</span><span class=n>images</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>pixels</span><span class=p>[</span><span class=n>j</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>0</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=mi>16</span><span class=p>)</span> <span class=o>|</span>
                            <span class=p>(</span><span class=n>images</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>pixels</span><span class=p>[</span><span class=n>j</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=o>&lt;&lt;</span>  <span class=mi>8</span><span class=p>)</span> <span class=o>|</span>
                            <span class=p>(</span><span class=n>images</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>pixels</span><span class=p>[</span><span class=n>j</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>2</span><span class=p>]</span> <span class=o>&lt;&lt;</span>  <span class=mi>0</span><span class=p>)</span> <span class=o>|</span>
                            <span class=p>(</span><span class=n>images</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>pixels</span><span class=p>[</span><span class=n>j</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>3</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=mi>24</span><span class=p>);</span>
            <span class=p>}</span>
        <span class=p>}</span>
<span class=p>...</span>
</code></pre></div><h2 id=reaching-my-limits>Reaching my limits</h2><p>At this point, I feel confident in saying:</p><ul><li>The Zig code is correct, the pointers are valid, the lengths are correct, everything&rsquo;s right.</li><li>The GLFW code is pretty popular, and it&rsquo;s been around for 6 years. Seems unlikely it&rsquo;s a bug in GLFW?</li></ul><p>Luckily, my brother (and reverse engineer) <a href=https://github.com/Andoryuuta>@Andoryuuta</a> was available to help debug, so I pulled him in. Stepping through instructions, we could see clearly that after a bit shift we were stepping into the abyss:</p><pre><code>* thread #1, name = 'test', stop reason = instruction step over
    frame #0: 0x00000000002c6f84 test`_glfwPlatformSetWindowIcon(window=0x00000000004e53d0, count=1, images=0x00007fffec0b3000) at x11_window.c:2156:58
   2153	                *target++ = (images[i].pixels[j * 4 + 0] &lt;&lt; 16) |
   2154	                            (images[i].pixels[j * 4 + 1] &lt;&lt;  8) |
   2155	                            (images[i].pixels[j * 4 + 2] &lt;&lt;  0) |
-&gt; 2156	                            (images[i].pixels[j * 4 + 3] &lt;&lt; 24);
   2157	                printf(&quot;DID WE GET HERE???x\n&quot;);
   2158	            }
   2159	        }
(lldb) 
Process 6516 stopped
* thread #1, name = 'test', stop reason = instruction step over
    frame #0: 0x00000000002c6c21 test`_glfwPlatformSetWindowIcon(window=0x00000000004e53d0, count=1, images=0x00007fffec0b3000) at x11_window.c:0
   1   	//========================================================================
   2   	// GLFW 3.3 X11 - www.glfw.org
   3   	//------------------------------------------------------------------------
   4   	// Copyright (c) 2002-2006 Marcus Geelnard
   5   	// Copyright (c) 2006-2019 Camilla Löwy &lt;elmindreda@glfw.org&gt;
   6   	//
   7   	// This software is provided 'as-is', without any express or implied
(lldb) 
Process 6516 stopped
</code></pre><p>Inspecting the binary in IDA Pro we were able to see that we were jumping into an <code>__asm { ud1 }</code> section (ud1 standing for &ldquo;undefined instruction 1&rdquo;):</p><p><a href=https://user-images.githubusercontent.com/3173176/139594073-b2159e4c-6764-44b1-882d-802724f424e8.png><img alt="IDA Pro showing a jump to an undefined instruction 1" class=color src=https://user-images.githubusercontent.com/3173176/139594073-b2159e4c-6764-44b1-882d-802724f424e8.png></a></p><p>It turns out that clang&rsquo;s UBSan inserts these instructions as traps for when the compiler thinks there is undefined behavior occurring, such as if a pointer addition leads to an overflow. This is super interesting, but unfortunately doesn&rsquo;t always give a compiler error. We got lucky and found someone else who ran into this through Google:</p><blockquote><p>I <em>believe</em> LLVM explicitly generates a ud2 x86 instruction because "it determined" there's undefined behavior in the C code. So first I wonder which flags you're passing it through zig (i.e. how strict are you being with the settings?)</p>— Abner (@AbnerCoimbre) <a href=https://twitter.com/AbnerCoimbre/status/1339396987100168192>December 17, 2020</a></p></blockquote><p>And indeed, compiling via <code>zig build test -Drelease-fast</code> (which turns off UBsan) made the crash go away. So where&rsquo;s the undefined behavior?</p><p>If we squint at the code and assume all pointers, counts, and indices are correct, you might be able to spot it:</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=kt>void</span> <span class=nf>_glfwSetWindowIconX11</span><span class=p>(</span><span class=n>_GLFWwindow</span><span class=o>*</span> <span class=n>window</span><span class=p>,</span> <span class=kt>int</span> <span class=n>count</span><span class=p>,</span> <span class=k>const</span> <span class=n>GLFWimage</span><span class=o>*</span> <span class=n>images</span><span class=p>)</span>
<span class=p>{</span>
    <span class=p>...</span>
        <span class=kt>long</span><span class=o>*</span> <span class=n>target</span> <span class=o>=</span> <span class=n>icon</span><span class=p>;</span>

        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>  <span class=n>i</span> <span class=o>&lt;</span> <span class=n>count</span><span class=p>;</span>  <span class=n>i</span><span class=o>++</span><span class=p>)</span>
        <span class=p>{</span>
            <span class=p>...</span>
            <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>  <span class=n>j</span> <span class=o>&lt;</span> <span class=n>images</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>width</span> <span class=o>*</span> <span class=n>images</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>height</span><span class=p>;</span>  <span class=n>j</span><span class=o>++</span><span class=p>)</span>
            <span class=p>{</span>
                <span class=c1>// illegal instruction on first iteration?
</span><span class=c1></span>                <span class=o>*</span><span class=n>target</span><span class=o>++</span> <span class=o>=</span> <span class=p>(</span><span class=n>images</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>pixels</span><span class=p>[</span><span class=n>j</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>0</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=mi>16</span><span class=p>)</span> <span class=o>|</span>
                            <span class=p>(</span><span class=n>images</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>pixels</span><span class=p>[</span><span class=n>j</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=o>&lt;&lt;</span>  <span class=mi>8</span><span class=p>)</span> <span class=o>|</span>
                            <span class=p>(</span><span class=n>images</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>pixels</span><span class=p>[</span><span class=n>j</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>2</span><span class=p>]</span> <span class=o>&lt;&lt;</span>  <span class=mi>0</span><span class=p>)</span> <span class=o>|</span>
                            <span class=p>(</span><span class=n>images</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>pixels</span><span class=p>[</span><span class=n>j</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>3</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=mi>24</span><span class=p>);</span>
            <span class=p>}</span>
        <span class=p>}</span>
<span class=p>...</span>
</code></pre></div><p>What is happening here is that:</p><ul><li><code>images[i].pixels[j * 4 + 0]</code> is returning an <code>unsigned char</code> (8 bits)</li><li><del>It is then being shifted left by <code>&lt;&lt; 16</code> bits. !!! That&rsquo;s further than an 8-bit number can be shifted left by, so that&rsquo;s UB</del><ul><li>EDIT: Actually, it turns out that&rsquo;s not exactly right, it&rsquo;s the <code>&lt;&lt; 24</code> that&rsquo;s the cause of the UB, thanks <a href=https://github.com/Maato>@Maato</a> for <a href=https://github.com/glfw/glfw/pull/1986#issuecomment-955784179>pointing this out and explaining in better detail than I could</a>.</li></ul></li></ul><p>Suddenly, it all makes sense. And <a href=https://godbolt.org/z/ddq75WsYK>if we load an equal snippet of code into Godbolt</a> we can see what is happening when we compile without UBSan / the <code>-fsanitize=undefined</code> flag:</p><p><a href=https://user-images.githubusercontent.com/3173176/139594650-eff35347-3f32-42e5-bc60-da2a1dceb1e1.png><img alt="Compilation with godbolt with UBSan turned off shows movement into 32-bit EAX register" class=color src=https://user-images.githubusercontent.com/3173176/139594650-eff35347-3f32-42e5-bc60-da2a1dceb1e1.png></a></p><p>Without UBsan, clang merely uses the 32-bit EAX register as an optimization. It loads the 8-bit number into the 32-bit register, and then performs the left shift. Although the shift exceeds 8 bits, it <em>does not get truncated to zero</em> - instead it is effectively as if the number was converted to a <code>long</code> (32 bits) prior to the left-shift operation.</p><p>This explains why nobody has caught this UB in GLFW yet, too: it works by accident! Just because the compiler likes to use 32-bit registers in this context.</p><p>And this change benefits all the languages out there using GLFW: <a href=https://github.com/glfw/glfw/pull/1986>glfw/glfw#1986</a></p><h2 id=defaults-are-_critical_>Defaults are <em>critical</em></h2><p>This code, and undefined behavior, has been in GLFW for over 6 years according to <code>git blame</code>.</p><p>Anybody using GLFW <em>could have</em> enabled UBSan in their C compiler. Anybody <em>could have</em> run into this same crash and debugged it in the last 6 years. But they didn&rsquo;t.</p><p>In mach-glfw, we compile all of GLFW&rsquo;s C code with Zig (which is also a fully functional C and C++ compiler), with UBSan enabled by default.</p><p>Only because Zig has good defaults, because it places so much emphasis on things being right <em>out of the box</em>, and because there is such an emphasis on having safety checks for undefined behavior - were we able to catch this undefined behavior that went unnoticed in GLFW for the last 6 years.</p><h2 id=thanks-for-reading>Thanks for reading</h2><p>All key Mach engine developments will be posted here, with incremental updates on Twitter <a href=https://twitter.com/machengine>@machengine</a>.</p><p>Follow <a href=https://github.com/hexops/mach>Mach engine on GitHub</a>, and if you like what I&rsquo;m doing please consider <a href=https://github.com/sponsors/slimsag>sponsoring my work</a>.</p></div></main><script>function addAnchor(a){a.insertAdjacentHTML('afterbegin',`<a href="#${a.id}" class="hanchor" ariaLabel="Anchor">#</a> `)}document.addEventListener('DOMContentLoaded',function(){var a=document.querySelectorAll('h1[id], h2[id], h3[id], h4[id]');a&&a.forEach(addAnchor)})</script></div><div class=footer><div class=row-1><a href=https://hexops.com/privacy>Privacy matters</a>
<a href=https://github.com/sponsors/slimsag>Sponsor on GitHub</a>
<a href=https://machengine.org>machengine.org</a></div><div class=row-2><a href=/feed.xml><img alt="RSS feed" src="https://shields.io/badge/RSS-follow-green?logo=RSS"></a></div><div class=row-3><a href=https://hexops.com><img class="logo color-auto" alt="Hexops logo" src=https://raw.githubusercontent.com/hexops/media/234e15f265b19743c580a078b2d68660c92675d4/logo.svg height=50px></a></div></div></body></html>