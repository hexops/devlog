<!doctype html><html><head><link rel=stylesheet href=https://devlog.hexops.com/assets/font/stylesheet.css><link rel=stylesheet href=https://devlog.hexops.com/main.8de7c8e396a7e07ebc8c5ab76a8cda13267f823867d43c5b9bdde8b10d3cc1e8.css><script async defer data-domain=hexops.com src=https://hexops.com/opendata.js></script><meta charset=utf-8><title>Unicode sorting is hard & why browsers added special emoji matching to regexp | Hexops' devlog</title><link rel=canonical href=https://devlog.hexops.com/2021/unicode-sorting-why-browsers-added-special-emoji-matching/><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><meta property="og:title" content="Unicode sorting is hard & why browsers added special emoji matching to regexp"><meta property="og:description" content="As I work on Zorex, an omnipotent regexp engine I have stumbled into a world of tales about why Unicode text sorting is so annoying in the modern day. Let's talk about that."><meta property="og:type" content="article"><meta property="og:url" content="https://devlog.hexops.com/2021/unicode-sorting-why-browsers-added-special-emoji-matching/"><meta property="article:section" content="2021"><meta property="article:published_time" content="2021-06-27T00:00:00+00:00"><meta property="article:modified_time" content="2021-06-27T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Unicode sorting is hard & why browsers added special emoji matching to regexp"><meta name=twitter:description content="As I work on Zorex, an omnipotent regexp engine I have stumbled into a world of tales about why Unicode text sorting is so annoying in the modern day. Let's talk about that."></head><body><div class=navbar><div class=content><a href=/ class=logo><img src=https://raw.githubusercontent.com/hexops/media/main/logo.svg>' devlog</a><div><a href=https://hexops.com/about class=item>About</a>
<a href=/archives class=item>Archives</a>
<a href=https://github.com/hexops class=item>GitHub</a></div></div></div><div id=content><main aria-role=main class=main-single><div class=single><header class=header><h1>Unicode sorting is hard & why browsers added special emoji matching to regexp</h1><div class=metadata><time>June 27, 2021</time>
• <a class=category href=/categories/zig>zig</a>
• <a class=category href=/categories/unicode>unicode</a>
• <a class=category href=/categories/regex>regex</a></div></header><p>As I work on <a href=https://github.com/hexops/zorex>Zorex, an omnipotent regexp engine</a> I have stumbled into a world of tales about why Unicode text sorting is so annoying in the modern day. Let&rsquo;s talk about that.</p><ul><li><a href=#why-ascii-sorting-is-not-enough>Why ASCII sorting is not enough</a></li><li><a href=#twitters-emoji-problem---or-when-unicode-locale-aware-sorting-really-matters>Twitter&rsquo;s emoji problem - or when Unicode locale-aware sorting Really Matters™</a></li><li><a href=#browsers-added-special-emoji-matching-to-regexp>Browsers added special emoji matching to regexp</a></li><li><a href=#language-comparison>Language comparison</a><ul><li><a href=#javascript-collator-sorting-is-not-guaranteed-across-browsers>JavaScript Collator sorting is not guaranteed across browsers</a></li></ul></li><li><a href=#go-sortstrings-is-not-locale-aware>Go sort.Strings is not locale aware</a><ul><li><a href=#rust-vec-sorting-is-not-locale-aware>Rust Vec sorting is not locale aware</a></li><li><a href=#swifts-default-is-not-locale-aware-but-unicode-support-is-notable>Swift&rsquo;s default is not locale aware, but unicode support is notable</a></li></ul></li><li><a href=#zigs-ziglyph-package>Zig&rsquo;s ziglyph package</a></li><li><a href=#why-is-localized-text-sorting-hard>Why is localized text sorting hard?</a></li><li><a href=#webassembly-may-make-things-worse>WebAssembly may make things worse?</a></li></ul><h2 id=why-ascii-sorting-is-not-enough>Why ASCII sorting is not enough</h2><p>Perhaps you are sorting strings in JavaScript like this:</p><div class=highlight><pre class=chroma><code class=language-javascript data-lang=javascript><span class=kr>const</span> <span class=nx>words</span> <span class=o>=</span> <span class=p>[</span><span class=s1>&#39;Bears&#39;</span><span class=p>,</span> <span class=s1>&#39;Beetle&#39;</span><span class=p>,</span> <span class=s1>&#39;kiss&#39;</span><span class=p>,</span> <span class=s1>&#39;Similar&#39;</span><span class=p>,</span> <span class=s1>&#39;Apples&#39;</span><span class=p>];</span>
<span class=nx>words</span><span class=p>.</span><span class=nx>sort</span><span class=p>();</span>
<span class=c1>// [ &#34;Apples&#34;, &#34;Bears&#34;, &#34;Beetle&#34;, &#34;Similar&#34;, &#34;kiss&#34; ]
</span></code></pre></div><p>And that works pretty well, until someone translates it to German:</p><div class=highlight><pre class=chroma><code class=language-javascript data-lang=javascript><span class=kr>const</span> <span class=nx>words</span> <span class=o>=</span> <span class=p>[</span><span class=s1>&#39;Bären&#39;</span><span class=p>,</span> <span class=s1>&#39;Käfer&#39;</span><span class=p>,</span> <span class=s1>&#39;küssen&#39;</span><span class=p>,</span> <span class=s1>&#39;Ähnlich&#39;</span><span class=p>,</span> <span class=s1>&#39;Äpfel&#39;</span><span class=p>];</span>
<span class=nx>words</span><span class=p>.</span><span class=nx>sort</span><span class=p>();</span>
<span class=c1>// [ &#34;Bären&#34;, &#34;Käfer&#34;, &#34;küssen&#34;, &#34;Ähnlich&#34;, &#34;Äpfel&#34; ]
</span></code></pre></div><p>The preferred alphabetical sorting would be <code>[ "Ähnlich", "Äpfel", "Bären", "Käfer", "küssen" ]</code> - <code>Array.sort</code> doesn&rsquo;t do that.</p><p>That is because it is sorting lexicographically by byte values in the string, and not taking into account locales.</p><h2 id=twitters-emoji-problem---or-when-unicode-locale-aware-sorting-really-matters>Twitter&rsquo;s emoji problem - or when Unicode locale-aware sorting Really Matters™</h2><p>Twitter is <a href=https://9to5google.com/2018/05/21/twitter-android-emoji-updates/>no stranger to issues with emojis</a>, but have you ever thought about how they check if a hashtag contains only legal characters and emojis? Regexp, of course!</p><p>You might think one could just use a regexp unicode character class, like <code>[\u{1f300}-\u{1f5ff}]</code> - but that only covers a single codepoint! Emojis and other text rely on combining multiple Unicode codepoints to compose <em>grapheme clusters</em> - and often what we see as a single visible character on our screen.</p><p>The full regexp needed to match all emojis with codepoints would be:</p><pre><code class=language-regexp data-lang=regexp>(?:\ud83e\uddd1\ud83c\udffb\u200d\u2764\ufe0f\u200d\ud83d\udc8b\u200d\ud83e\uddd1\ud83c\udffc|\ud83e\uddd1\ud83c\udffb\u200d\u2764\ufe0f\u200d\ud83d
[102,816 characters omitted]
</code></pre><p>For your sake, I&rsquo;ve omitted the other 102,816 characters of that regexp. You can view it here: <a href=https://regex101.com/r/2ia4m2/7>https://regex101.com/r/2ia4m2/7</a></p><h2 id=browsers-added-special-emoji-matching-to-regexp>Browsers added special emoji matching to regexp</h2><p>Luckily for Twitter and others, ECMAScript&rsquo;s <a href=https://github.com/tc39/proposal-regexp-unicode-property-escapes>TC39 proposal a few years back</a> extended the regexp engine to support Unicode property escapes for emojis and a few other Unicode properties so you can write e.g.:</p><pre><code class=language-regexp data-lang=regexp>\p{Emoji_Presentation}
</code></pre><p>Without packing several thousand bytes of Unicode data tables or regexp into your JS bundle.</p><h2 id=language-comparison>Language comparison</h2><p>As <a href=https://lemire.me/blog/2018/12/17/sorting-strings-properly-is-stupidly-hard/>Daniel Lemire said</a>: <em>sorting strings is stupidly hard</em>.</p><h3 id=javascript-collator-sorting-is-not-guaranteed-across-browsers>JavaScript Collator sorting is not guaranteed across browsers</h3><p>You may have found browser&rsquo;s <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare><code>String.prototype.localCompare</code></a> or <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Collator><code>Intl.Collator</code></a> and they <strong>DO</strong> fix the issue<a href=https://ourcodeworld.com/articles/read/958/how-to-sort-an-array-of-strings-alphabetically-with-special-characters-properly-with-javascript>[1]</a>:</p><pre><code>const words = ['Bären', 'Käfer', 'küssen', 'Ähnlich', 'Äpfel'];
words.sort(Intl.Collator().compare);
// [ &quot;Ähnlich&quot;, &quot;Äpfel&quot;, &quot;Bären&quot;, &quot;Käfer&quot;, &quot;küssen&quot; ]
</code></pre><p>(note, however, you may wish to use <code>Intl.Collator('de').compare</code> instead to sort according to German language customs)</p><p>However, beware that if you look at <a href=https://tc39.es/ecma402/#sec-collator-comparestrings>the ECMA spec</a> for this you will find:</p><blockquote><p>It is <strong>recommended</strong> that the CompareStrings abstract operation be implemented following Unicode Technical Standard 10, Unicode Collation Algorithm [&mldr;]</p><p>Applications should not assume that the behaviour of the CompareStrings abstract operation for Collator instances with the same resolved options will remain the same for different versions of the same implementation.</p></blockquote><p>Although many browsers may produce similar sorting results - not all will. For one thing, not all locales are available across browsers.</p><p>Further, different browsers may choose to sort things differently. For example IE 11 sorting &ldquo;co-op&rdquo; after &ldquo;coop&rdquo; while other browsers do the opposite.<a href=https://stackoverflow.com/questions/33919257/sorting-strings-with-punctuation-using-intl-collator-is-inconsistent-across-brow>[2]</a></p><h2 id=go-sortstrings-is-not-locale-aware>Go sort.Strings is not locale aware</h2><p>It may be interesting to note that Go&rsquo;s <code>sort.Strings</code> operates on byte comparisons, and has the same issue as JavaScript&rsquo;s <code>Array.prototype.sort</code>:</p><div class=highlight><pre class=chroma><code class=language-Go data-lang=Go><span class=nx>words</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;Bären&#34;</span><span class=p>,</span> <span class=s>&#34;Käfer&#34;</span><span class=p>,</span> <span class=s>&#34;küssen&#34;</span><span class=p>,</span> <span class=s>&#34;Ähnlich&#34;</span><span class=p>,</span> <span class=s>&#34;Äpfel&#34;</span><span class=p>}</span>	
<span class=nx>sort</span><span class=p>.</span><span class=nf>Strings</span><span class=p>(</span><span class=nx>words</span><span class=p>)</span>
<span class=c1>// [Bären Käfer küssen Ähnlich Äpfel]
</span></code></pre></div><p>One can easily perform unicode code point (rune) sorting in Go, which would fix the above example - but note that rune sorting is not locale-aware, and importantly that <a href=https://www.reddit.com/r/golang/comments/o1o5hr/fyi_a_single_go_rune_is_not_the_same_as_a_single>a Go rune is not the same as a visible character</a> and would not take into account grapheme clusters.</p><p>For proper Unicode locale-aware sorting in Go, you need to use the Unicode Collation Algorithm via <a href=https://pkg.go.dev/golang.org/x/text/collate>golang.org/x/text/collate</a> but be sure to also apply normalization to your text first via <a href=https://pkg.go.dev/golang.org/x/text@v0.3.6/unicode/norm>golang.org/x/text/unicode/norm</a></p><h3 id=rust-vec-sorting-is-not-locale-aware>Rust Vec sorting is not locale aware</h3><p>A Rust <code>Vec</code> of strings implements sorting<a href=https://doc.rust-lang.org/std/primitive.str.html#impl-Ord>[3]</a> lexicographically by their byte values, consistent with Go&rsquo;s <code>sort.Strings</code> and JavaScripts <code>Array.prototype.sort</code>:</p><pre><code>let mut vec = Vec::new();
vec.push(&quot;Bären&quot;);
vec.push(&quot;Käfer&quot;);
vec.push(&quot;küssen&quot;);
vec.push(&quot;Ähnlich&quot;);
vec.sort(&quot;Äpfel&quot;);
println!(&quot;{:?}&quot;, vec);
// [&quot;Bären&quot;, &quot;Käfer&quot;, &quot;küssen&quot;, &quot;Ähnlich&quot;, &quot;Äpfel&quot;]
</code></pre><p>Locale-aware sorting in Rust is provided <a href=https://github.com/google/rust_icu>by ICU4C bindings by Google, google/rust_icu</a> (note however, there have been a number of <a href=https://github.com/rust-lang/rust/issues/14656#issuecomment-45164318>vulnerabilities in the ICU4C library</a>) and there is ongoing work to implement internationalization in pure Rust as a safer alternative: <a href=https://github.com/unicode-org/icu4x>unicode-org/icu4x</a>.</p><h3 id=swifts-default-is-not-locale-aware-but-unicode-support-is-notable>Swift&rsquo;s default is not locale aware, but unicode support is notable</h3><p>Swift remains consistent with other languages in sorting strings lexicographically by byte value:</p><div class=highlight><pre class=chroma><code class=language-swift data-lang=swift><span class=kd>var</span> <span class=nv>words</span> <span class=p>=</span> <span class=p>[</span><span class=s>&#34;Bären&#34;</span><span class=p>,</span> <span class=s>&#34;Käfer&#34;</span><span class=p>,</span> <span class=s>&#34;küssen&#34;</span><span class=p>,</span> <span class=s>&#34;Ähnlich&#34;</span><span class=p>,</span> <span class=s>&#34;Äpfel&#34;</span><span class=p>]</span>
<span class=n>words</span><span class=p>.</span><span class=bp>sort</span><span class=p>()</span>
<span class=c1>// [&#34;Bären&#34;, &#34;Käfer&#34;, &#34;küssen&#34;, &#34;Ähnlich&#34;, &#34;Äpfel&#34;]</span>
</code></pre></div><p>However, it is notable that Swift includes locale sensitive sorting out of the box<a href=https://sarunw.com/posts/different-ways-to-sort-array-of-strings-in-swift/>[4]</a>:</p><div class=highlight><pre class=chroma><code class=language-swift data-lang=swift><span class=kd>var</span> <span class=nv>words</span> <span class=p>=</span> <span class=p>[</span><span class=s>&#34;Bären&#34;</span><span class=p>,</span> <span class=s>&#34;Käfer&#34;</span><span class=p>,</span> <span class=s>&#34;küssen&#34;</span><span class=p>,</span> <span class=s>&#34;Ähnlich&#34;</span><span class=p>,</span> <span class=s>&#34;Äpfel&#34;</span><span class=p>]</span>
<span class=kd>let</span> <span class=nv>sorted</span> <span class=p>=</span> <span class=n>words</span><span class=p>.</span><span class=bp>sorted</span> <span class=p>{</span> <span class=p>(</span><span class=n>lhs</span><span class=p>:</span> <span class=nb>String</span><span class=p>,</span> <span class=n>rhs</span><span class=p>:</span> <span class=nb>String</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=nb>Bool</span> <span class=k>in</span>    
    <span class=k>return</span> <span class=n>lhs</span><span class=p>.</span><span class=n>localizedStandardCompare</span><span class=p>(</span><span class=n>rhs</span><span class=p>)</span> <span class=p>==</span> <span class=p>.</span><span class=n>orderedAscending</span>
<span class=p>}</span>
<span class=c1>// [&#34;Ähnlich&#34;, &#34;Äpfel&#34;, &#34;Bären&#34;, &#34;Käfer&#34;, &#34;küssen&#34;]</span>
</code></pre></div><p>It also seems quite notable just <a href=https://developer.apple.com/documentation/swift/string>how very unicode-aware the Swift documentation is on their String type</a>. Other languages could learn a thing or two here in educating developers.</p><h2 id=zigs-ziglyph-package>Zig&rsquo;s ziglyph package</h2><p>Zig&rsquo;s standard library is still quite under development, however it seems likely that major unicode functionality will be outside the stdlib.</p><p>Luckily, <a href=https://github.com/jecolon>@jecolon</a> in the Zig community is working on an excellent package for this: <a href=https://github.com/jecolon/ziglyph>ziglyph</a>.</p><p>I mention this because I&rsquo;m a fan of the language and have recently begun contributing to that package; but otherwise Zig isn&rsquo;t any different than other languages listed here aside from there being no real &ldquo;default&rdquo; way to sort strings from what I know.</p><h2 id=why-is-localized-text-sorting-hard>Why is localized text sorting hard?</h2><p>I believe there are a combination of factors at play:</p><ul><li>Most languages leave Unicode locale-aware text sorting as an afterthought.</li><li>Most developers don&rsquo;t care enough to use Unicode, let alone implement locale-aware text sorting. Internationalization is always &ldquo;that thing we&rsquo;ll do if somebody complains&rdquo; or an afterthought.</li><li>It&rsquo;s hard. It wasn&rsquo;t until recently that we got semi-decent support for it across browsers, and what is there still leaves a lot to be desired.</li><li>Many are still running into dated software, like NodeJS versions from ~2019 ish that <a href=https://github.com/nodejs/node/issues/19214>didn&rsquo;t have full ICU support on by default</a>.</li></ul><h2 id=webassembly-may-make-things-worse>WebAssembly may make things worse?</h2><p>As a closing thought, I just want to hint at why I think WebAssembly will make things worse before they get better.</p><p>Whether your application is in Go and has it&rsquo;s own Unicode Collation Algorithm (UCA) implementation, or Rust and uses bindings to the popular ICU4C library - one thing is going to remain true: it requires large data files to work.</p><p>The UCA algorithm depends on two quite large data table files to work:</p><ul><li><a href=https://www.unicode.org/Public/9.0.0/ucd/UnicodeData.txt>UnicodeData.txt</a> for normalization, a step required before sorting can take place.</li><li><a href=http://www.unicode.org/Public/UCA/12.0.0/allkeys.txt>allkeys.txt</a> for weighting certain text above others.</li><li>And more, if you want truly locale-aware sorting and not just &ldquo;the default&rdquo; the UCA algorithm gives you.</li></ul><p>Together, these files can add up to over a half a megabyte.</p><p>While WASM languages could shell out to JavaScript browser APIs for collation, I suspect they won&rsquo;t due to the lack of guarantees around those APIs.</p><p>A more likely scenario is languages continuing to leave locale-aware sorting as an optional, opt-in feature - that also makes your application larger.</p><p>I think this a worthwhile problem to solve, so I am working on <a href=https://github.com/jecolon/ziglyph/issues/3>compression algorithms for these files specifically</a> in Zig to reduce them to only a few tens of kilobytes.</p></div></main><script>function addAnchor(a){a.insertAdjacentHTML('afterbegin',`<a href="#${a.id}" class="hanchor" ariaLabel="Anchor">#</a> `)}document.addEventListener('DOMContentLoaded',function(){var a=document.querySelectorAll('h1[id], h2[id], h3[id], h4[id]');a&&a.forEach(addAnchor)})</script></div><div class=footer><div class=row-1><a href=https://hexops.com/privacy>Privacy matters</a>
<a href=https://github.com/sponsors/slimsag>Sponsor on GitHub</a>
<a href=https://machengine.org>machengine.org</a></div><div class=row-2><a href=/feed.xml><img alt="RSS feed" src="https://shields.io/badge/RSS-follow-green?logo=RSS"></a></div><div class=row-3><a href=https://hexops.com><img class="logo color-inverted" alt="Hexops logo" src=https://raw.githubusercontent.com/hexops/media/main/logo.svg height=50px></a></div></div></body></html>