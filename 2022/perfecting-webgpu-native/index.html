<!doctype html><html><head><link rel=stylesheet href=https://devlog.hexops.com/assets/font/stylesheet.css><link rel=stylesheet href=https://devlog.hexops.com/main.959becff4f3640c2ba19521949a93832fa147f951930301c1c72e74e25823239.css><script async defer data-domain=hexops.com src=https://hexops.com/opendata.js></script><meta charset=utf-8><title>Perfecting WebGPU/Dawn native graphics for Zig | Hexops' devlog</title><link rel=canonical href=https://devlog.hexops.com/2022/perfecting-webgpu-native/><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><meta property="og:title" content="Perfecting WebGPU/Dawn native graphics for Zig"><meta property="og:description" content="A 700+ commit complete rewrite of mach/gpu (the WebGPU interface for Zig) has been completed, enabling seamless use of Dawn (Google Chrome's WebGPU implementation) for native Zig applications."><meta property="og:type" content="article"><meta property="og:url" content="https://devlog.hexops.com/2022/perfecting-webgpu-native/"><meta property="og:image" content="https://user-images.githubusercontent.com/3173176/184753919-1f368996-c681-49a0-994c-34590e5846aa.png"><meta property="article:section" content="2022"><meta property="article:published_time" content="2022-09-11T00:00:00+00:00"><meta property="article:modified_time" content="2022-09-11T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://user-images.githubusercontent.com/3173176/184753919-1f368996-c681-49a0-994c-34590e5846aa.png"><meta name=twitter:title content="Perfecting WebGPU/Dawn native graphics for Zig"><meta name=twitter:description content="A 700+ commit complete rewrite of mach/gpu (the WebGPU interface for Zig) has been completed, enabling seamless use of Dawn (Google Chrome's WebGPU implementation) for native Zig applications."></head><body><div class=navbar><div class=content><a href=/ class=logo><img src=https://raw.githubusercontent.com/hexops/media/234e15f265b19743c580a078b2d68660c92675d4/logo.svg>' devlog</a><div><a href=https://hexops.com/about class=item>About</a>
<a href=/archives class=item>Archives</a>
<a href=https://github.com/hexops class=item>GitHub</a></div></div></div><div id=content><main aria-role=main class=main-single><div class=single><header class=header><h1>Perfecting WebGPU/Dawn native graphics for Zig</h1><div class=metadata><time>September 11, 2022</time>
• <a class=category href=/categories/mach>mach</a>
• <a class=category href=/categories/zig>zig</a>
• <a class=category href=/categories/gamedev>gamedev</a>
• <a class=category href=/categories/graphics>graphics</a></div></header><picture><source srcset=https://raw.githubusercontent.com/hexops/media/839b04fa5a72428052733d2095726894ff93466a/gpu/logo_dark.svg media="(prefers-color-scheme: dark)"><img style=height:100px src=https://raw.githubusercontent.com/hexops/media/839b04fa5a72428052733d2095726894ff93466a/gpu/logo_light.svg></picture><p>We&rsquo;ve just finished a complete rewrite of <code>mach/gpu</code> (WebGPU/Dawn bindings for Zig), with 700+ commits, ~7.4k LOC, and 100% API coverage.</p><p>WebGPU (not to be confused with WebGL) is a modern graphics API, acting as a unified API to the underlying Vulkan/Metal/DirectX APIs. Despite it&rsquo;s name, it is also designed for use in native applications via its C API.</p><p>Dawn is the C++ implementation of WebGPU by Google, used in Chrome, planned to be shipped to millions of browsers in the not too distant future.</p><h2 id=machgpu-webgpu-for-zig><code>mach/gpu</code>: WebGPU for Zig</h2><p>6 months ago we <a href=/2022/mach-v0.1-zig-graphics-in-60s/>released Mach v0.1</a> which enabled the creation of native applications using WebGPU graphics in Zig:</p><img class=color style=max-height:300px src=https://user-images.githubusercontent.com/3173176/163936001-fd9eb918-7c29-4dcc-bfcb-5586f2ea1f9a.gif><p>It all Just Works™ out of the box in under ~60s - all you need is <code>zig</code>, <code>git</code>, and <code>curl</code>:</p><div class=highlight><pre class=chroma><code class=language-sh data-lang=sh>git clone https://github.com/hexops/mach
<span class=nb>cd</span> mach/
zig build run-example-boids
</code></pre></div><p><small>(requires Zig v0.10+, see <a href=https://github.com/hexops/mach/blob/main/doc/known-issues.md>known issues</a>.)</small></p><p>We do all the heavy-lifting behind the scenes for you: building Dawn using Zig as a C++ compiler, rewriting build scripts in Zig (so you don&rsquo;t need ninja/cmake/etc), package up all required dependencies so you don&rsquo;t need Google&rsquo;s <code>depot_tools</code>, and more.</p><p>Because of this, cross-compilation to every major desktop OS is available at the flip of a switch:</p><pre><code>$ zig build example-boids -Dtarget=x86_64-windows
$ zig build example-boids -Dtarget=x86_64-linux
$ zig build example-boids -Dtarget=x86_64-macos.12
$ zig build example-boids -Dtarget=aarch64-macos.12
</code></pre><p>But this is old news! We released this 6 months ago-so what&rsquo;s new since?</p><h2 id=zig--webgpu-showcase-10-examples>Zig + WebGPU showcase (10+ examples)</h2><p>The new <a href=https://machengine.org/gpu>Zig WebGPU demo showcase</a> has 12+ examples you can try on your own machine to begin learning Zig and WebGPU quickly:</p><video style=height:40rem autoplay loop controls>
<source src=https://user-images.githubusercontent.com/3173176/189518244-5a44ed7f-bb11-4c98-9a84-9fdc5613aec4.mp4 type=video/mp4></video><h2 id=mach-core-vs-mach-engine>Mach core vs. Mach engine</h2><p><img class=color-auto src=https://user-images.githubusercontent.com/3173176/184719710-ebae4fbd-af14-4b2f-80ad-11527c5f3e8f.png></p><p>Mach has a choose-your-journey development strategy, where you don&rsquo;t even have to adopt the entire engine to benefit from it. All the WebGPU examples we provide are <em>Mach core apps</em>: they rely on Mach for window creation, user input, and setting up the WebGPU API - nothing else. Using <em>Mach core</em>, you write your own engine!</p><p>Why use this over, say, GLFW and WebGPU on your own? The benefit is that this will work on Desktop, WebAssembly (soon), Mobile (future), and consoles (long term.) You can write Mach core apps in Zig, or other languages via <code>libmach</code> (more on this later.) Think of Mach core as <em>a competitor to SDL/GLFW.</em></p><p>In the future we&rsquo;ll offer <em>Mach engine</em> apps, where you buy into our ECS, Unity/Unreal-like editor, and other composable building-blocks that make up the engine at your choosing. But this isn&rsquo;t ready today.</p><h3 id=dawnwebgpu-on-the-steam-deck>Dawn/WebGPU on the Steam Deck</h3><p>We believe Linux should be a first-class platform, and because of this <a href=https://twitter.com/slimsag/status/1544858201849376768>we&rsquo;ve found</a> Mach all Just Works™ right out of the box on the Steam Deck (running natively as a Linux Vulkan application, no DirectX or Proton in the mix.):</p><div class=video-container><video autoplay loop muted src=https://user-images.githubusercontent.com/3173176/184556247-6e039490-99ee-48f4-91b4-d2cfd7a7f847.mp4></video></div><h2 id=a-complete-rewrite-of-machgpu-to-be-lean--mean>A complete rewrite of <code>mach/gpu</code> to be lean & mean</h2><p>When we wrote the initial WebGPU bindings for Zig 6+ months ago, our primary goal was just to get <em>something</em> working to where we could start building out examples: we always knew we&rsquo;d need to revisit things later, especially as Browser support, the use of native extensions in Dawn (like bindless support in the future, etc.), overhead & other aspects became clear.</p><p>We&rsquo;ve finally done that revisit in a month-long complete rewrite of <code>mach/gpu</code> from the ground up. This brings 700+ commits, zero-overhead bindings, Dawn native extensions, and much more. Here are the highlights.</p><h3 id=righting-our-wrongs-runtime-interfaces>Righting our wrongs: runtime interfaces</h3><p>One goal of <code>mach/gpu</code> is to be able to intercept WebGPU API calls, so that we can provide superior debugging facilities in the future (imagine record-and-replay, step-by-step debugging of WebGPU API calls, etc.)</p><p>In the old <code>mach/gpu</code>, we achieved this by wrapping each WebGPU API object that had methods (like textures, render pass encoders, etc.) in a <em>runtime interface</em> similar to Zig&rsquo;s <code>std.mem.Allocator</code> interface:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>pub</span><span class=w> </span><span class=kr>const</span><span class=w> </span><span class=n>Texture</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>/// The type erased pointer to the Texture implementation
</span><span class=c1></span><span class=w>    </span><span class=c1>/// Equal to c.WGPUTexture for NativeInstance.
</span><span class=c1></span><span class=w>    </span><span class=n>ptr</span><span class=o>:</span><span class=w> </span><span class=o>*</span><span class=n>anyopaque</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>vtable</span><span class=o>:</span><span class=w> </span><span class=o>*</span><span class=kr>const</span><span class=w> </span><span class=n>VTable</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>};</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=kr>pub</span><span class=w> </span><span class=kr>const</span><span class=w> </span><span class=n>VTable</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>destroy</span><span class=o>:</span><span class=w> </span><span class=k>fn</span><span class=w> </span><span class=p>(</span><span class=n>ptr</span><span class=o>:</span><span class=w> </span><span class=o>*</span><span class=n>anyopaque</span><span class=p>)</span><span class=w> </span><span class=kt>void</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=c1>// ...
</span><span class=c1></span><span class=p>};</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=kr>pub</span><span class=w> </span><span class=kr>inline</span><span class=w> </span><span class=k>fn</span><span class=w> </span><span class=n>destroy</span><span class=p>(</span><span class=n>tex</span><span class=o>:</span><span class=w> </span><span class=n>Texture</span><span class=p>)</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>tex</span><span class=p>.</span><span class=n>vtable</span><span class=p>.</span><span class=n>destroy</span><span class=p>(</span><span class=n>tex</span><span class=p>.</span><span class=n>ptr</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Our thought process was simply to follow any established patterns, learn what didn&rsquo;t work about it by writing examples, and then revisiting the API later. Even six months ago, though, we knew there were issues with this approach.</p><p><strong>The problem:</strong> In WebGPU, <code>Descriptor</code> data structures are often passed to methods: these fairly large data structures contain a wide range of options and graphics pipeline state to use, and often involve passing a list of WebGPU objects as a field - or nested field - as part of the Descriptor data structure. Because our <code>Texture</code> involves keeping a <code>ptr</code> (the interface implementation) and a <code>vtable</code> pointer (our implementation methods) it meant that a <code>gpu.Texture</code> was two pointers, while a C <code>WGPUTexture</code> was a single pointer - breaking ABI compatibility.</p><p>This meant that our <code>Texture</code> could not simply be passed to a C API expecting a <code>WGPUTexture</code>: instead, we needed to pass our <code>.ptr</code> field only. This had viral effects, though: every <code>Descriptor</code> struct which embedded a <code>Texture</code> needed to be copied/rewritten to convert our two-pointer <code>Texture</code> to a single-pointer <code>WGPUTexture</code>. Worse yet, some descriptors hold <em>dynamic arrays</em> of such objects, requiring us to <em>copy an array to a temporary (and worst-case, heap-allocated), buffer</em> just in order to call the actual WebGPU C API.</p><p>Needless to say, this was a cancer we felt we absolutely had to get rid of in the rewrite.</p><h3 id=comptime-interfaces>Comptime interfaces</h3><p>While we want to get rid of runtime interfaces, maintain C ABI compatability, and be zero-overhead-we&rsquo;d still like to be able to intercept WebGPU API calls if desired, so that we can provide superior debugging facilities in the future.</p><p>Zig&rsquo;s <code>std.mem.Allocator</code> being a <em>runtime interface</em> makes sense because they have different use cases, no existing ABI to remain compatible with, and importantly there are cases where you would want to have <strong>multiple allocator implementations</strong> in the same program for different purposes.</p><p>With WebGPU, we have different constraints: it&rsquo;s very unlikely to want multiple WebGPU implementations per program. We do need to maintain ABI compatibility. So to address this, we introduce a <em>comptime interface</em>.</p><p><img class=color-auto style=max-height:200px src=https://user-images.githubusercontent.com/3173176/184733061-92f1165d-8d20-4c97-8852-34b1abf5b655.png></p><p>Let&rsquo;s look at the <code>Texture.destroy</code> method from earlier:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>pub</span><span class=w> </span><span class=kr>inline</span><span class=w> </span><span class=k>fn</span><span class=w> </span><span class=n>destroy</span><span class=p>(</span><span class=n>tex</span><span class=o>:</span><span class=w> </span><span class=n>Texture</span><span class=p>)</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>tex</span><span class=p>.</span><span class=n>vtable</span><span class=p>.</span><span class=n>destroy</span><span class=p>(</span><span class=n>tex</span><span class=p>.</span><span class=n>ptr</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>As you can see, this would&rsquo;ve called the <em>tex.vtable pointer</em>, and passed the <code>tex.ptr</code> interface implementation pointer to it. It&rsquo;s a classical runtime interface implementation. The key point here is that the data type can remain the same, while the <em>implementation pointer</em> could be replaced at runtime with a different one. On the other side of this invocation, <code>tex.vtable.destroy</code> would look like this:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>pub</span><span class=w> </span><span class=k>fn</span><span class=w> </span><span class=n>destroy</span><span class=p>(</span><span class=n>ptr</span><span class=o>:</span><span class=w> </span><span class=o>*</span><span class=n>anyopaque</span><span class=p>)</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>c</span><span class=p>.</span><span class=n>wgpuTextureDestroy</span><span class=p>(</span><span class=nb>@ptrCast</span><span class=p>(</span><span class=n>c</span><span class=p>.</span><span class=n>WGPUTexture</span><span class=p>,</span><span class=w> </span><span class=n>ptr</span><span class=p>));</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Now let&rsquo;s look at how the <em>comptime interface</em> approach differs:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>pub</span><span class=w> </span><span class=kr>const</span><span class=w> </span><span class=n>Texture</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>opaque</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kr>pub</span><span class=w> </span><span class=kr>inline</span><span class=w> </span><span class=k>fn</span><span class=w> </span><span class=n>destroy</span><span class=p>(</span><span class=n>texture</span><span class=o>:</span><span class=w> </span><span class=o>*</span><span class=n>Texture</span><span class=p>)</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>Impl</span><span class=p>.</span><span class=n>textureDestroy</span><span class=p>(</span><span class=n>texture</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=c1>// ...
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Firstly, we see that <code>*gpu.Texture</code> is merely an opaque pointer (a C <code>void*</code> if you like), just the same as before. Unlike before, however, there is no vtable pointer: there is only one pointer, it&rsquo;s passed directly to the implementor via <code>Impl.textureDestroy</code> - and the implementation <em>cannot be changed at runtime</em>.</p><p>This solves the issue of ABI compatibility (we have only one pointer now), but we still need to let the user of the library - say from their <code>main.zig</code> file - decide which <code>Impl</code>ementation of the interface to use.</p><p>Traditionally, one might use generics for this (passing an <code>Impl</code> type parameter to each method for example), but we&rsquo;d rather not pass that around everywhere: after all, we know it will be decided by one user of the API for the entire program, and requiring a type parameter here would have viral effects to every user of the WebGPU API (every API they expose would need that same type parameter.)</p><p>Luckily, in Zig there is a trick: from within our WebGPU API we can import the root file of the program (e.g. <code>main.zig</code>). Zig allows this since it lazily evaluates code, so there&rsquo;s no dependency loop here. So in our <code>mach/gpu</code> package, we can define:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>pub</span><span class=w> </span><span class=kr>const</span><span class=w> </span><span class=n>Impl</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>blk</span><span class=o>:</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kr>const</span><span class=w> </span><span class=n>root</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>@import</span><span class=p>(</span><span class=s>&#34;root&#34;</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=nb>@hasDecl</span><span class=p>(</span><span class=n>root</span><span class=p>,</span><span class=w> </span><span class=s>&#34;GPUInterface&#34;</span><span class=p>))</span><span class=w> </span><span class=nb>@compileError</span><span class=p>(</span><span class=s>&#34;expected to find `pub const GPUInterface = T;` in root file&#34;</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=n>_</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>gpu</span><span class=p>.</span><span class=n>Interface</span><span class=p>(</span><span class=n>root</span><span class=p>.</span><span class=n>GPUInterface</span><span class=p>);</span><span class=w> </span><span class=c1>// verify the type
</span><span class=c1></span><span class=w>    </span><span class=k>break</span><span class=w> </span><span class=o>:</span><span class=n>blk</span><span class=w> </span><span class=n>root</span><span class=p>.</span><span class=n>GPUInterface</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=p>};</span><span class=w>
</span></code></pre></div><p>This effectively looks in the user&rsquo;s <code>main.zig</code> (&ldquo;root&rdquo;) file for a declaration like:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>pub</span><span class=w> </span><span class=kr>const</span><span class=w> </span><span class=n>GPUInterface</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>gpu</span><span class=p>.</span><span class=n>dawn</span><span class=p>.</span><span class=n>Interface</span><span class=p>;</span><span class=w>
</span></code></pre></div><p>Once resolved, our <code>Impl</code> constant is known statically at compile time to be an exact interface implementation of the <code>gpu.Interface</code>: <code>gpu.dawn.Interface</code> in this case, which is just a struct type with functions in it calling the Dawn C API:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>pub</span><span class=w> </span><span class=kr>const</span><span class=w> </span><span class=n>Interface</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kr>pub</span><span class=w> </span><span class=kr>inline</span><span class=w> </span><span class=k>fn</span><span class=w> </span><span class=n>textureDestroy</span><span class=p>(</span><span class=n>texture</span><span class=o>:</span><span class=w> </span><span class=o>*</span><span class=n>gpu</span><span class=p>.</span><span class=n>Texture</span><span class=p>)</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>procs</span><span class=p>.</span><span class=n>textureDestroy</span><span class=p>.</span><span class=o>?</span><span class=p>(</span><span class=nb>@ptrCast</span><span class=p>(</span><span class=n>c</span><span class=p>.</span><span class=n>WGPUTexture</span><span class=p>,</span><span class=w> </span><span class=n>texture</span><span class=p>));</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=c1>// ...
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>The trick here to ensuring that a type actually satisfies the <code>gpu.Interface</code> is that you write a type validator function, which checks if the struct passes to it has the desired methods with matching function signatures:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=c1>/// Verifies that a gpu.Interface implementation exposes the expected function declarations.
</span><span class=c1></span><span class=kr>pub</span><span class=w> </span><span class=k>fn</span><span class=w> </span><span class=n>Interface</span><span class=p>(</span><span class=kr>comptime</span><span class=w> </span><span class=n>T</span><span class=o>:</span><span class=w> </span><span class=kt>type</span><span class=p>)</span><span class=w> </span><span class=kt>type</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>assertDecl</span><span class=p>(</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=s>&#34;textureDestroy&#34;</span><span class=p>,</span><span class=w> </span><span class=k>fn</span><span class=w> </span><span class=p>(</span><span class=n>texture</span><span class=o>:</span><span class=w> </span><span class=o>*</span><span class=n>gpu</span><span class=p>.</span><span class=n>Texture</span><span class=p>)</span><span class=w> </span><span class=n>callconv</span><span class=p>(.</span><span class=n>Inline</span><span class=p>)</span><span class=w> </span><span class=kt>void</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=c1>// ...
</span><span class=c1></span><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>T</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=p>};</span><span class=w>
</span></code></pre></div><p>Best of all, since the interface implementation is completely static and known at comptime, we can enforce every method invocation is <code>inline</code> and we&rsquo;re not adding any overhead.</p><h3 id=libmach-and-gpuexport>libmach and gpu.Export</h3><p><img class=color-auto style=max-height:300px src=https://user-images.githubusercontent.com/3173176/184734447-b3df59dc-9b8c-453f-9f8e-2c01eb45e086.png></p><p>One recent development is <code>libmach</code>, which will provide at least a C ABI for the creation of <em>Mach core</em> applications from other languages (think a bit like SDL, but for WebGPU and it works on Desktop, Mobile, WebAssembly & more in the future.)</p><p>One thing we&rsquo;d like to retain, though, is the ability to have such applications get the same nice WebGPU debugging experience in the future, while still using that language&rsquo;s existing WebGPU bindings. This means instead of calling Dawn&rsquo;s <code>wgpuTextureDestroy</code> for example, we&rsquo;d need to call <code>libmach</code>&rsquo;s <code>wgpuTextureDestroy</code>.</p><p>This is where <code>gpu.Export</code> comes in: it merely takes a <code>gpu.Interface</code> struct with all of the Zig functions that implement the WebGPU API, and exports the WebGPU C ABI for them:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=c1>/// Exports C ABI function declarations for the given gpu.Interface implementation.
</span><span class=c1></span><span class=kr>pub</span><span class=w> </span><span class=k>fn</span><span class=w> </span><span class=n>Export</span><span class=p>(</span><span class=kr>comptime</span><span class=w> </span><span class=n>T</span><span class=o>:</span><span class=w> </span><span class=kt>type</span><span class=p>)</span><span class=w> </span><span class=kt>type</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>_</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Interface</span><span class=p>(</span><span class=n>T</span><span class=p>);</span><span class=w> </span><span class=c1>// verify implementation is a valid interface
</span><span class=c1></span><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=c1>// WGPU_EXPORT void wgpuTextureDestroy(WGPUTexture texture);
</span><span class=c1></span><span class=w>        </span><span class=kr>export</span><span class=w> </span><span class=k>fn</span><span class=w> </span><span class=n>wgpuTextureDestroy</span><span class=p>(</span><span class=n>texture</span><span class=o>:</span><span class=w> </span><span class=o>*</span><span class=n>gpu</span><span class=p>.</span><span class=n>Texture</span><span class=p>)</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>T</span><span class=p>.</span><span class=n>textureDestroy</span><span class=p>(</span><span class=n>texture</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=c1>// ...
</span><span class=c1></span><span class=w>    </span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>From this, you might notice something important: We&rsquo;ve maintained 100% C ABI compatability in the new <code>mach/gpu</code> rewrite. Every data structure is ABI compatible with Dawn&rsquo;s <code>webgpu.h</code> header.</p><h3 id=zig-flag-sets>Zig flag sets</h3><p>One nice property of Zig is it&rsquo;s <code>packed struct</code>s. For example, in C there is a <code>WGPUColorWriteMaskFlags</code> type which is a <code>uint32_t</code> where the first four bits represent a color write mask for red, green, blue, and alpha respectively. The remaining 28 bits are unused at present.</p><p><img class=color-auto style=max-height:300px src=https://user-images.githubusercontent.com/3173176/184735519-cc78d19d-73e8-4914-8f3d-fc3a15d00bb7.png></p><p>Interacting with <code>WGPUColorWriteMaskFlags</code> in C can be a bit cumbersome: you need to make sure you remember the right bit masking operations to set bits, check if they are set, and so on.</p><p>In Zig, we have <code>packed struct</code> in which <code>bool</code> is just one bit - and we have integers of any bit width we desire. We can use this to compose a 32-bit data structure compatible with the C ABI variant, but using nice bools to represent those first four bits:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>pub</span><span class=w> </span><span class=kr>const</span><span class=w> </span><span class=n>ColorWriteMaskFlags</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kr>packed</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>red</span><span class=o>:</span><span class=w> </span><span class=kt>bool</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>green</span><span class=o>:</span><span class=w> </span><span class=kt>bool</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>blue</span><span class=o>:</span><span class=w> </span><span class=kt>bool</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>alpha</span><span class=o>:</span><span class=w> </span><span class=kt>bool</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>,</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=n>_padding</span><span class=o>:</span><span class=w> </span><span class=n>u28</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>};</span><span class=w>
</span></code></pre></div><p>This is nice because now one can simply check <code>if (write_mask.red and write_mask.blue)</code> for example, or simply pass it as a parameter to a function like <code>ColorWriteMaskFlags{.red = true, .blue = true}</code>.</p><p>Read more about how this works: <a href=/2022/packed-structs-in-zig/>&ldquo;Packed structs in Zig make bit/flag sets trivial&rdquo;</a></p><h3 id=dawn-native-extensions>Dawn native extensions</h3><p>One not-so-friendly aspect of <code>webgpu.h</code> (the C API for WebGPU) is that it allows for arbitrary extension of the API via so-called chaining. For example, let&rsquo;s look at a descriptor struct used as the parameters to create a shader module from its text source code:</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=k>typedef</span> <span class=k>struct</span> <span class=n>WGPUShaderModuleDescriptor</span> <span class=p>{</span>
    <span class=n>WGPUChainedStruct</span> <span class=k>const</span> <span class=o>*</span> <span class=n>nextInChain</span><span class=p>;</span>
    <span class=kt>char</span> <span class=k>const</span> <span class=o>*</span> <span class=n>label</span><span class=p>;</span> <span class=c1>// nullable
</span><span class=c1></span><span class=p>}</span> <span class=n>WGPUShaderModuleDescriptor</span><span class=p>;</span>
</code></pre></div><p>Here you can obviously see there is a <code>label</code> for the shader module - but where does our shader source code go? It&rsquo;s not clear. And what goes in that <code>nextInChain</code> field? It looks like this:</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=k>typedef</span> <span class=k>struct</span> <span class=n>WGPUChainedStruct</span> <span class=p>{</span>
    <span class=k>struct</span> <span class=n>WGPUChainedStruct</span> <span class=k>const</span> <span class=o>*</span> <span class=n>next</span><span class=p>;</span>
    <span class=n>WGPUSType</span> <span class=n>sType</span><span class=p>;</span>
<span class=p>}</span> <span class=n>WGPUChainedStruct</span><span class=p>;</span>
</code></pre></div><p>Effectively, WebGPU implementations can take arbitrary data structures via this chaining process - as extensions to the WebGPU API for example - so long as the chained struct <em>begins with these ABI-compatible fields</em>.</p><p>For example-to construct a shader in Zig, you might write:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>const</span><span class=w> </span><span class=n>next_in_chain</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>c</span><span class=p>.</span><span class=n>WGPUShaderModuleWGSLDescriptor</span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=p>.</span><span class=n>chain</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>c</span><span class=p>.</span><span class=n>WGPUChainedStruct</span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=p>.</span><span class=n>next</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>,</span><span class=w> </span><span class=c1>// nothing else to chain
</span><span class=c1></span><span class=w>        </span><span class=p>.</span><span class=n>sType</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>c</span><span class=p>.</span><span class=n>WGPUSType_ShaderModuleWGSLDescriptor</span><span class=p>,</span><span class=w> </span><span class=c1>// so it knows what type we chained!
</span><span class=c1></span><span class=w>    </span><span class=p>},</span><span class=w>
</span><span class=w>    </span><span class=p>.</span><span class=n>source</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>my_shader_source_code_text</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=kr>const</span><span class=w> </span><span class=n>shader_module_descriptor</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>c</span><span class=p>.</span><span class=n>WGPUShaderModuleDescriptor</span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=p>.</span><span class=n>nextInChain</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>@ptrCast</span><span class=p>(</span><span class=o>?*</span><span class=kr>const</span><span class=w> </span><span class=n>c</span><span class=p>.</span><span class=n>WGPUChainedStruct</span><span class=p>,</span><span class=w> </span><span class=n>next_in_chain</span><span class=p>),</span><span class=w>
</span><span class=w>    </span><span class=p>.</span><span class=n>label</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;my shader module&#34;</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>};</span><span class=w>
</span></code></pre></div><p>That&rsquo;s pretty nasty! Also take note of how <code>nextInChain</code> needs to be <em>cast to</em> the <code>WGPUChainedStruct</code> pointer type, only the <code>sType</code> field identifies it (the C type system can&rsquo;t.)</p><p>More importantly: because <code>nextInChain</code> is an opaque type, you can&rsquo;t really know what type of pointer is legal at all to give to the API in a <code>nextInChain</code> field. Oof!</p><p>Needless to say, we didn&rsquo;t want to adopt this lack of type safety (and lack of documentation), so we worked with the Dawn developers at Google <a href="https://bugs.chromium.org/p/dawn/issues/detail?id=1486&q=reporter%3Ame&can=1">to add documentation about what structs are legal where</a>, and then in Zig we used this information to replace <code>next_in_chain</code> fields with a union of pointers so it&rsquo;s type safe (for all known structs) and self-documenting. Our example from before becomes just:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>const</span><span class=w> </span><span class=n>shader_module_descriptor</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>gpu</span><span class=p>.</span><span class=n>ShaderModule</span><span class=p>.</span><span class=n>Descriptor</span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=p>.</span><span class=n>next_in_chain</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>.{</span><span class=w>
</span><span class=w>        </span><span class=p>.</span><span class=n>wgsl_descriptor</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=p>.{.</span><span class=n>source</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>my_shader_source_code_text</span><span class=p>},</span><span class=w>
</span><span class=w>    </span><span class=p>},</span><span class=w>
</span><span class=w>    </span><span class=p>.</span><span class=n>label</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;my shader module&#34;</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>};</span><span class=w>
</span></code></pre></div><p>It may not seem much more readable, but all of the type system info is there to protect you and that&rsquo;s what counts. Of course, we also added a helper to create WGSL shader modules so this ends up being truly clean:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=n>device</span><span class=p>.</span><span class=n>createShaderModuleWGSL</span><span class=p>(</span><span class=s>&#34;my shader module&#34;</span><span class=p>,</span><span class=w> </span><span class=n>my_shader_source_code_text</span><span class=p>);</span><span class=w>
</span></code></pre></div><h3 id=upstreamed-patches-to-dawn>Upstreamed patches to Dawn</h3><p>Out of the box, Dawn needed a little love to be compiled with Zig as the C/C++ compiled - so we&rsquo;ve contributed patches upstream for this:</p><ul><li>Resolving some undefined behavior in Dawn caught by Zig using UBSAN by default. <a href=https://dawn-review.googlesource.com/c/dawn/+/87380>#87380</a></li><li>Improving constexpr compatibility for a DirectX constant, due to using MinGW DirectX headers. <a href=https://dawn-review.googlesource.com/c/dawn/+/87381>#87381</a></li><li>Correcting an invocation of <code>_uuidof</code> on Windows. <a href=https://dawn-review.googlesource.com/c/dawn/+/87309>#87309</a></li><li>Adding an option to disable use of (Windows 10+) Windows UI, as we don&rsquo;t have headers for it. <a href=https://dawn-review.googlesource.com/c/dawn/+/87383>#87383</a></li></ul><h3 id=obvious-improvements>Obvious improvements</h3><p>There were many other <a href=https://github.com/hexops/mach/tree/main/gpu>obvious improvements</a> we won&rsquo;t enumerate in detail here:</p><ul><li>Achieving 100% API coverage, and coming up with processes/rules/conventions to ensure this all remains up-to-date and correct going forward as Dawn&rsquo;s <code>webgpu.h</code> API changes.</li><li>Setting the right default values for every field in the entire API, which reduces verbosity of the API substantially.</li><li>Adding slice helpers where the C ABI uses pointers-and-lengths distinctly.</li><li>Adding type-safe helpers to callbacks which would have a <code>void*</code> userdata pointer in the C API.</li><li>Exposing every Dawn native extension, e.g. in anticipation of bindless support in the future.</li></ul><h2 id=standalone-repository>Standalone repository</h2><p>As with all <a href=https://github.com/hexops/mach/tree/main/libs>standalone Mach libraries</a> that reach a certain level of maturity, <code>mach/gpu</code> is now available in it&rsquo;s own standalone repository with an example using it with GLFW: <a href=https://github.com/hexops/mach-gpu>https://github.com/hexops/mach-gpu</a></p><h2 id=whats-next-browser-support-more-examples>What&rsquo;s next: browser support, more examples</h2><p>I&rsquo;d say we&rsquo;re well on our way to having a perfect WebGPU/Dawn API for Zig, but we do have a little ways to go. Things coming up include:</p><ul><li>More examples</li><li>Adding browser support: this will be achieved in the near future by direct WebAssembly->JS calls (not via Emscripten.)</li><li>Adding higher-level helpers (always 100% optional, the C ABI is always available and present via <code>gpu.Impl.foobar</code> methods.)</li></ul><p>We&rsquo;re continuing to work towards <a href=https://github.com/hexops/mach/issues/355>the Mach v0.2 release</a> otherwise (special thanks for all those contributing to Mach today!)</p><h2 id=thanks-for-reading>Thanks for reading</h2><div style=display:flex;flex-direction:row;align-items:center><img align=left style=max-height:12.5rem src=https://user-images.githubusercontent.com/3173176/187348488-0b52e87d-3a48-421c-9402-be78e32b5a20.png></img><ul><li>Join the <a href=https://discord.gg/XNG3NZgCqp>Mach Discord server</a></li><li>Check out the mach/gpu <a href=https://machengine.org/gpu>example showcase</a></li><li>Help us <a href=https://github.com/hexops/mach/issues/230>port/write more WebGPU examples</a> to Zig</li><li>Read up on WebGPU <a href=https://surma.dev/things/webgpu/>compute</a> and <a href=https://alain.xyz/blog/raw-webgpu>rendering</a></li><li><a href=https://github.com/sponsors/slimsag>Sponsor development</a> if you like what we're doing!</li></ul></div></div></main><script>function addAnchor(a){a.insertAdjacentHTML('afterbegin',`<a href="#${a.id}" class="hanchor" ariaLabel="Anchor">#</a> `)}document.addEventListener('DOMContentLoaded',function(){var a=document.querySelectorAll('h1[id], h2[id], h3[id], h4[id]');a&&a.forEach(addAnchor)})</script></div><div class=footer><div class=row-1><a href=https://hexops.com/privacy>Privacy matters</a>
<a href=https://github.com/sponsors/slimsag>Sponsor on GitHub</a>
<a href=https://machengine.org>machengine.org</a></div><div class=row-2><a href=/feed.xml><img alt="RSS feed" src="https://shields.io/badge/RSS-follow-green?logo=RSS"></a></div><div class=row-3><a href=https://hexops.com><img class="logo color-auto" alt="Hexops logo" src=https://raw.githubusercontent.com/hexops/media/234e15f265b19743c580a078b2d68660c92675d4/logo.svg height=50px></a></div></div></body></html>