<!doctype html><html><head><link rel=stylesheet href=https://devlog.hexops.com/assets/font/stylesheet.css><link rel=stylesheet href=https://devlog.hexops.com/main.959becff4f3640c2ba19521949a93832fa147f951930301c1c72e74e25823239.css><script async defer data-domain=hexops.com src=https://hexops.com/opendata.js></script><meta charset=utf-8><title>Packed structs in Zig make bit/flag sets trivial | Hexops' devlog</title><link rel=canonical href=https://devlog.hexops.com/2022/packed-structs-in-zig/><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><meta property="og:title" content="Packed structs in Zig make bit/flag sets trivial"><meta property="og:description" content="As we've been building Mach engine, we've been using a neat little pattern in Zig that enables writing flag sets more nicely in Zig than in other languages. Here's a brief explainer."><meta property="og:type" content="article"><meta property="og:url" content="https://devlog.hexops.com/2022/packed-structs-in-zig/"><meta property="og:image" content="https://user-images.githubusercontent.com/3173176/184735519-cc78d19d-73e8-4914-8f3d-fc3a15d00bb7.png"><meta property="article:section" content="2022"><meta property="article:published_time" content="2022-08-29T00:00:00+00:00"><meta property="article:modified_time" content="2022-08-29T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://user-images.githubusercontent.com/3173176/184735519-cc78d19d-73e8-4914-8f3d-fc3a15d00bb7.png"><meta name=twitter:title content="Packed structs in Zig make bit/flag sets trivial"><meta name=twitter:description content="As we've been building Mach engine, we've been using a neat little pattern in Zig that enables writing flag sets more nicely in Zig than in other languages. Here's a brief explainer."></head><body><div class=navbar><div class=content><a href=/ class=logo><img src=https://raw.githubusercontent.com/hexops/media/234e15f265b19743c580a078b2d68660c92675d4/logo.svg>' devlog</a><div><a href=https://hexops.com/about class=item>About</a>
<a href=/archives class=item>Archives</a>
<a href=https://github.com/hexops class=item>GitHub</a></div></div></div><div id=content><main aria-role=main class=main-single><div class=single><header class=header><h1>Packed structs in Zig make bit/flag sets trivial</h1><div class=metadata><time>August 29, 2022</time>
• <a class=category href=/categories/zig>zig</a>
• <a class=category href=/categories/zigtips>zigtips</a></div></header><p>As we&rsquo;ve been building <a href=https://machengine.org/>Mach engine</a>, we&rsquo;ve been using a neat little pattern in Zig that enables writing flag sets more nicely in Zig than in other languages.</p><h2 id=what-is-a-flag-set>What is a flag set?</h2><p>We&rsquo;ve been rewriting <code>mach/gpu</code> (WebGPU bindings for Zig) from scratch recently, so let&rsquo;s take a flag set from the WebGPU C API:</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=k>typedef</span> <span class=kt>uint32_t</span> <span class=n>WGPUFlags</span><span class=p>;</span>
<span class=k>typedef</span> <span class=n>WGPUFlags</span> <span class=n>WGPUColorWriteMaskFlags</span><span class=p>;</span>
</code></pre></div><p>Effectively, <code>WGPUColorWriteMaskFlags</code> here is a 32-bit unsigned integer where you can set specific bits in it to represent whether or not to write certain colors:</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=k>typedef</span> <span class=k>enum</span> <span class=n>WGPUColorWriteMask</span> <span class=p>{</span>
    <span class=n>WGPUColorWriteMask_None</span> <span class=o>=</span> <span class=mh>0x00000000</span><span class=p>,</span>
    <span class=n>WGPUColorWriteMask_Red</span> <span class=o>=</span> <span class=mh>0x00000001</span><span class=p>,</span>
    <span class=n>WGPUColorWriteMask_Green</span> <span class=o>=</span> <span class=mh>0x00000002</span><span class=p>,</span>
    <span class=n>WGPUColorWriteMask_Blue</span> <span class=o>=</span> <span class=mh>0x00000004</span><span class=p>,</span>
    <span class=n>WGPUColorWriteMask_Alpha</span> <span class=o>=</span> <span class=mh>0x00000008</span><span class=p>,</span>
    <span class=n>WGPUColorWriteMask_All</span> <span class=o>=</span> <span class=mh>0x0000000F</span><span class=p>,</span>
    <span class=n>WGPUColorWriteMask_Force32</span> <span class=o>=</span> <span class=mh>0x7FFFFFFF</span>
<span class=p>}</span> <span class=n>WGPUColorWriteMask</span><span class=p>;</span>
</code></pre></div><p>Then to use it you&rsquo;d use the various bit operations with those masks, e.g.:</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=n>WGPUColorWriteMaskFlags</span> <span class=n>mask</span> <span class=o>=</span> <span class=n>WGPUColorWriteMask_Red</span> <span class=o>|</span> <span class=n>WGPUColorWriteMask_Green</span><span class=p>;</span>
<span class=n>mask</span> <span class=o>|=</span> <span class=n>WGPUColorWriteMask_Blue</span><span class=p>;</span> <span class=c1>// set blue bit
</span></code></pre></div><p>This all works, people have been doing it for years in C, C++, Java, Rust, and more. In Zig, we can do better.</p><h2 id=zig-packed-structs>Zig packed structs</h2><p><img class=color-auto style=max-height:300px src=https://user-images.githubusercontent.com/3173176/184735519-cc78d19d-73e8-4914-8f3d-fc3a15d00bb7.png></p><p>Zig has <code>packed struct</code>s: these let us pack memory tightly, where a <code>bool</code> is actually a single bit (in most other languages, this is not true.) Zig also has arbitrary bit-width integers, like <code>u28</code>, <code>u1</code> and so on.</p><p>We can write <code>WGPUColorWriteMaskFlags</code> from earlier in Zig using:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>pub</span><span class=w> </span><span class=kr>const</span><span class=w> </span><span class=n>ColorWriteMaskFlags</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kr>packed</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>red</span><span class=o>:</span><span class=w> </span><span class=kt>bool</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>green</span><span class=o>:</span><span class=w> </span><span class=kt>bool</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>blue</span><span class=o>:</span><span class=w> </span><span class=kt>bool</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>alpha</span><span class=o>:</span><span class=w> </span><span class=kt>bool</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>,</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=n>_padding</span><span class=o>:</span><span class=w> </span><span class=n>u28</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>};</span><span class=w>
</span></code></pre></div><p>This is still just 32 bits of memory, and so can be passed to the same C APIs that expect a <code>WGPUColorWriteMaskFlags</code> - but interacting with it is much nicer:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>var</span><span class=w> </span><span class=n>mask</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ColorWriteMaskFlags</span><span class=p>{.</span><span class=n>red</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>,</span><span class=w> </span><span class=p>.</span><span class=n>green</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=n>mask</span><span class=p>.</span><span class=n>blue</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w> </span><span class=c1>// set blue bit
</span></code></pre></div><p>In C you would need to write code like this:</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=k>if</span> <span class=p>(</span><span class=n>mask</span> <span class=o>&amp;</span> <span class=n>WGPUColorWriteMask_Alpha</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// alpha is set..
</span><span class=c1></span><span class=p>}</span>
<span class=k>if</span> <span class=p>(</span><span class=n>mask</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>WGPUColorWriteMask_Alpha</span><span class=o>|</span><span class=n>WGPUColorWriteMask_Blue</span><span class=p>))</span> <span class=p>{</span>
    <span class=c1>// alpha and blue are set..
</span><span class=c1></span><span class=p>}</span>
<span class=k>if</span> <span class=p>((</span><span class=n>mask</span> <span class=o>&amp;</span> <span class=n>WGPUColorWriteMask_Green</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// green not set
</span><span class=c1></span><span class=p>}</span>
</code></pre></div><p>In Zig it&rsquo;s just:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>mask</span><span class=p>.</span><span class=n>alpha</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// alpha is set..
</span><span class=c1></span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>mask</span><span class=p>.</span><span class=n>alpha</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=n>mask</span><span class=p>.</span><span class=n>blue</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// alpha is set..
</span><span class=c1></span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>mask</span><span class=p>.</span><span class=n>green</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// green not set
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><h2 id=comptime-validation>Comptime validation</h2><p>Making sure that our <code>ColorWriteMaskFlags</code> ends up being the same size could be a bit tricky: what if we count the number of <code>bool</code> wrong? Or what if we accidently get the padding size wrong? Then it might not be the same size as a <code>uint32</code> anymore.</p><p>Luckily, we can verify our expectations at comptime:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>pub</span><span class=w> </span><span class=kr>const</span><span class=w> </span><span class=n>ColorWriteMaskFlags</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kr>packed</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>red</span><span class=o>:</span><span class=w> </span><span class=kt>bool</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>green</span><span class=o>:</span><span class=w> </span><span class=kt>bool</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>blue</span><span class=o>:</span><span class=w> </span><span class=kt>bool</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>alpha</span><span class=o>:</span><span class=w> </span><span class=kt>bool</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>,</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=n>_padding</span><span class=o>:</span><span class=w> </span><span class=n>u28</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=kr>comptime</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>std</span><span class=p>.</span><span class=n>debug</span><span class=p>.</span><span class=n>assert</span><span class=p>(</span><span class=nb>@sizeOf</span><span class=p>(</span><span class=nb>@This</span><span class=p>())</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=nb>@sizeOf</span><span class=p>(</span><span class=kt>u32</span><span class=p>));</span><span class=w>
</span><span class=w>        </span><span class=n>std</span><span class=p>.</span><span class=n>debug</span><span class=p>.</span><span class=n>assert</span><span class=p>(</span><span class=nb>@bitSizeOf</span><span class=p>(</span><span class=nb>@This</span><span class=p>())</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=nb>@bitSizeOf</span><span class=p>(</span><span class=kt>u32</span><span class=p>));</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>The Zig compiler will take care of running the <code>comptime</code> code block here for us when building, and it will verify that the byte size of <code>@This()</code> (the type we&rsquo;re inside of, the <code>ColorWriteMaskFlags</code> struct in this case) matches the <code>@sizeOf(u32)</code>.</p><p>Similarly we could check the <code>@bitSizeOf</code> both types if we like.</p><p>Note that <a href=https://ziglang.org/documentation/master/#sizeOf><code>@sizeOf</code></a> may include the size of padding for more complex types, while <a href=https://ziglang.org/documentation/master/#bitSizeOf><code>@bitSizeOf</code></a> returns the number of bits it takes to store <code>T</code> in memory <em>if the type were a field in a packed struct/union</em>. For flag sets like this, it doesn&rsquo;t matter and either will do. For more complex types, be sure to recall this.</p><h2 id=explicit-backing-integers-for-packed-structs>Explicit backing integers for packed structs</h2><p>It&rsquo;s worth noting that in Zig 0.10 (shipping in Nov), the new self-hosted compiler has support for <a href=https://github.com/ziglang/zig/pull/12379>explicit backing integers for packed structs</a> which will simplify this even further.</p><p>Instead of manually adding padding to make up 32 bits, one could simply write <code>packed struct(u32)</code>:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>pub</span><span class=w> </span><span class=kr>const</span><span class=w> </span><span class=n>ColorWriteMaskFlags</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kr>packed</span><span class=w> </span><span class=k>struct</span><span class=p>(</span><span class=kt>u32</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>red</span><span class=o>:</span><span class=w> </span><span class=kt>bool</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>green</span><span class=o>:</span><span class=w> </span><span class=kt>bool</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>blue</span><span class=o>:</span><span class=w> </span><span class=kt>bool</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>alpha</span><span class=o>:</span><span class=w> </span><span class=kt>bool</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><h2 id=thanks-for-reading>Thanks for reading</h2><p><img align=left style=max-height:150px src=https://user-images.githubusercontent.com/3173176/187348488-0b52e87d-3a48-421c-9402-be78e32b5a20.png></img>
Be sure to join the new <a href=https://discord.gg/XNG3NZgCqp>Mach engine Discord server</a> where we&rsquo;re building the future of Zig game development.<br><br>You can also <a href=https://github.com/sponsors/emidoots>sponsor my work</a> if you like what I&rsquo;m doing! :)</p><h2 id=but-c-has-had-bitfields-since-forever>&ldquo;But C has had bitfields since forever!&rdquo;</h2><p>Shortly after posting this article I was inundated with comments proclaiming &ldquo;But C has had bitfields since forever!&rdquo;</p><p>First, I&rsquo;d like to say I was not aware of C bitfields at the time of writing - I simply had not ever come across usage of them. Secondly, I&rsquo;d like to question: if C has bitfields, then why do seemingly all modern C APIs not use? Why do they all expose integer types instead?</p><p>And then I found the answer in the TC3 C specification:</p><img width=803 alt=image src=https://user-images.githubusercontent.com/3173176/189488251-738931cc-820a-4cd8-84d4-7320e3d870e6.png><p>As <a href="https://news.ycombinator.com/item?id=32648232">this user writes</a>:</p><blockquote><p>The in-memory representation of bit fields is implementation-defined. Therefore, if you&rsquo;re calling into an external API that takes a uint32_t like in the example without an explicit remapping, you may or may not like the results.</p><p>In practice, everything you&rsquo;re likely to come across will be little endian nowadays, and the ABI you&rsquo;re using will most likely order your struct from top to bottom in memory, so they will look the same most of the time. However, it&rsquo;s still technically not portable.</p></blockquote><p>My intention behind this article wasn&rsquo;t to say C is bad; but rather to say that I find Zig&rsquo;s packed structs quite nice. I actually come from a background mostly in Go - which absolutely does not have bitfields, packed structs, or arbitrary bit-width integers. Having never come across them in C either, my claims against C bitfields today could be summarized as:</p><ul><li>C&rsquo;s bitfields are more implementation-defined than Zig&rsquo;s.</li><li>C&rsquo;s bitfields being so implementation-defined, tend not to be used in modern APIs - so the fact that Zig has come up with a variant which <em>is used in practice in most APIs</em> is very important.</li></ul><p>In any case, I am not an expert in C bitfields! I just hate masking to check if bits are set, and the <a href="https://news.ycombinator.com/item?id=32646998">insane number of ways</a> that exact same logic can be written - both correctly and incorrectly. We deserve nicer syntax to check if a bit field is set out of the box, Zig provides that and I am happier for it.</p><p>Please stop messaging me about how C has bitfields :)</p></div></main><script>function addAnchor(a){a.insertAdjacentHTML('afterbegin',`<a href="#${a.id}" class="hanchor" ariaLabel="Anchor">#</a> `)}document.addEventListener('DOMContentLoaded',function(){var a=document.querySelectorAll('h1[id], h2[id], h3[id], h4[id]');a&&a.forEach(addAnchor)})</script></div><div class=footer><div class=row-1><a href=https://hexops.com/privacy>Privacy matters</a>
<a href=https://github.com/sponsors/emidoots>Sponsor on GitHub</a>
<a href=https://machengine.org>machengine.org</a></div><div class=row-2><a href=/feed.xml><img alt="RSS feed" src="https://shields.io/badge/RSS-follow-green?logo=RSS"></a></div><div class=row-3><a href=https://hexops.com><img class="logo color-auto" alt="Hexops logo" src=https://raw.githubusercontent.com/hexops/media/234e15f265b19743c580a078b2d68660c92675d4/logo.svg height=50px></a></div></div></body></html>