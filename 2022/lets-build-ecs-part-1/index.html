<!doctype html><html><head><link rel=stylesheet href=https://devlog.hexops.com/assets/font/stylesheet.css><link rel=stylesheet href=https://devlog.hexops.com/main.542172aae70a7994b0407dbd1f63f48ead97025b8fe9f77d87673847fca7629b.css><script async defer data-domain=hexops.com src=https://hexops.com/opendata.js></script><meta charset=utf-8><title>Let's build an Entity Component System from scratch (part 1) | Hexops' devlog</title><link rel=canonical href=https://devlog.hexops.com/2022/lets-build-ecs-part-1/><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><meta property="og:title" content="Let's build an Entity Component System from scratch (part 1)"><meta property="og:description" content="In this multi-part series we'll build the Entity Component System used in Mach engine in the Zig programming language from first principles (asking what an ECS is and walking through what problems it solves) all the way to writing an implementation in a low-level programming language. The only thing you need to follow along is some programming experience and a desire to learn."><meta property="og:type" content="article"><meta property="og:url" content="https://devlog.hexops.com/2022/lets-build-ecs-part-1/"><meta property="og:image" content="https://user-images.githubusercontent.com/3173176/149644281-df5a7846-eefb-4482-929b-2ac7243de7a2.png"><meta property="article:section" content="2022"><meta property="article:published_time" content="2022-01-16T00:00:00+00:00"><meta property="article:modified_time" content="2022-01-16T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://user-images.githubusercontent.com/3173176/149644281-df5a7846-eefb-4482-929b-2ac7243de7a2.png"><meta name=twitter:title content="Let's build an Entity Component System from scratch (part 1)"><meta name=twitter:description content="In this multi-part series we'll build the Entity Component System used in Mach engine in the Zig programming language from first principles (asking what an ECS is and walking through what problems it solves) all the way to writing an implementation in a low-level programming language. The only thing you need to follow along is some programming experience and a desire to learn."></head><body><div class=navbar><div class=content><a href=/ class=logo><img src=https://raw.githubusercontent.com/hexops/media/234e15f265b19743c580a078b2d68660c92675d4/logo.svg>' devlog</a><div><a href=https://hexops.com/about class=item>About</a>
<a href=/archives class=item>Archives</a>
<a href=https://github.com/hexops class=item>GitHub</a></div></div></div><div id=content><main aria-role=main class=main-single><div class=single><header class=header><h1>Let's build an Entity Component System from scratch (part 1)</h1><div class=metadata><time>January 16, 2022</time>
• <a class=category href=/categories/mach>mach</a>
• <a class=category href=/categories/zig>zig</a>
• <a class=category href=/categories/gamedev>gamedev</a>
• <a class=category href=/categories/ecs>ecs</a>
• <a class=category href=/categories/build-an-ecs>build-an-ecs</a></div></header><p>In this multi-part series we&rsquo;ll build the Entity Component System used in <a href=https://hexops.com/mach>Mach engine</a> in <a href=https://ziglang.org>the Zig programming language</a> from first principles (asking what an ECS is and walking through what problems it solves) all the way to writing an implementation in a low-level programming language. The only thing you need to follow along is some programming experience and a desire to learn.</p><p>In this article, we&rsquo;ll mostly go over the problem space, data oriented design, the things we need our ECS to solve, etc. In the next article, implementation will begin.</p><ul><li><a href=#motivation>Motivation</a></li><li><a href=#my-approach-to-complex-software-architecture>My approach to complex software architecture</a></li><li><a href=#what-really-is-an-entity-component-system-anyway>What really is an entity component system, anyway?</a></li><li><a href=#what-problems-does-an-ecs-solve>What problems does an ECS solve?</a></li><li><a href=#start-with-data-oriented-design>Start with data oriented design</a></li><li><a href=#what-would-data-oriented-design-look-like-code-starts-here>What would data oriented design look like? (code starts here!)</a></li><li><a href=#sparse-data-storage>Sparse data storage</a><ul><li><a href=#comptime-sparse-data>Comptime sparse data</a></li><li><a href=#runtime-sparse-data>Runtime sparse data</a></li><li><a href=#avoiding-unity-software-patents--improving-performance-while-doing-it>Avoiding Unity software patents & improving performance while doing it</a></li></ul></li><li><a href=#archetype-storage>Archetype storage</a><ul><li><a href=#comptime-archetype-storage>Comptime archetype storage</a></li><li><a href=#runtime-archetype-storage>Runtime archetype storage</a></li></ul></li><li><a href=#designing-our-ecs>Designing our ECS</a></li><li><a href=#next-up-starting-our-ecs-implementation>Next up: starting our ECS implementation</a></li></ul><h2 id=motivation>Motivation</h2><p><a class=imglink href=https://user-images.githubusercontent.com/3173176/149648955-ab99ff6f-79e6-4b03-9ca2-3f31fb000203.png><img class=color-auto src=https://user-images.githubusercontent.com/3173176/149648955-ab99ff6f-79e6-4b03-9ca2-3f31fb000203.png></a></p><p>I&rsquo;ve used and written more traditional <a href=https://en.wikipedia.org/wiki/Object-oriented_programming>OOP</a> <a href=https://en.wikipedia.org/wiki/Scene_graph>scene graphs</a> in the past. These are often the core engine architecture used to represent everything in game worlds: they&rsquo;re used in Unity historically (which is now migrating to ECS due to popular demand) and even <a href=https://godotengine.org/article/why-isnt-godot-ecs-based-game-engine>in other modern engines such as Godot</a>.</p><p>For <a href=https://hexops.com/mach>Mach engine</a>, however, we&rsquo;re adopting an ECS as our core architecture. ECS has gained great momentum in recent years for its composition and performance benefits.</p><h2 id=my-approach-to-complex-software-architecture>My approach to complex software architecture</h2><ol><li>What user problems does the proposed architecture (scene graphs, ECS, React-like frameworks, etc.) solve?</li><li>How does the proposed architecture <em>typically</em> solve such problems?</li></ol><p>The key point here is that, personally, I find it useful to intentionally avoid looking directly at code for the implementations themselves.</p><p><a class=imglink href=https://user-images.githubusercontent.com/3173176/149651958-a9c1d50e-77be-4098-ae91-4ed14dd95794.png><img class=color-auto src=https://user-images.githubusercontent.com/3173176/149651958-a9c1d50e-77be-4098-ae91-4ed14dd95794.png></a></p><p>I&rsquo;ve used this approach to <a href=https://github.com/hexops/vecty>to great success before</a>: the nice thing about this is that the end result really <em>fits the language</em>, using patterns and features specific to the language - it doesn&rsquo;t just end up feeling like a port of some other language&rsquo;s implementation.</p><p>I&rsquo;ve researched a bit about ECS in general, and have chatted with people familiar with ECS, but haven&rsquo;t read any other&rsquo;s code. No doubt, initially, I&rsquo;ll get some aspects wrong! As this series of articles progresses over the coming months, though, you&rsquo;ll see how this can be a winning tactic as we learn together!</p><h2 id=what-really-is-an-entity-component-system-anyway>What really is an entity component system, anyway?</h2><p><a class=imglink href=https://user-images.githubusercontent.com/3173176/149679322-f17012b1-4aed-484e-a27e-4b7823354912.png><img class=color-auto src=https://user-images.githubusercontent.com/3173176/149679322-f17012b1-4aed-484e-a27e-4b7823354912.png></a></p><p>I&rsquo;ve found the Rust project <a href=https://bevyengine.org/learn/book/getting-started/ecs/#bevy-ecs>Bevy ECS to have a great succinct explanation</a>, which I further simplify here:</p><ul><li><strong>Entities</strong>: a unique integer</li><li><strong>Components</strong>: structs of plain old data</li><li><strong>Systems</strong>: normal functions</li></ul><p>When you hear this, things may start to sounds a whole lot simpler! Those are the core concepts of an ECS.</p><p>There is one other concept of an ECS that I think is particularly important:</p><ul><li><strong>Archetype</strong>: A <em>chosen set of components</em> that an entity of a certain type will have.</li></ul><p><a class=imglink href=https://user-images.githubusercontent.com/3173176/149679390-e0a680f4-3299-4f96-b5b0-2165f390dbfb.png><img class=color-auto src=https://user-images.githubusercontent.com/3173176/149679390-e0a680f4-3299-4f96-b5b0-2165f390dbfb.png></a></p><h2 id=what-problems-does-an-ecs-solve>What problems does an ECS solve?</h2><p>I&rsquo;ve identified two problems it solves.</p><p><a class=imglink href=https://user-images.githubusercontent.com/3173176/149681141-eeed2594-fa40-46b7-8327-ca2a6143d98f.png><img class=color-auto src=https://user-images.githubusercontent.com/3173176/149681141-eeed2594-fa40-46b7-8327-ca2a6143d98f.png></a></p><p>First and foremost is <em>making it easy for game developers to architect their code</em> compared to them doing it manually. If it&rsquo;s easier for someone to structure their code themselves, manually, then such a system is not useful at all! Of course, as complexity and the scale of software increases then a <em>consistent</em> system is <em>far more useful</em> than a bunch of ad-hoc systems.</p><p>The second problem ECS solves, I believe, is making your software architecture <em>efficient</em> without you really having to think too much about it. You don&rsquo;t have to think about how to structure all your code & data for logic first, <em>and then for performance</em>, but rather get good performance by nature of following patterns.</p><h2 id=start-with-data-oriented-design>Start with data oriented design</h2><p><a class=imglink href=https://user-images.githubusercontent.com/3173176/149683974-e33f05b9-c1ad-46e1-9634-7996f39e18b8.png><img class=color-auto src=https://user-images.githubusercontent.com/3173176/149683974-e33f05b9-c1ad-46e1-9634-7996f39e18b8.png></a></p><p>ECS overlaps with <a href=https://dataorienteddesign.com/site.php><em>data oriented design</em></a> in many ways (although it&rsquo;s <a href=https://github.com/hexops/mach/issues/127#issuecomment-1014176503>roots are <em>much</em> earlier</a>). There are many talks about data oriented design including <a href="https://www.youtube.com/watch?v=rX0ItVEVjHc">Mike Acton&rsquo;s at CppCon</a>, and my personal favorite <a href=https://media.handmade-seattle.com/practical-data-oriented-design/>&ldquo;A Practical Guide to Applying Data-Oriented Design&rdquo;</a> by Andrew Kelley. You don&rsquo;t have to watch either, I&rsquo;ll cover the important concepts we use here. But I highly suggest <strong>every</strong> developer watch Andrew Kelley&rsquo;s talk above. It&rsquo;s eye opening no matter what kind of programming you are doing.</p><p>Let&rsquo;s work forwards, not backwards: We&rsquo;re not starting by building an ECS, we&rsquo;re starting by building a proper data oriented design for CPU cache and memory efficiency, and then we&rsquo;re working towards &ldquo;how do we make that easier for people to do by default?&rdquo; and looking to existing ECS architectures for inspiration.</p><h2 id=what-would-data-oriented-design-look-like-code-starts-here>What would data oriented design look like? (code starts here!)</h2><p>A simple first approach would be something like this:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>const</span><span class=w> </span><span class=n>Player</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>name</span><span class=o>:</span><span class=w> </span><span class=p>[]</span><span class=kr>const</span><span class=w> </span><span class=kt>u8</span><span class=p>,</span><span class=w> </span><span class=c1>// a string / byte slice
</span><span class=c1></span><span class=w>    </span><span class=n>location</span><span class=o>:</span><span class=w> </span><span class=n>Vec3</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>velocity</span><span class=o>:</span><span class=w> </span><span class=n>Vec3</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>health</span><span class=o>:</span><span class=w> </span><span class=kt>u8</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>team</span><span class=o>:</span><span class=w> </span><span class=n>Team</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>alive</span><span class=o>:</span><span class=w> </span><span class=kt>bool</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>};</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=kr>const</span><span class=w> </span><span class=n>Cat</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>name</span><span class=o>:</span><span class=w> </span><span class=p>[]</span><span class=kr>const</span><span class=w> </span><span class=kt>u8</span><span class=p>,</span><span class=w> </span><span class=c1>// a string / byte slice
</span><span class=c1></span><span class=w>    </span><span class=n>location</span><span class=o>:</span><span class=w> </span><span class=n>Vec3</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>};</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=kr>const</span><span class=w> </span><span class=n>Monster</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>location</span><span class=o>:</span><span class=w> </span><span class=n>Vec3</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>health</span><span class=o>:</span><span class=w> </span><span class=kt>u8</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>};</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=c1>// All the players, cats, monsters in our game world.
</span><span class=c1></span><span class=kr>var</span><span class=w> </span><span class=n>players</span><span class=o>:</span><span class=w> </span><span class=n>ArrayList</span><span class=p>(</span><span class=n>Player</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>.{};</span><span class=w>
</span><span class=w></span><span class=kr>var</span><span class=w> </span><span class=n>cats</span><span class=o>:</span><span class=w> </span><span class=n>ArrayList</span><span class=p>(</span><span class=n>Cat</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>.{};</span><span class=w>
</span><span class=w></span><span class=kr>var</span><span class=w> </span><span class=n>monsters</span><span class=o>:</span><span class=w> </span><span class=n>ArrayList</span><span class=p>(</span><span class=n>Monster</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>.{};</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=c1>// The index of a player in the players array, a cat in the cats array, etc.!
</span><span class=c1></span><span class=kr>const</span><span class=w> </span><span class=n>Entity</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kt>u32</span><span class=p>;</span><span class=w>
</span></code></pre></div><p>Now we can refer to players, cats, or monsters by using an entity ID (their index in the array), which we call an <em>entity</em>. We could also write functions (called systems) which iterate over these arrays and e.g. compute physics for players.</p><p>However, we can improve this quite a bit!</p><h2 id=sparse-data-storage>Sparse data storage</h2><h3 id=comptime-sparse-data>Comptime sparse data</h3><p>It&rsquo;s likely that most players will be alive in our game, only a few will be dead at a time - but yet we&rsquo;re paying the cost of storing which players are dead for <em>every living player</em> (via the <code>Player.alive</code> struct field)!</p><p>We can eliminate paying the cost of <code>alive: bool</code> per player by removing the field entirely, and having what I call <em>compile time sparse data</em> instead:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>var</span><span class=w> </span><span class=n>alive_players</span><span class=o>:</span><span class=w> </span><span class=n>ArrayList</span><span class=p>(</span><span class=n>Player</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>.{};</span><span class=w>
</span><span class=w></span><span class=kr>var</span><span class=w> </span><span class=n>dead_players</span><span class=o>:</span><span class=w> </span><span class=n>ArrayList</span><span class=p>(</span><span class=n>Player</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>.{};</span><span class=w>
</span></code></pre></div><p>This not only reduces the amount of memory each <code>Player</code> entity takes up because we no longer store an <code>alive: bool</code> per player, but also it:</p><ol><li>Improves performance by ensuring more players fit into L1/L2/L3 cache.</li><li>Reduces the amount of players we must skip (and reduces potential cache misses) because in some cases we might only be interested in alive players and have to skip over dead ones when iterating.</li></ol><p>This introduces some complexity for us to deal with, though:</p><ul><li>Now if a player goes from dead->alive, or alive->dead, we need logic to remove it from the old array and put it in the new one.</li><li>When we move a player from one array to another, the Entity ID we use to refer to that player (the array index) has changed! So if someone is storing a player Entity ID in order to have reference to it somewhere, we&rsquo;d need to have logic to update that.</li></ul><p>Now we start to see one thing our ECS needs to make simpler!</p><p>I call this type of data <em>comptime sparse data</em>.</p><h3 id=runtime-sparse-data>Runtime sparse data</h3><p>In an ideal world, we&rsquo;re able to pre-declare all sparse data at compile time like we did above:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>var</span><span class=w> </span><span class=n>alive_players</span><span class=o>:</span><span class=w> </span><span class=n>ArrayList</span><span class=p>(</span><span class=n>Player</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>.{};</span><span class=w>
</span><span class=w></span><span class=kr>var</span><span class=w> </span><span class=n>dead_players</span><span class=o>:</span><span class=w> </span><span class=n>ArrayList</span><span class=p>(</span><span class=n>Player</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>.{};</span><span class=w>
</span></code></pre></div><p>But sometimes, this just isn&rsquo;t possible:</p><ul><li>Maybe players in your game can give other players a customer nickname to display above their head. Again, for most players this won&rsquo;t be set - but for some players it will be! Ideally we don&rsquo;t have to pay the cost of storing a nickname string pointer for every player in the game without one</li><li>Maybe a handful of players out of thousands are given the speciality of having a custom weapon, they get to choose it&rsquo;s type, a custom name for it, and even the damage it should do! Where should we store that information?</li><li>&mldr;</li></ul><p>In this case, we could use a hash map:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>const</span><span class=w> </span><span class=n>PlayerNickname</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[]</span><span class=kr>const</span><span class=w> </span><span class=kt>u8</span><span class=p>;</span><span class=w> </span><span class=c1>// a string
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=kr>const</span><span class=w> </span><span class=n>Weapon</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>custom_name</span><span class=o>:</span><span class=w> </span><span class=p>[]</span><span class=kr>const</span><span class=w> </span><span class=kt>u8</span><span class=p>,</span><span class=w> </span><span class=c1>// a string
</span><span class=c1></span><span class=w>    </span><span class=kt>type</span><span class=o>:</span><span class=w> </span><span class=n>WeaponType</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>damage</span><span class=o>:</span><span class=w> </span><span class=kt>u8</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>};</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=kr>var</span><span class=w> </span><span class=n>players</span><span class=o>:</span><span class=w> </span><span class=n>ArrayList</span><span class=p>(</span><span class=n>Player</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>.{};</span><span class=w> </span><span class=c1>// all players
</span><span class=c1></span><span class=kr>var</span><span class=w> </span><span class=n>players_with_nicknames</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>AutoHashMap</span><span class=p>(</span><span class=n>Entity</span><span class=p>,</span><span class=w> </span><span class=n>PlayerNickname</span><span class=p>).</span><span class=n>init</span><span class=p>(</span><span class=n>allocator</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=kr>var</span><span class=w> </span><span class=n>players_with_weapons</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>AutoHashMap</span><span class=p>(</span><span class=n>Entity</span><span class=p>,</span><span class=w> </span><span class=n>Weapon</span><span class=p>).</span><span class=n>init</span><span class=p>(</span><span class=n>allocator</span><span class=p>);</span><span class=w>
</span></code></pre></div><p>Now we&rsquo;ve got a mapping of player Entity IDs -> their nicknames and weapons. We only pay the cost of storing this information for players that do actually have these specialties - not for every player.</p><p>I call this type of data <em>runtime sparse data</em>.</p><h3 id=avoiding-unity-software-patents--improving-performance-while-doing-it>Avoiding Unity software patents & improving performance while doing it</h3><p>Consider our player storage as it stands right now:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>const</span><span class=w> </span><span class=n>Player</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>name</span><span class=o>:</span><span class=w> </span><span class=p>[]</span><span class=kr>const</span><span class=w> </span><span class=kt>u8</span><span class=p>,</span><span class=w> </span><span class=c1>// a string / byte slice
</span><span class=c1></span><span class=w>    </span><span class=n>location</span><span class=o>:</span><span class=w> </span><span class=n>Vec3</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>velocity</span><span class=o>:</span><span class=w> </span><span class=n>Vec3</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>health</span><span class=o>:</span><span class=w> </span><span class=kt>u8</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>team</span><span class=o>:</span><span class=w> </span><span class=n>Team</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>};</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=kr>var</span><span class=w> </span><span class=n>players</span><span class=o>:</span><span class=w> </span><span class=n>ArrayList</span><span class=p>(</span><span class=n>Player</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>.{};</span><span class=w> </span><span class=c1>// all players
</span></code></pre></div><p>In a perfect world, software patents wouldn&rsquo;t exist. But, in our world, however, Unity makes 20 claims in their software patent covering ECS, including all code we&rsquo;ve written above to this point. Luckily, <a href=https://www.reddit.com/r/rust/comments/pjtpkj/unity_files_patent_for_ecs_in_game_engines_that/hbzaz61/>as the Bevy authors suggest here</a> entity component systems which store components in separate arrays are not affected by this (this is not legal advice)</p><p>Additionally, because of the way structs get laid out in memory with padding, our players array above would end up having a larger memory footprint than needed. So we actually benefit from using a separate array for every type of data (thanks, Unity!):</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>var</span><span class=w> </span><span class=n>player_names</span><span class=o>:</span><span class=w> </span><span class=n>ArrayList</span><span class=p>([]</span><span class=kr>const</span><span class=w> </span><span class=kt>u8</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>.{};</span><span class=w>
</span><span class=w></span><span class=kr>var</span><span class=w> </span><span class=n>player_locations</span><span class=o>:</span><span class=w> </span><span class=n>ArrayList</span><span class=p>(</span><span class=n>Vec3</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>.{};</span><span class=w>
</span><span class=w></span><span class=kr>var</span><span class=w> </span><span class=n>player_velocities</span><span class=o>:</span><span class=w> </span><span class=n>ArrayList</span><span class=p>(</span><span class=n>Vec3</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>.{};</span><span class=w>
</span><span class=w></span><span class=kr>var</span><span class=w> </span><span class=n>player_healths</span><span class=o>:</span><span class=w> </span><span class=n>ArrayList</span><span class=p>(</span><span class=kt>u8</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>.{};</span><span class=w>
</span><span class=w></span><span class=kr>var</span><span class=w> </span><span class=n>player_teams</span><span class=o>:</span><span class=w> </span><span class=n>ArrayList</span><span class=p>(</span><span class=n>Team</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>.{};</span><span class=w>
</span></code></pre></div><p>Luckily, we don&rsquo;t actually have to enumerate all our fields out like this: Zig has a nice <code>MultiArrayList</code> type which does this for us, we need change only one line:</p><div class=highlight><pre class=chroma><code class=language-diff data-lang=diff>const Player = struct {
    name: []const u8, // a string / byte slice
    location: Vec3,
    velocity: Vec3,
    health: u8,
    team: Team,
};

<span class=gd>-var players: ArrayList(Player) = .{}; // all players
</span><span class=gd></span><span class=gi>+var players: MultiArrayList(Player) = .{}; // all players
</span></code></pre></div><p>Not only does this use less memory, it also improves CPU cache efficiency a ton, especially when iterating over a lot of players to do work with them. If you&rsquo;re curious why, then you should watch Andrew Kelley&rsquo;s <a href=https://media.handmade-seattle.com/practical-data-oriented-design/>&ldquo;A Practical Guide to Applying Data-Oriented Design&rdquo;</a> talk!</p><h2 id=archetype-storage>Archetype storage</h2><h3 id=comptime-archetype-storage>Comptime archetype storage</h3><p>Up until now, we&rsquo;ve assumed we have pre-defined archetypes (&ldquo;player&rdquo;, &ldquo;cat&rdquo;, &ldquo;monster&rdquo;):</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=c1>// All the players, cats, monsters in our game world.
</span><span class=c1></span><span class=kr>var</span><span class=w> </span><span class=n>players</span><span class=o>:</span><span class=w> </span><span class=n>ArrayList</span><span class=p>(</span><span class=n>Player</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>.{};</span><span class=w>
</span><span class=w></span><span class=kr>var</span><span class=w> </span><span class=n>cats</span><span class=o>:</span><span class=w> </span><span class=n>ArrayList</span><span class=p>(</span><span class=n>Cat</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>.{};</span><span class=w>
</span><span class=w></span><span class=kr>var</span><span class=w> </span><span class=n>monsters</span><span class=o>:</span><span class=w> </span><span class=n>ArrayList</span><span class=p>(</span><span class=n>Monster</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>.{};</span><span class=w>
</span></code></pre></div><p>This is ideal: we don&rsquo;t need to ask the computer to do any work to find out where players, cats, or monsters are stored - we just <em>know at compile time</em> because <em>they&rsquo;re in that variable</em>. When someone uses our ECS, we could have them write a compile time function like:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=n>World</span><span class=p>(.{</span><span class=w>
</span><span class=w>    </span><span class=n>Player</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>Cat</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>Monster</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>})</span><span class=w>
</span></code></pre></div><p>And that&rsquo;s great because it means our ECS &ldquo;world&rdquo; can be aware ahead of time exactly which archetypes it needs to store. It could write out those <code>var players: ArrayList...</code> variables for us.</p><p>I call this <em>comptime archetype storage</em>.</p><h3 id=runtime-archetype-storage>Runtime archetype storage</h3><p>However, real games are much more complex: we might not really know at the time we&rsquo;re declaring the <code>World</code> all the different archetypes we plan on storing. Code gets messy. In some cases, maybe we even need to define some archetypes <em>of a common type</em> at runtime. For example, if we wanted to allow configuring <code>red</code> and <code>blue</code> here (or the number of teams) via a configuration file on disk or via a GUI:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>var</span><span class=w> </span><span class=n>red_team_players</span><span class=o>:</span><span class=w> </span><span class=n>ArrayList</span><span class=p>(</span><span class=n>Player</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>.{};</span><span class=w>
</span><span class=w></span><span class=kr>var</span><span class=w> </span><span class=n>blue_team_players</span><span class=o>:</span><span class=w> </span><span class=n>ArrayList</span><span class=p>(</span><span class=n>Player</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>.{};</span><span class=w>
</span></code></pre></div><p>Of course our <code>Player</code> could have a <code>team</code> field in it to represent the team, but there may be cases where storing <em>a separate list of entities</em> like this is needed without pre-declaring it. If we want to do that, we could use a hashmap:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>var</span><span class=w> </span><span class=n>runtime_archetypes</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>AutoHashMap</span><span class=p>([]</span><span class=kr>const</span><span class=w> </span><span class=kt>u8</span><span class=p>,</span><span class=w> </span><span class=o>*</span><span class=n>anyopaque</span><span class=p>).</span><span class=n>init</span><span class=p>(</span><span class=n>allocator</span><span class=p>);</span><span class=w>
</span></code></pre></div><p>In this model, we could store the <em>archtype string name</em> as the hashmap key (for example, the <code>@typeName(Player)</code> if we wanted, or maybe a custom name like <code>red</code>, <code>blue</code>, etc.). The value of the hashmap would need to be different types: an <code>ArrayList(Player)</code>, an <code>ArrayList(Monster)</code>, etc. and so we would store a type-erased <code>*anyopaque</code> (like a C <code>void*</code>) pointer. When we get a value out, we&rsquo;ll need to &ldquo;know&rdquo; what type of <code>ArrayList</code> to cast the pointer back to. It won&rsquo;t store that info for us.</p><p>I call this <em>runtime archetype storage</em>.</p><h2 id=designing-our-ecs>Designing our ECS</h2><p>We now start to see <em>some</em> of the things our ECS architecture should solve:</p><ul><li>Typed entity storage (how you interact with a list of players, monsters, etc.)</li><li>Sparse data: both comptime and runtime</li><li>Archetype storage: both comptime and runtime</li></ul><p>Additionally, these are the design principles I&rsquo;ve come up with:</p><ul><li>Clean-room implementation (I&rsquo;ve not read any other ECS implementation code.)</li><li>Solve the problems ECS solves, in a way that is natural to Zig and leverages Zig comptime.</li><li>Avoid patent infringement upon Unity ECS patent claims.</li><li>Fast. Optimal for CPU caches, multi-threaded, leverage comptime as much as is reasonable.</li><li>Simple. Small API footprint, should be natural and fun - not like you&rsquo;re writing boilerplate.</li><li>Enable other libraries to provide tracing, editors, visualizers, profilers, etc.</li></ul><p>From this, you can easily gather that storing entities is actually only a small (but critical) portion of this system. In the next article we will get into the details of implementing this in code, and go on to explore more challenging topics like multi-threading, systems, and scheduling in future articles.</p><h2 id=next-up-starting-our-ecs-implementation>Next up: starting our ECS implementation</h2><p>As this series develops, all the code is being developed in the Mach repository&rsquo;s <code>ecs</code> subfolder <a href=https://github.com/hexops/mach/tree/main/ecs>on GitHub</a>. The articles will lag slightly behind.</p><p><a href=https://devlog.hexops.com/categories/lets-build-an-ecs>As more articles come out, you can find them here</a>. Join us in developing it, give us advice, etc. <a href=https://matrix.to/#/#ecs:matrix.org>on Matrix chat</a> or <a href=https://twitter.com/machengine>follow updates on Twitter</a>.</p><p>If you like what I&rsquo;m doing, you can <a href=https://github.com/sponsors/slimsag>sponsor me on GitHub</a>.</p></div></main><script>function addAnchor(a){a.insertAdjacentHTML('afterbegin',`<a href="#${a.id}" class="hanchor" ariaLabel="Anchor">#</a> `)}document.addEventListener('DOMContentLoaded',function(){var a=document.querySelectorAll('h1[id], h2[id], h3[id], h4[id]');a&&a.forEach(addAnchor)})</script></div><div class=footer><div class=row-1><a href=https://hexops.com/privacy>Privacy matters</a>
<a href=https://github.com/sponsors/slimsag>Sponsor on GitHub</a>
<a href=https://machengine.org>machengine.org</a></div><div class=row-2><a href=/feed.xml><img alt="RSS feed" src="https://shields.io/badge/RSS-follow-green?logo=RSS"></a></div><div class=row-3><a href=https://hexops.com><img class="logo color-auto" alt="Hexops logo" src=https://raw.githubusercontent.com/hexops/media/234e15f265b19743c580a078b2d68660c92675d4/logo.svg height=50px></a></div></div></body></html>