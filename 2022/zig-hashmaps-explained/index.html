<!doctype html><html><head><link rel=stylesheet href=https://devlog.hexops.com/assets/font/stylesheet.css><link rel=stylesheet href=https://devlog.hexops.com/main.959becff4f3640c2ba19521949a93832fa147f951930301c1c72e74e25823239.css><script async defer data-domain=hexops.com src=https://hexops.com/opendata.js></script><meta charset=utf-8><title>Zig hashmaps explained | Hexops' devlog</title><link rel=canonical href=https://devlog.hexops.com/2022/zig-hashmaps-explained/><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><meta property="og:title" content="Zig hashmaps explained"><meta property="og:description" content="If you just got started with Zig, you might quickly want to use a hashmap. Zig provides good defaults, with a lot of customization options."><meta property="og:type" content="article"><meta property="og:url" content="https://devlog.hexops.com/2022/zig-hashmaps-explained/"><meta property="og:image" content="https://devlog.hexops.com/img/hexops-opengraph.png"><meta property="article:section" content="2022"><meta property="article:published_time" content="2022-01-29T00:00:00+00:00"><meta property="article:modified_time" content="2022-01-29T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://devlog.hexops.com/img/hexops-opengraph.png"><meta name=twitter:title content="Zig hashmaps explained"><meta name=twitter:description content="If you just got started with Zig, you might quickly want to use a hashmap. Zig provides good defaults, with a lot of customization options."></head><body><div class=navbar><div class=content><a href=/ class=logo><img src=https://raw.githubusercontent.com/hexops/media/234e15f265b19743c580a078b2d68660c92675d4/logo.svg>' devlog</a><div><a href=https://hexops.com/about class=item>About</a>
<a href=/archives class=item>Archives</a>
<a href=https://github.com/hexops class=item>GitHub</a></div></div></div><div id=content><main aria-role=main class=main-single><div class=single><header class=header><h1>Zig hashmaps explained</h1><div class=metadata><time>January 29, 2022</time>
• <a class=category href=/categories/zig>zig</a>
• <a class=category href=/categories/zigtips>zigtips</a></div></header><p>If you just got started with <a href=https://ziglang.org>Zig</a>, you might quickly want to use a hashmap. Zig provides good defaults, with a lot of customization options.</p><p>Here I will try to guide you into choosing the right hashmap type.</p><h2 id=60-second-explainer>60-second explainer</h2><p>You probably want:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>var</span><span class=w> </span><span class=n>my_hash_map</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>std</span><span class=p>.</span><span class=n>StringHashMap</span><span class=p>(</span><span class=n>V</span><span class=p>).</span><span class=n>init</span><span class=p>(</span><span class=n>allocator</span><span class=p>);</span><span class=w>
</span></code></pre></div><p>Or if you do not have string keys, you can use an <code>Auto</code> hashmap instead:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>var</span><span class=w> </span><span class=n>my_hash_map</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>std</span><span class=p>.</span><span class=n>AutoHashMap</span><span class=p>(</span><span class=n>K</span><span class=p>,</span><span class=w> </span><span class=n>V</span><span class=p>).</span><span class=n>init</span><span class=p>(</span><span class=n>allocator</span><span class=p>);</span><span class=w>
</span></code></pre></div><p>Where <code>K</code> and <code>V</code> are your key and value data types, respectively. e.g. <code>[]const u8</code> for a string.</p><p>You can then use these APIs:</p><h3 id=insert-a-value>Insert a value</h3><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=k>try</span><span class=w> </span><span class=n>my_hash_map</span><span class=p>.</span><span class=n>put</span><span class=p>(</span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=n>value</span><span class=p>);</span><span class=w>
</span></code></pre></div><h3 id=insert-a-value-assert-entry-does-not-already-exist>Insert a value, assert entry does not already exist</h3><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=k>try</span><span class=w> </span><span class=n>my_hash_map</span><span class=p>.</span><span class=n>putNoClobber</span><span class=p>(</span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=n>value</span><span class=p>);</span><span class=w>
</span></code></pre></div><p>Note <code>putNoClobber</code> may be renamed to something like <code>putAssumeNoEntry</code> in the near future: <a href=https://github.com/ziglang/zig/issues/10736>ziglang/zig#10736</a></p><h3 id=get-a-value>Get a value</h3><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>var</span><span class=w> </span><span class=n>value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>my_hash_map</span><span class=p>.</span><span class=n>get</span><span class=p>(</span><span class=n>key</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>value</span><span class=p>)</span><span class=w> </span><span class=o>|</span><span class=n>v</span><span class=o>|</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// got value &#34;v&#34;
</span><span class=c1></span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// doesn&#39;t exist
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><h3 id=get-a-value-insert-if-not-exist>Get a value, insert if not exist</h3><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>var</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>try</span><span class=w> </span><span class=n>my_hash_map</span><span class=p>.</span><span class=n>getOrPut</span><span class=p>(</span><span class=n>key</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>v</span><span class=p>.</span><span class=n>found_existing</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// We inserted an entry, specify the new value
</span><span class=c1></span><span class=w>    </span><span class=c1>// This is a conditional in case creating the new value is expensive
</span><span class=c1></span><span class=w>    </span><span class=n>v</span><span class=p>.</span><span class=n>value_ptr</span><span class=p>.</span><span class=o>*</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;my value&#34;</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=kr>var</span><span class=w> </span><span class=n>value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>v</span><span class=p>.</span><span class=n>value_ptr</span><span class=p>.</span><span class=o>*</span><span class=p>;</span><span class=w> </span><span class=c1>// use the value
</span></code></pre></div><p>You can find more APIs <a href=https://github.com/ziglang/zig/blob/master/lib/std/hash_map.zig#L342>by going here</a> and using your browser&rsquo;s builtin search for <code>pub fn</code>.</p><h2 id=about-key-data-types>About key data types</h2><p>Zig hash map types start with the data type of the key:</p><ul><li><code>std.StringHashMap</code> - uses a good default hashing function for string keys</li><li><code>std.AutoHashMap</code> - uses a good default hashing function for most data types</li><li><code>std.HashMap</code> - the &ldquo;bring your own hashing function&rdquo; option</li></ul><p>Note: <code>AutoHashMap</code> does not support <em>slices</em>, such as <code>[]const u8</code> string slices, because that is a pointer to an array and it is ambiguous whether or not you intend to hash <em>the array elements</em> or <em>the pointer itself</em>. You can use the generic <code>std.HashMap</code> for any slice type, you just have to provide your own hash functions.</p><h2 id=hashmaps-are-also-sets>Hashmaps are also sets</h2><p>A set in Zig is just a hashmap with a <code>void</code> value:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>var</span><span class=w> </span><span class=n>my_hash_map</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>std</span><span class=p>.</span><span class=n>AutoHashMap</span><span class=p>(</span><span class=n>K</span><span class=p>,</span><span class=w> </span><span class=kt>void</span><span class=p>).</span><span class=n>init</span><span class=p>(</span><span class=n>allocator</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>try</span><span class=w> </span><span class=n>my_hash_map</span><span class=p>.</span><span class=n>put</span><span class=p>(</span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=p>{});</span><span class=w> </span><span class=c1>// `{}` is a value of type `void`
</span></code></pre></div><h2 id=advanced-usages>Advanced usages</h2><p>If you&rsquo;re just getting started with Zig, don&rsquo;t worry too much about the below. Just know that you have options available should you need to reduce memory usage or optimize your use of hashmaps in the future.</p><h3 id=managed-vs-unmanaged-hashmaps>Managed vs. unmanaged hashmaps</h3><p>You can add <code>Unmanaged</code> to the end of a Zig hashmap data type, e.g. <code>std.StringHashMapUnmanaged</code> in order to get the <em>unmanaged</em> version.</p><p>This merely doesn&rsquo;t carry an <code>allocator</code> internally, instead you must pass the allocator into every method of the hashmap. While only a few bytes, this can be a useful optimization if you&rsquo;re storing many hashmaps for example.</p><p>Managed:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>var</span><span class=w> </span><span class=n>my_hash_map</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>std</span><span class=p>.</span><span class=n>StringHashMap</span><span class=p>(</span><span class=n>V</span><span class=p>).</span><span class=n>init</span><span class=p>(</span><span class=n>allocator</span><span class=p>);</span><span class=w>
</span></code></pre></div><p>Unmanaged:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>var</span><span class=w> </span><span class=n>my_hash_map</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>std</span><span class=p>.</span><span class=n>StringHashMapUnmanaged</span><span class=p>(</span><span class=n>V</span><span class=p>){};</span><span class=w>
</span></code></pre></div><h3 id=array-hash-maps>Array hash maps</h3><p>Zig actually provides <a href=https://github.com/ziglang/zig/pull/5999><em>two hashmap implementations</em></a> in the standard library</p><p><code>std.HashMap</code>, perfect for every-day use cases:</p><ul><li>Optimized for lookup times primarily</li><li>Optimized for insertion/removal times secondarily</li></ul><p><code>std.ArrayHashMap</code>, useful in <em>some</em> situations:</p><ul><li>Iterating over the hashmap is an order of magnitude faster (a contiguous array)</li><li>Insertion order is preserved.</li><li>You can index into the underlying data like an array if you like</li><li>Deletions can be performed one of two ways, mirroring the <code>ArrayList</code> API:<ul><li><code>swapRemove</code>: swaps the target element with the last element in the list to remove it</li><li><code>orderedRemove</code>: removes target element by shifting all elements forward, maintaining current ordering</li></ul></li></ul><h3 id=hashmap-context>Hashmap context</h3><p>If you choose to use <code>std.HashMap</code> or <code>std.ArrayHashMap</code> directly (without the <code>String</code> or <code>Auto</code> prefix), then you&rsquo;ll find it wants a <em>context</em> parameter and <em>max load percentage</em>:</p><div class=highlight><pre class=chroma><code class=language-zig data-lang=zig><span class=kr>var</span><span class=w> </span><span class=n>my_hash_map</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>std</span><span class=p>.</span><span class=n>HashMap</span><span class=p>(</span><span class=n>K</span><span class=p>,</span><span class=w> </span><span class=n>V</span><span class=p>,</span><span class=w> </span><span class=n>std</span><span class=p>.</span><span class=n>hash_map</span><span class=p>.</span><span class=n>AutoContext</span><span class=p>(</span><span class=n>K</span><span class=p>),</span><span class=w> </span><span class=n>std</span><span class=p>.</span><span class=n>hash_map</span><span class=p>.</span><span class=n>default_max_load_percentage</span><span class=p>);</span><span class=w>
</span></code></pre></div><p>The <em>context</em> parameter lets you embed some of your own data within the hash map type. This can be useful for <a href=https://zig.news/andrewrk/how-to-use-hash-map-contexts-to-save-memory-when-doing-a-string-table-3l33>reducing the amount of memory that a hash map takes up when doing a string table</a>.</p><h3 id=pick-your-hashmap>Pick your hashmap</h3><p>Regular implementation:</p><table><thead><tr><th>Key type</th><th>Managed?</th><th>How to initialize</th></tr></thead><tbody><tr><td><code>String</code></td><td>yes</td><td><code>std.StringHashMap(V).init(allocator)</code></td></tr><tr><td><code>Auto</code></td><td>yes</td><td><code>std.AutoHashMap(K, V).init(allocator)</code></td></tr><tr><td><code>String</code></td><td><code>Unmanaged</code></td><td><code>std.StringHashMapUnmanaged(V){}</code></td></tr><tr><td><code>Auto</code></td><td><code>Unmanaged</code></td><td><code>std.AutoHashMapUnmanaged(K, V){}</code></td></tr></tbody></table><p><code>ArrayHashMap</code> implementation:</p><table><thead><tr><th>Key type</th><th>Managed?</th><th>How to initialize</th></tr></thead><tbody><tr><td><code>String</code></td><td>yes</td><td><code>std.StringArrayHashMap(V).init(allocator)</code></td></tr><tr><td><code>Auto</code></td><td>yes</td><td><code>std.AutoArrayHashMap(K, V).init(allocator)</code></td></tr><tr><td><code>String</code></td><td><code>Unmanaged</code></td><td><code>std.StringArrayHashMapUnmanaged(V){}</code></td></tr><tr><td><code>Auto</code></td><td><code>Unmanaged</code></td><td><code>std.AutoArrayHashMapUnmanaged(K, V){}</code></td></tr></tbody></table><h3 id=learn-more>Learn more</h3><p>The source code is very readable:</p><ul><li><a href=https://github.com/ziglang/zig/blob/master/lib/std/hash_map.zig><code>std.HashMap</code></a></li><li><a href=https://github.com/ziglang/zig/blob/master/lib/std/hash_map.zig><code>std.ArrayHashMap</code></a></li></ul><h3 id=help-improve-this-page>Help improve this page</h3><p>I wrote this article quickly because I needed to explain my choice of hashmaps in the <a href=https://devlog.hexops.com/categories/build-an-ecs/>&ldquo;Let&rsquo;s build an Entity Component System from scratch&rdquo;</a> series and there was no better source of this info. I&rsquo;m sure there are things that can be improved.</p><p><a href=https://github.com/hexops/devlog/blob/main/_posts/2022-01-29-zig-hashmaps-explained.md>Feel free to send a PR!</a></p></div></main><script>function addAnchor(a){a.insertAdjacentHTML('afterbegin',`<a href="#${a.id}" class="hanchor" ariaLabel="Anchor">#</a> `)}document.addEventListener('DOMContentLoaded',function(){var a=document.querySelectorAll('h1[id], h2[id], h3[id], h4[id]');a&&a.forEach(addAnchor)})</script></div><div class=footer><div class=row-1><a href=https://hexops.com/privacy>Privacy matters</a>
<a href=https://github.com/sponsors/slimsag>Sponsor on GitHub</a>
<a href=https://machengine.org>machengine.org</a></div><div class=row-2><a href=/feed.xml><img alt="RSS feed" src="https://shields.io/badge/RSS-follow-green?logo=RSS"></a></div><div class=row-3><a href=https://hexops.com><img class="logo color-auto" alt="Hexops logo" src=https://raw.githubusercontent.com/hexops/media/234e15f265b19743c580a078b2d68660c92675d4/logo.svg height=50px></a></div></div></body></html>